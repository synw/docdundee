import { defineComponent as ae, ref as be, onBeforeMount as Er, resolveComponent as go, openBlock as D, createElementBlock as q, normalizeClass as Oe, createElementVNode as F, toDisplayString as rn, Fragment as oe, renderList as ie, createVNode as _e, createCommentVNode as W, pushScopeId as wr, popScopeId as Ar, computed as Qn, unref as ne, reactive as et, onBeforeUnmount as bo, watchEffect as pn, withKeys as _o, withModifiers as mo, createBlock as we, shallowRef as vo, getCurrentScope as xo, onScopeDispose as ko, createTextVNode as hn, nextTick as yo, normalizeStyle as Eo, withDirectives as wo, isRef as Ao, vModelText as Co, watch as mt, renderSlot as So, withCtx as Do } from "vue";
const Cr = (n) => (wr("data-v-a9e8c92d"), n = n(), Ar(), n), Ro = {
  key: 0,
  xmlns: "http://www.w3.org/2000/svg",
  width: "15",
  height: "15",
  viewBox: "0 0 256 256"
}, To = /* @__PURE__ */ Cr(() => /* @__PURE__ */ F("path", {
  fill: "currentColor",
  d: "M96 220a12.2 12.2 0 0 1-8.5-3.5a12 12 0 0 1 0-17L159 128L87.5 56.5a12 12 0 0 1 17-17l80 80a12 12 0 0 1 0 17l-80 80A12.2 12.2 0 0 1 96 220Z"
}, null, -1)), Mo = [
  To
], No = {
  key: 1,
  xmlns: "http://www.w3.org/2000/svg",
  width: "15",
  height: "15",
  viewBox: "0 0 256 256"
}, qo = /* @__PURE__ */ Cr(() => /* @__PURE__ */ F("path", {
  fill: "currentColor",
  d: "M128 188a12.2 12.2 0 0 1-8.5-3.5l-80-80a12 12 0 0 1 17-17L128 159l71.5-71.5a12 12 0 0 1 17 17l-80 80a12.2 12.2 0 0 1-8.5 3.5Z"
}, null, -1)), Lo = [
  qo
], Oo = { class: "ml-2" }, Io = { key: 0 }, Bo = { key: 1 }, Fo = { key: 0 }, $o = { class: "nav-item-hspace" }, Po = ["onClick"], zo = { key: 1 }, Ho = { class: "nav-item-hspace" }, Uo = ["onClick"], jo = /* @__PURE__ */ ae({
  __name: "AutoNavNode",
  props: {
    node: {
      type: Object,
      required: !0
    },
    level: {
      type: Number,
      default: 0
    },
    startState: {
      type: String,
      default: "one"
    },
    onOpen: {
      type: Function,
      required: !0
    }
  },
  setup(n) {
    const e = n, t = be(!0);
    function r() {
      t.value = !t.value;
    }
    return Er(() => {
      (e.startState == "all" || e.startState == "one" && e.level == 0) && (t.value = !1);
    }), (s, c) => {
      var o;
      const i = go("AutoNavNode", !0);
      return D(), q("div", {
        class: Oe(n.level > 0 ? ["nav-header-hspace", `navnode-${n.level}`] : [`navnode-${n.level}`])
      }, [
        F("button", {
          class: Oe(["flex items-center w-full btn navnode-header", t.value ? ["navnode-closed"] : ["navnode-opened"]]),
          onClick: c[0] || (c[0] = (a) => r())
        }, [
          F("div", null, [
            t.value === !0 ? (D(), q("svg", Ro, Mo)) : (D(), q("svg", No, Lo))
          ]),
          F("div", Oo, rn(n.node.title), 1)
        ], 2),
        F("div", {
          class: Oe([t.value ? [
            "slideup",
            "navnode-closed"
          ] : [
            "slidedown",
            "navnode-opened"
          ], "duration-100 slide-y navnode-content"])
        }, [
          (((o = n.node) == null ? void 0 : o.children) ?? []).length > 0 ? (D(), q("div", Io, [
            (D(!0), q(oe, null, ie(n.node.children, (a) => (D(), q("div", null, [
              _e(i, {
                "on-open": n.onOpen,
                node: a,
                level: n.level + 1,
                "start-state": n.startState
              }, null, 8, ["on-open", "node", "level", "start-state"])
            ]))), 256))
          ])) : (D(), q("div", Bo, [
            (n.node.content ?? []).length > 0 ? (D(), q("div", Fo, [
              (D(!0), q(oe, null, ie(n.node.content, (a) => (D(), q("div", $o, [
                F("button", {
                  class: "py-1 focus:ring-0 btn navnode-item navnode-md",
                  onClick: (l) => n.onOpen(a.url)
                }, rn(a.title), 9, Po)
              ]))), 256))
            ])) : W("", !0),
            (n.node.docstrings ?? []).length > 0 ? (D(), q("div", zo, [
              (D(!0), q(oe, null, ie(n.node.docstrings, (a) => (D(), q("div", Ho, [
                F("button", {
                  class: "py-1 focus:ring-0 btn navnode-item navnode-docstring",
                  onClick: (l) => n.onOpen(a.url)
                }, rn(a.name), 9, Uo)
              ]))), 256))
            ])) : W("", !0)
          ]))
        ], 2)
      ], 2);
    };
  }
});
const Sr = (n, e) => {
  const t = n.__vccOpts || n;
  for (const [r, s] of e)
    t[r] = s;
  return t;
}, Go = /* @__PURE__ */ Sr(jo, [["__scopeId", "data-v-a9e8c92d"]]), Vo = { class: "flex flex-col" }, a7 = /* @__PURE__ */ ae({
  __name: "AutoNav",
  props: {
    nodes: {
      type: Object,
      required: !0
    },
    startState: {
      type: String,
      default: "one"
    },
    onOpen: {
      type: Function,
      required: !0
    }
  },
  setup(n) {
    return (e, t) => (D(), q("div", Vo, [
      (D(!0), q(oe, null, ie(n.nodes, (r) => (D(), q("div", null, [
        _e(Go, {
          node: r,
          "start-state": n.startState,
          "on-open": n.onOpen
        }, null, 8, ["node", "start-state", "on-open"])
      ]))), 256))
    ]));
  }
}), Zo = ["innerHTML", "onClick"], Ko = ["innerHTML", "onClick"], l7 = /* @__PURE__ */ ae({
  __name: "RenderNavNode",
  props: {
    node: {
      type: Object,
      required: !0
    },
    onOpen: {
      type: Function,
      required: !0
    }
  },
  setup(n) {
    const e = n;
    function t(r) {
      e.onOpen(r);
    }
    return (r, s) => (D(), q("div", null, [
      n.node.content.length > 0 ? (D(!0), q(oe, { key: 0 }, ie(n.node.content, (c) => (D(), q("div", null, [
        F("button", {
          class: "px-1 text-left truncate cursor-pointer btn",
          innerHTML: c.title,
          onClick: (i) => t(c.url)
        }, null, 8, Zo)
      ]))), 256)) : W("", !0),
      n.node.docstrings.length > 0 ? (D(!0), q(oe, { key: 1 }, ie(n.node.docstrings, (c) => (D(), q("div", null, [
        F("button", {
          class: "px-1 truncate cursor-pointer btn",
          innerHTML: c.title,
          onClick: (i) => t(n.node.url + "/" + c.name)
        }, null, 8, Ko)
      ]))), 256)) : W("", !0)
    ]));
  }
});
function Wo(n) {
  return n && n.__esModule && Object.prototype.hasOwnProperty.call(n, "default") ? n.default : n;
}
function Yo(n) {
  if (n.__esModule)
    return n;
  var e = n.default;
  if (typeof e == "function") {
    var t = function r() {
      if (this instanceof r) {
        var s = [null];
        s.push.apply(s, arguments);
        var c = Function.bind.apply(e, s);
        return new c();
      }
      return e.apply(this, arguments);
    };
    t.prototype = e.prototype;
  } else
    t = {};
  return Object.defineProperty(t, "__esModule", { value: !0 }), Object.keys(n).forEach(function(r) {
    var s = Object.getOwnPropertyDescriptor(n, r);
    Object.defineProperty(t, r, s.get ? s : {
      enumerable: !0,
      get: function() {
        return n[r];
      }
    });
  }), t;
}
var Kn = {}, Jo = {
  get exports() {
    return Kn;
  },
  set exports(n) {
    Kn = n;
  }
}, H = {}, on = {}, Xo = {
  get exports() {
    return on;
  },
  set exports(n) {
    on = n;
  }
};
const Qo = "Á", es = "á", ns = "Ă", ts = "ă", rs = "∾", os = "∿", ss = "∾̳", cs = "Â", is = "â", as = "´", ls = "А", us = "а", fs = "Æ", ps = "æ", hs = "⁡", ds = "𝔄", gs = "𝔞", bs = "À", _s = "à", ms = "ℵ", vs = "ℵ", xs = "Α", ks = "α", ys = "Ā", Es = "ā", ws = "⨿", As = "&", Cs = "&", Ss = "⩕", Ds = "⩓", Rs = "∧", Ts = "⩜", Ms = "⩘", Ns = "⩚", qs = "∠", Ls = "⦤", Os = "∠", Is = "⦨", Bs = "⦩", Fs = "⦪", $s = "⦫", Ps = "⦬", zs = "⦭", Hs = "⦮", Us = "⦯", js = "∡", Gs = "∟", Vs = "⊾", Zs = "⦝", Ks = "∢", Ws = "Å", Ys = "⍼", Js = "Ą", Xs = "ą", Qs = "𝔸", ec = "𝕒", nc = "⩯", tc = "≈", rc = "⩰", oc = "≊", sc = "≋", cc = "'", ic = "⁡", ac = "≈", lc = "≊", uc = "Å", fc = "å", pc = "𝒜", hc = "𝒶", dc = "≔", gc = "*", bc = "≈", _c = "≍", mc = "Ã", vc = "ã", xc = "Ä", kc = "ä", yc = "∳", Ec = "⨑", wc = "≌", Ac = "϶", Cc = "‵", Sc = "∽", Dc = "⋍", Rc = "∖", Tc = "⫧", Mc = "⊽", Nc = "⌅", qc = "⌆", Lc = "⌅", Oc = "⎵", Ic = "⎶", Bc = "≌", Fc = "Б", $c = "б", Pc = "„", zc = "∵", Hc = "∵", Uc = "∵", jc = "⦰", Gc = "϶", Vc = "ℬ", Zc = "ℬ", Kc = "Β", Wc = "β", Yc = "ℶ", Jc = "≬", Xc = "𝔅", Qc = "𝔟", ei = "⋂", ni = "◯", ti = "⋃", ri = "⨀", oi = "⨁", si = "⨂", ci = "⨆", ii = "★", ai = "▽", li = "△", ui = "⨄", fi = "⋁", pi = "⋀", hi = "⤍", di = "⧫", gi = "▪", bi = "▴", _i = "▾", mi = "◂", vi = "▸", xi = "␣", ki = "▒", yi = "░", Ei = "▓", wi = "█", Ai = "=⃥", Ci = "≡⃥", Si = "⫭", Di = "⌐", Ri = "𝔹", Ti = "𝕓", Mi = "⊥", Ni = "⊥", qi = "⋈", Li = "⧉", Oi = "┐", Ii = "╕", Bi = "╖", Fi = "╗", $i = "┌", Pi = "╒", zi = "╓", Hi = "╔", Ui = "─", ji = "═", Gi = "┬", Vi = "╤", Zi = "╥", Ki = "╦", Wi = "┴", Yi = "╧", Ji = "╨", Xi = "╩", Qi = "⊟", ea = "⊞", na = "⊠", ta = "┘", ra = "╛", oa = "╜", sa = "╝", ca = "└", ia = "╘", aa = "╙", la = "╚", ua = "│", fa = "║", pa = "┼", ha = "╪", da = "╫", ga = "╬", ba = "┤", _a = "╡", ma = "╢", va = "╣", xa = "├", ka = "╞", ya = "╟", Ea = "╠", wa = "‵", Aa = "˘", Ca = "˘", Sa = "¦", Da = "𝒷", Ra = "ℬ", Ta = "⁏", Ma = "∽", Na = "⋍", qa = "⧅", La = "\\", Oa = "⟈", Ia = "•", Ba = "•", Fa = "≎", $a = "⪮", Pa = "≏", za = "≎", Ha = "≏", Ua = "Ć", ja = "ć", Ga = "⩄", Va = "⩉", Za = "⩋", Ka = "∩", Wa = "⋒", Ya = "⩇", Ja = "⩀", Xa = "ⅅ", Qa = "∩︀", el = "⁁", nl = "ˇ", tl = "ℭ", rl = "⩍", ol = "Č", sl = "č", cl = "Ç", il = "ç", al = "Ĉ", ll = "ĉ", ul = "∰", fl = "⩌", pl = "⩐", hl = "Ċ", dl = "ċ", gl = "¸", bl = "¸", _l = "⦲", ml = "¢", vl = "·", xl = "·", kl = "𝔠", yl = "ℭ", El = "Ч", wl = "ч", Al = "✓", Cl = "✓", Sl = "Χ", Dl = "χ", Rl = "ˆ", Tl = "≗", Ml = "↺", Nl = "↻", ql = "⊛", Ll = "⊚", Ol = "⊝", Il = "⊙", Bl = "®", Fl = "Ⓢ", $l = "⊖", Pl = "⊕", zl = "⊗", Hl = "○", Ul = "⧃", jl = "≗", Gl = "⨐", Vl = "⫯", Zl = "⧂", Kl = "∲", Wl = "”", Yl = "’", Jl = "♣", Xl = "♣", Ql = ":", eu = "∷", nu = "⩴", tu = "≔", ru = "≔", ou = ",", su = "@", cu = "∁", iu = "∘", au = "∁", lu = "ℂ", uu = "≅", fu = "⩭", pu = "≡", hu = "∮", du = "∯", gu = "∮", bu = "𝕔", _u = "ℂ", mu = "∐", vu = "∐", xu = "©", ku = "©", yu = "℗", Eu = "∳", wu = "↵", Au = "✗", Cu = "⨯", Su = "𝒞", Du = "𝒸", Ru = "⫏", Tu = "⫑", Mu = "⫐", Nu = "⫒", qu = "⋯", Lu = "⤸", Ou = "⤵", Iu = "⋞", Bu = "⋟", Fu = "↶", $u = "⤽", Pu = "⩈", zu = "⩆", Hu = "≍", Uu = "∪", ju = "⋓", Gu = "⩊", Vu = "⊍", Zu = "⩅", Ku = "∪︀", Wu = "↷", Yu = "⤼", Ju = "⋞", Xu = "⋟", Qu = "⋎", ef = "⋏", nf = "¤", tf = "↶", rf = "↷", of = "⋎", sf = "⋏", cf = "∲", af = "∱", lf = "⌭", uf = "†", ff = "‡", pf = "ℸ", hf = "↓", df = "↡", gf = "⇓", bf = "‐", _f = "⫤", mf = "⊣", vf = "⤏", xf = "˝", kf = "Ď", yf = "ď", Ef = "Д", wf = "д", Af = "‡", Cf = "⇊", Sf = "ⅅ", Df = "ⅆ", Rf = "⤑", Tf = "⩷", Mf = "°", Nf = "∇", qf = "Δ", Lf = "δ", Of = "⦱", If = "⥿", Bf = "𝔇", Ff = "𝔡", $f = "⥥", Pf = "⇃", zf = "⇂", Hf = "´", Uf = "˙", jf = "˝", Gf = "`", Vf = "˜", Zf = "⋄", Kf = "⋄", Wf = "⋄", Yf = "♦", Jf = "♦", Xf = "¨", Qf = "ⅆ", ep = "ϝ", np = "⋲", tp = "÷", rp = "÷", op = "⋇", sp = "⋇", cp = "Ђ", ip = "ђ", ap = "⌞", lp = "⌍", up = "$", fp = "𝔻", pp = "𝕕", hp = "¨", dp = "˙", gp = "⃜", bp = "≐", _p = "≑", mp = "≐", vp = "∸", xp = "∔", kp = "⊡", yp = "⌆", Ep = "∯", wp = "¨", Ap = "⇓", Cp = "⇐", Sp = "⇔", Dp = "⫤", Rp = "⟸", Tp = "⟺", Mp = "⟹", Np = "⇒", qp = "⊨", Lp = "⇑", Op = "⇕", Ip = "∥", Bp = "⤓", Fp = "↓", $p = "↓", Pp = "⇓", zp = "⇵", Hp = "̑", Up = "⇊", jp = "⇃", Gp = "⇂", Vp = "⥐", Zp = "⥞", Kp = "⥖", Wp = "↽", Yp = "⥟", Jp = "⥗", Xp = "⇁", Qp = "↧", eh = "⊤", nh = "⤐", th = "⌟", rh = "⌌", oh = "𝒟", sh = "𝒹", ch = "Ѕ", ih = "ѕ", ah = "⧶", lh = "Đ", uh = "đ", fh = "⋱", ph = "▿", hh = "▾", dh = "⇵", gh = "⥯", bh = "⦦", _h = "Џ", mh = "џ", vh = "⟿", xh = "É", kh = "é", yh = "⩮", Eh = "Ě", wh = "ě", Ah = "Ê", Ch = "ê", Sh = "≖", Dh = "≕", Rh = "Э", Th = "э", Mh = "⩷", Nh = "Ė", qh = "ė", Lh = "≑", Oh = "ⅇ", Ih = "≒", Bh = "𝔈", Fh = "𝔢", $h = "⪚", Ph = "È", zh = "è", Hh = "⪖", Uh = "⪘", jh = "⪙", Gh = "∈", Vh = "⏧", Zh = "ℓ", Kh = "⪕", Wh = "⪗", Yh = "Ē", Jh = "ē", Xh = "∅", Qh = "∅", ed = "◻", nd = "∅", td = "▫", rd = " ", od = " ", sd = " ", cd = "Ŋ", id = "ŋ", ad = " ", ld = "Ę", ud = "ę", fd = "𝔼", pd = "𝕖", hd = "⋕", dd = "⧣", gd = "⩱", bd = "ε", _d = "Ε", md = "ε", vd = "ϵ", xd = "≖", kd = "≕", yd = "≂", Ed = "⪖", wd = "⪕", Ad = "⩵", Cd = "=", Sd = "≂", Dd = "≟", Rd = "⇌", Td = "≡", Md = "⩸", Nd = "⧥", qd = "⥱", Ld = "≓", Od = "ℯ", Id = "ℰ", Bd = "≐", Fd = "⩳", $d = "≂", Pd = "Η", zd = "η", Hd = "Ð", Ud = "ð", jd = "Ë", Gd = "ë", Vd = "€", Zd = "!", Kd = "∃", Wd = "∃", Yd = "ℰ", Jd = "ⅇ", Xd = "ⅇ", Qd = "≒", eg = "Ф", ng = "ф", tg = "♀", rg = "ﬃ", og = "ﬀ", sg = "ﬄ", cg = "𝔉", ig = "𝔣", ag = "ﬁ", lg = "◼", ug = "▪", fg = "fj", pg = "♭", hg = "ﬂ", dg = "▱", gg = "ƒ", bg = "𝔽", _g = "𝕗", mg = "∀", vg = "∀", xg = "⋔", kg = "⫙", yg = "ℱ", Eg = "⨍", wg = "½", Ag = "⅓", Cg = "¼", Sg = "⅕", Dg = "⅙", Rg = "⅛", Tg = "⅔", Mg = "⅖", Ng = "¾", qg = "⅗", Lg = "⅜", Og = "⅘", Ig = "⅚", Bg = "⅝", Fg = "⅞", $g = "⁄", Pg = "⌢", zg = "𝒻", Hg = "ℱ", Ug = "ǵ", jg = "Γ", Gg = "γ", Vg = "Ϝ", Zg = "ϝ", Kg = "⪆", Wg = "Ğ", Yg = "ğ", Jg = "Ģ", Xg = "Ĝ", Qg = "ĝ", e0 = "Г", n0 = "г", t0 = "Ġ", r0 = "ġ", o0 = "≥", s0 = "≧", c0 = "⪌", i0 = "⋛", a0 = "≥", l0 = "≧", u0 = "⩾", f0 = "⪩", p0 = "⩾", h0 = "⪀", d0 = "⪂", g0 = "⪄", b0 = "⋛︀", _0 = "⪔", m0 = "𝔊", v0 = "𝔤", x0 = "≫", k0 = "⋙", y0 = "⋙", E0 = "ℷ", w0 = "Ѓ", A0 = "ѓ", C0 = "⪥", S0 = "≷", D0 = "⪒", R0 = "⪤", T0 = "⪊", M0 = "⪊", N0 = "⪈", q0 = "≩", L0 = "⪈", O0 = "≩", I0 = "⋧", B0 = "𝔾", F0 = "𝕘", $0 = "`", P0 = "≥", z0 = "⋛", H0 = "≧", U0 = "⪢", j0 = "≷", G0 = "⩾", V0 = "≳", Z0 = "𝒢", K0 = "ℊ", W0 = "≳", Y0 = "⪎", J0 = "⪐", X0 = "⪧", Q0 = "⩺", eb = ">", nb = ">", tb = "≫", rb = "⋗", ob = "⦕", sb = "⩼", cb = "⪆", ib = "⥸", ab = "⋗", lb = "⋛", ub = "⪌", fb = "≷", pb = "≳", hb = "≩︀", db = "≩︀", gb = "ˇ", bb = " ", _b = "½", mb = "ℋ", vb = "Ъ", xb = "ъ", kb = "⥈", yb = "↔", Eb = "⇔", wb = "↭", Ab = "^", Cb = "ℏ", Sb = "Ĥ", Db = "ĥ", Rb = "♥", Tb = "♥", Mb = "…", Nb = "⊹", qb = "𝔥", Lb = "ℌ", Ob = "ℋ", Ib = "⤥", Bb = "⤦", Fb = "⇿", $b = "∻", Pb = "↩", zb = "↪", Hb = "𝕙", Ub = "ℍ", jb = "―", Gb = "─", Vb = "𝒽", Zb = "ℋ", Kb = "ℏ", Wb = "Ħ", Yb = "ħ", Jb = "≎", Xb = "≏", Qb = "⁃", e_ = "‐", n_ = "Í", t_ = "í", r_ = "⁣", o_ = "Î", s_ = "î", c_ = "И", i_ = "и", a_ = "İ", l_ = "Е", u_ = "е", f_ = "¡", p_ = "⇔", h_ = "𝔦", d_ = "ℑ", g_ = "Ì", b_ = "ì", __ = "ⅈ", m_ = "⨌", v_ = "∭", x_ = "⧜", k_ = "℩", y_ = "Ĳ", E_ = "ĳ", w_ = "Ī", A_ = "ī", C_ = "ℑ", S_ = "ⅈ", D_ = "ℐ", R_ = "ℑ", T_ = "ı", M_ = "ℑ", N_ = "⊷", q_ = "Ƶ", L_ = "⇒", O_ = "℅", I_ = "∞", B_ = "⧝", F_ = "ı", $_ = "⊺", P_ = "∫", z_ = "∬", H_ = "ℤ", U_ = "∫", j_ = "⊺", G_ = "⋂", V_ = "⨗", Z_ = "⨼", K_ = "⁣", W_ = "⁢", Y_ = "Ё", J_ = "ё", X_ = "Į", Q_ = "į", em = "𝕀", nm = "𝕚", tm = "Ι", rm = "ι", om = "⨼", sm = "¿", cm = "𝒾", im = "ℐ", am = "∈", lm = "⋵", um = "⋹", fm = "⋴", pm = "⋳", hm = "∈", dm = "⁢", gm = "Ĩ", bm = "ĩ", _m = "І", mm = "і", vm = "Ï", xm = "ï", km = "Ĵ", ym = "ĵ", Em = "Й", wm = "й", Am = "𝔍", Cm = "𝔧", Sm = "ȷ", Dm = "𝕁", Rm = "𝕛", Tm = "𝒥", Mm = "𝒿", Nm = "Ј", qm = "ј", Lm = "Є", Om = "є", Im = "Κ", Bm = "κ", Fm = "ϰ", $m = "Ķ", Pm = "ķ", zm = "К", Hm = "к", Um = "𝔎", jm = "𝔨", Gm = "ĸ", Vm = "Х", Zm = "х", Km = "Ќ", Wm = "ќ", Ym = "𝕂", Jm = "𝕜", Xm = "𝒦", Qm = "𝓀", e1 = "⇚", n1 = "Ĺ", t1 = "ĺ", r1 = "⦴", o1 = "ℒ", s1 = "Λ", c1 = "λ", i1 = "⟨", a1 = "⟪", l1 = "⦑", u1 = "⟨", f1 = "⪅", p1 = "ℒ", h1 = "«", d1 = "⇤", g1 = "⤟", b1 = "←", _1 = "↞", m1 = "⇐", v1 = "⤝", x1 = "↩", k1 = "↫", y1 = "⤹", E1 = "⥳", w1 = "↢", A1 = "⤙", C1 = "⤛", S1 = "⪫", D1 = "⪭", R1 = "⪭︀", T1 = "⤌", M1 = "⤎", N1 = "❲", q1 = "{", L1 = "[", O1 = "⦋", I1 = "⦏", B1 = "⦍", F1 = "Ľ", $1 = "ľ", P1 = "Ļ", z1 = "ļ", H1 = "⌈", U1 = "{", j1 = "Л", G1 = "л", V1 = "⤶", Z1 = "“", K1 = "„", W1 = "⥧", Y1 = "⥋", J1 = "↲", X1 = "≤", Q1 = "≦", ev = "⟨", nv = "⇤", tv = "←", rv = "←", ov = "⇐", sv = "⇆", cv = "↢", iv = "⌈", av = "⟦", lv = "⥡", uv = "⥙", fv = "⇃", pv = "⌊", hv = "↽", dv = "↼", gv = "⇇", bv = "↔", _v = "↔", mv = "⇔", vv = "⇆", xv = "⇋", kv = "↭", yv = "⥎", Ev = "↤", wv = "⊣", Av = "⥚", Cv = "⋋", Sv = "⧏", Dv = "⊲", Rv = "⊴", Tv = "⥑", Mv = "⥠", Nv = "⥘", qv = "↿", Lv = "⥒", Ov = "↼", Iv = "⪋", Bv = "⋚", Fv = "≤", $v = "≦", Pv = "⩽", zv = "⪨", Hv = "⩽", Uv = "⩿", jv = "⪁", Gv = "⪃", Vv = "⋚︀", Zv = "⪓", Kv = "⪅", Wv = "⋖", Yv = "⋚", Jv = "⪋", Xv = "⋚", Qv = "≦", ex = "≶", nx = "≶", tx = "⪡", rx = "≲", ox = "⩽", sx = "≲", cx = "⥼", ix = "⌊", ax = "𝔏", lx = "𝔩", ux = "≶", fx = "⪑", px = "⥢", hx = "↽", dx = "↼", gx = "⥪", bx = "▄", _x = "Љ", mx = "љ", vx = "⇇", xx = "≪", kx = "⋘", yx = "⌞", Ex = "⇚", wx = "⥫", Ax = "◺", Cx = "Ŀ", Sx = "ŀ", Dx = "⎰", Rx = "⎰", Tx = "⪉", Mx = "⪉", Nx = "⪇", qx = "≨", Lx = "⪇", Ox = "≨", Ix = "⋦", Bx = "⟬", Fx = "⇽", $x = "⟦", Px = "⟵", zx = "⟵", Hx = "⟸", Ux = "⟷", jx = "⟷", Gx = "⟺", Vx = "⟼", Zx = "⟶", Kx = "⟶", Wx = "⟹", Yx = "↫", Jx = "↬", Xx = "⦅", Qx = "𝕃", ek = "𝕝", nk = "⨭", tk = "⨴", rk = "∗", ok = "_", sk = "↙", ck = "↘", ik = "◊", ak = "◊", lk = "⧫", uk = "(", fk = "⦓", pk = "⇆", hk = "⌟", dk = "⇋", gk = "⥭", bk = "‎", _k = "⊿", mk = "‹", vk = "𝓁", xk = "ℒ", kk = "↰", yk = "↰", Ek = "≲", wk = "⪍", Ak = "⪏", Ck = "[", Sk = "‘", Dk = "‚", Rk = "Ł", Tk = "ł", Mk = "⪦", Nk = "⩹", qk = "<", Lk = "<", Ok = "≪", Ik = "⋖", Bk = "⋋", Fk = "⋉", $k = "⥶", Pk = "⩻", zk = "◃", Hk = "⊴", Uk = "◂", jk = "⦖", Gk = "⥊", Vk = "⥦", Zk = "≨︀", Kk = "≨︀", Wk = "¯", Yk = "♂", Jk = "✠", Xk = "✠", Qk = "↦", ey = "↦", ny = "↧", ty = "↤", ry = "↥", oy = "▮", sy = "⨩", cy = "М", iy = "м", ay = "—", ly = "∺", uy = "∡", fy = " ", py = "ℳ", hy = "𝔐", dy = "𝔪", gy = "℧", by = "µ", _y = "*", my = "⫰", vy = "∣", xy = "·", ky = "⊟", yy = "−", Ey = "∸", wy = "⨪", Ay = "∓", Cy = "⫛", Sy = "…", Dy = "∓", Ry = "⊧", Ty = "𝕄", My = "𝕞", Ny = "∓", qy = "𝓂", Ly = "ℳ", Oy = "∾", Iy = "Μ", By = "μ", Fy = "⊸", $y = "⊸", Py = "∇", zy = "Ń", Hy = "ń", Uy = "∠⃒", jy = "≉", Gy = "⩰̸", Vy = "≋̸", Zy = "ŉ", Ky = "≉", Wy = "♮", Yy = "ℕ", Jy = "♮", Xy = " ", Qy = "≎̸", eE = "≏̸", nE = "⩃", tE = "Ň", rE = "ň", oE = "Ņ", sE = "ņ", cE = "≇", iE = "⩭̸", aE = "⩂", lE = "Н", uE = "н", fE = "–", pE = "⤤", hE = "↗", dE = "⇗", gE = "↗", bE = "≠", _E = "≐̸", mE = "​", vE = "​", xE = "​", kE = "​", yE = "≢", EE = "⤨", wE = "≂̸", AE = "≫", CE = "≪", SE = `
`, DE = "∄", RE = "∄", TE = "𝔑", ME = "𝔫", NE = "≧̸", qE = "≱", LE = "≱", OE = "≧̸", IE = "⩾̸", BE = "⩾̸", FE = "⋙̸", $E = "≵", PE = "≫⃒", zE = "≯", HE = "≯", UE = "≫̸", jE = "↮", GE = "⇎", VE = "⫲", ZE = "∋", KE = "⋼", WE = "⋺", YE = "∋", JE = "Њ", XE = "њ", QE = "↚", ew = "⇍", nw = "‥", tw = "≦̸", rw = "≰", ow = "↚", sw = "⇍", cw = "↮", iw = "⇎", aw = "≰", lw = "≦̸", uw = "⩽̸", fw = "⩽̸", pw = "≮", hw = "⋘̸", dw = "≴", gw = "≪⃒", bw = "≮", _w = "⋪", mw = "⋬", vw = "≪̸", xw = "∤", kw = "⁠", yw = " ", Ew = "𝕟", ww = "ℕ", Aw = "⫬", Cw = "¬", Sw = "≢", Dw = "≭", Rw = "∦", Tw = "∉", Mw = "≠", Nw = "≂̸", qw = "∄", Lw = "≯", Ow = "≱", Iw = "≧̸", Bw = "≫̸", Fw = "≹", $w = "⩾̸", Pw = "≵", zw = "≎̸", Hw = "≏̸", Uw = "∉", jw = "⋵̸", Gw = "⋹̸", Vw = "∉", Zw = "⋷", Kw = "⋶", Ww = "⧏̸", Yw = "⋪", Jw = "⋬", Xw = "≮", Qw = "≰", eA = "≸", nA = "≪̸", tA = "⩽̸", rA = "≴", oA = "⪢̸", sA = "⪡̸", cA = "∌", iA = "∌", aA = "⋾", lA = "⋽", uA = "⊀", fA = "⪯̸", pA = "⋠", hA = "∌", dA = "⧐̸", gA = "⋫", bA = "⋭", _A = "⊏̸", mA = "⋢", vA = "⊐̸", xA = "⋣", kA = "⊂⃒", yA = "⊈", EA = "⊁", wA = "⪰̸", AA = "⋡", CA = "≿̸", SA = "⊃⃒", DA = "⊉", RA = "≁", TA = "≄", MA = "≇", NA = "≉", qA = "∤", LA = "∦", OA = "∦", IA = "⫽⃥", BA = "∂̸", FA = "⨔", $A = "⊀", PA = "⋠", zA = "⊀", HA = "⪯̸", UA = "⪯̸", jA = "⤳̸", GA = "↛", VA = "⇏", ZA = "↝̸", KA = "↛", WA = "⇏", YA = "⋫", JA = "⋭", XA = "⊁", QA = "⋡", eC = "⪰̸", nC = "𝒩", tC = "𝓃", rC = "∤", oC = "∦", sC = "≁", cC = "≄", iC = "≄", aC = "∤", lC = "∦", uC = "⋢", fC = "⋣", pC = "⊄", hC = "⫅̸", dC = "⊈", gC = "⊂⃒", bC = "⊈", _C = "⫅̸", mC = "⊁", vC = "⪰̸", xC = "⊅", kC = "⫆̸", yC = "⊉", EC = "⊃⃒", wC = "⊉", AC = "⫆̸", CC = "≹", SC = "Ñ", DC = "ñ", RC = "≸", TC = "⋪", MC = "⋬", NC = "⋫", qC = "⋭", LC = "Ν", OC = "ν", IC = "#", BC = "№", FC = " ", $C = "≍⃒", PC = "⊬", zC = "⊭", HC = "⊮", UC = "⊯", jC = "≥⃒", GC = ">⃒", VC = "⤄", ZC = "⧞", KC = "⤂", WC = "≤⃒", YC = "<⃒", JC = "⊴⃒", XC = "⤃", QC = "⊵⃒", eS = "∼⃒", nS = "⤣", tS = "↖", rS = "⇖", oS = "↖", sS = "⤧", cS = "Ó", iS = "ó", aS = "⊛", lS = "Ô", uS = "ô", fS = "⊚", pS = "О", hS = "о", dS = "⊝", gS = "Ő", bS = "ő", _S = "⨸", mS = "⊙", vS = "⦼", xS = "Œ", kS = "œ", yS = "⦿", ES = "𝔒", wS = "𝔬", AS = "˛", CS = "Ò", SS = "ò", DS = "⧁", RS = "⦵", TS = "Ω", MS = "∮", NS = "↺", qS = "⦾", LS = "⦻", OS = "‾", IS = "⧀", BS = "Ō", FS = "ō", $S = "Ω", PS = "ω", zS = "Ο", HS = "ο", US = "⦶", jS = "⊖", GS = "𝕆", VS = "𝕠", ZS = "⦷", KS = "“", WS = "‘", YS = "⦹", JS = "⊕", XS = "↻", QS = "⩔", e2 = "∨", n2 = "⩝", t2 = "ℴ", r2 = "ℴ", o2 = "ª", s2 = "º", c2 = "⊶", i2 = "⩖", a2 = "⩗", l2 = "⩛", u2 = "Ⓢ", f2 = "𝒪", p2 = "ℴ", h2 = "Ø", d2 = "ø", g2 = "⊘", b2 = "Õ", _2 = "õ", m2 = "⨶", v2 = "⨷", x2 = "⊗", k2 = "Ö", y2 = "ö", E2 = "⌽", w2 = "‾", A2 = "⏞", C2 = "⎴", S2 = "⏜", D2 = "¶", R2 = "∥", T2 = "∥", M2 = "⫳", N2 = "⫽", q2 = "∂", L2 = "∂", O2 = "П", I2 = "п", B2 = "%", F2 = ".", $2 = "‰", P2 = "⊥", z2 = "‱", H2 = "𝔓", U2 = "𝔭", j2 = "Φ", G2 = "φ", V2 = "ϕ", Z2 = "ℳ", K2 = "☎", W2 = "Π", Y2 = "π", J2 = "⋔", X2 = "ϖ", Q2 = "ℏ", eD = "ℎ", nD = "ℏ", tD = "⨣", rD = "⊞", oD = "⨢", sD = "+", cD = "∔", iD = "⨥", aD = "⩲", lD = "±", uD = "±", fD = "⨦", pD = "⨧", hD = "±", dD = "ℌ", gD = "⨕", bD = "𝕡", _D = "ℙ", mD = "£", vD = "⪷", xD = "⪻", kD = "≺", yD = "≼", ED = "⪷", wD = "≺", AD = "≼", CD = "≺", SD = "⪯", DD = "≼", RD = "≾", TD = "⪯", MD = "⪹", ND = "⪵", qD = "⋨", LD = "⪯", OD = "⪳", ID = "≾", BD = "′", FD = "″", $D = "ℙ", PD = "⪹", zD = "⪵", HD = "⋨", UD = "∏", jD = "∏", GD = "⌮", VD = "⌒", ZD = "⌓", KD = "∝", WD = "∝", YD = "∷", JD = "∝", XD = "≾", QD = "⊰", eR = "𝒫", nR = "𝓅", tR = "Ψ", rR = "ψ", oR = " ", sR = "𝔔", cR = "𝔮", iR = "⨌", aR = "𝕢", lR = "ℚ", uR = "⁗", fR = "𝒬", pR = "𝓆", hR = "ℍ", dR = "⨖", gR = "?", bR = "≟", _R = '"', mR = '"', vR = "⇛", xR = "∽̱", kR = "Ŕ", yR = "ŕ", ER = "√", wR = "⦳", AR = "⟩", CR = "⟫", SR = "⦒", DR = "⦥", RR = "⟩", TR = "»", MR = "⥵", NR = "⇥", qR = "⤠", LR = "⤳", OR = "→", IR = "↠", BR = "⇒", FR = "⤞", $R = "↪", PR = "↬", zR = "⥅", HR = "⥴", UR = "⤖", jR = "↣", GR = "↝", VR = "⤚", ZR = "⤜", KR = "∶", WR = "ℚ", YR = "⤍", JR = "⤏", XR = "⤐", QR = "❳", eT = "}", nT = "]", tT = "⦌", rT = "⦎", oT = "⦐", sT = "Ř", cT = "ř", iT = "Ŗ", aT = "ŗ", lT = "⌉", uT = "}", fT = "Р", pT = "р", hT = "⤷", dT = "⥩", gT = "”", bT = "”", _T = "↳", mT = "ℜ", vT = "ℛ", xT = "ℜ", kT = "ℝ", yT = "ℜ", ET = "▭", wT = "®", AT = "®", CT = "∋", ST = "⇋", DT = "⥯", RT = "⥽", TT = "⌋", MT = "𝔯", NT = "ℜ", qT = "⥤", LT = "⇁", OT = "⇀", IT = "⥬", BT = "Ρ", FT = "ρ", $T = "ϱ", PT = "⟩", zT = "⇥", HT = "→", UT = "→", jT = "⇒", GT = "⇄", VT = "↣", ZT = "⌉", KT = "⟧", WT = "⥝", YT = "⥕", JT = "⇂", XT = "⌋", QT = "⇁", e3 = "⇀", n3 = "⇄", t3 = "⇌", r3 = "⇉", o3 = "↝", s3 = "↦", c3 = "⊢", i3 = "⥛", a3 = "⋌", l3 = "⧐", u3 = "⊳", f3 = "⊵", p3 = "⥏", h3 = "⥜", d3 = "⥔", g3 = "↾", b3 = "⥓", _3 = "⇀", m3 = "˚", v3 = "≓", x3 = "⇄", k3 = "⇌", y3 = "‏", E3 = "⎱", w3 = "⎱", A3 = "⫮", C3 = "⟭", S3 = "⇾", D3 = "⟧", R3 = "⦆", T3 = "𝕣", M3 = "ℝ", N3 = "⨮", q3 = "⨵", L3 = "⥰", O3 = ")", I3 = "⦔", B3 = "⨒", F3 = "⇉", $3 = "⇛", P3 = "›", z3 = "𝓇", H3 = "ℛ", U3 = "↱", j3 = "↱", G3 = "]", V3 = "’", Z3 = "’", K3 = "⋌", W3 = "⋊", Y3 = "▹", J3 = "⊵", X3 = "▸", Q3 = "⧎", eM = "⧴", nM = "⥨", tM = "℞", rM = "Ś", oM = "ś", sM = "‚", cM = "⪸", iM = "Š", aM = "š", lM = "⪼", uM = "≻", fM = "≽", pM = "⪰", hM = "⪴", dM = "Ş", gM = "ş", bM = "Ŝ", _M = "ŝ", mM = "⪺", vM = "⪶", xM = "⋩", kM = "⨓", yM = "≿", EM = "С", wM = "с", AM = "⊡", CM = "⋅", SM = "⩦", DM = "⤥", RM = "↘", TM = "⇘", MM = "↘", NM = "§", qM = ";", LM = "⤩", OM = "∖", IM = "∖", BM = "✶", FM = "𝔖", $M = "𝔰", PM = "⌢", zM = "♯", HM = "Щ", UM = "щ", jM = "Ш", GM = "ш", VM = "↓", ZM = "←", KM = "∣", WM = "∥", YM = "→", JM = "↑", XM = "­", QM = "Σ", eN = "σ", nN = "ς", tN = "ς", rN = "∼", oN = "⩪", sN = "≃", cN = "≃", iN = "⪞", aN = "⪠", lN = "⪝", uN = "⪟", fN = "≆", pN = "⨤", hN = "⥲", dN = "←", gN = "∘", bN = "∖", _N = "⨳", mN = "⧤", vN = "∣", xN = "⌣", kN = "⪪", yN = "⪬", EN = "⪬︀", wN = "Ь", AN = "ь", CN = "⌿", SN = "⧄", DN = "/", RN = "𝕊", TN = "𝕤", MN = "♠", NN = "♠", qN = "∥", LN = "⊓", ON = "⊓︀", IN = "⊔", BN = "⊔︀", FN = "√", $N = "⊏", PN = "⊑", zN = "⊏", HN = "⊑", UN = "⊐", jN = "⊒", GN = "⊐", VN = "⊒", ZN = "□", KN = "□", WN = "⊓", YN = "⊏", JN = "⊑", XN = "⊐", QN = "⊒", eq = "⊔", nq = "▪", tq = "□", rq = "▪", oq = "→", sq = "𝒮", cq = "𝓈", iq = "∖", aq = "⌣", lq = "⋆", uq = "⋆", fq = "☆", pq = "★", hq = "ϵ", dq = "ϕ", gq = "¯", bq = "⊂", _q = "⋐", mq = "⪽", vq = "⫅", xq = "⊆", kq = "⫃", yq = "⫁", Eq = "⫋", wq = "⊊", Aq = "⪿", Cq = "⥹", Sq = "⊂", Dq = "⋐", Rq = "⊆", Tq = "⫅", Mq = "⊆", Nq = "⊊", qq = "⫋", Lq = "⫇", Oq = "⫕", Iq = "⫓", Bq = "⪸", Fq = "≻", $q = "≽", Pq = "≻", zq = "⪰", Hq = "≽", Uq = "≿", jq = "⪰", Gq = "⪺", Vq = "⪶", Zq = "⋩", Kq = "≿", Wq = "∋", Yq = "∑", Jq = "∑", Xq = "♪", Qq = "¹", eL = "²", nL = "³", tL = "⊃", rL = "⋑", oL = "⪾", sL = "⫘", cL = "⫆", iL = "⊇", aL = "⫄", lL = "⊃", uL = "⊇", fL = "⟉", pL = "⫗", hL = "⥻", dL = "⫂", gL = "⫌", bL = "⊋", _L = "⫀", mL = "⊃", vL = "⋑", xL = "⊇", kL = "⫆", yL = "⊋", EL = "⫌", wL = "⫈", AL = "⫔", CL = "⫖", SL = "⤦", DL = "↙", RL = "⇙", TL = "↙", ML = "⤪", NL = "ß", qL = "	", LL = "⌖", OL = "Τ", IL = "τ", BL = "⎴", FL = "Ť", $L = "ť", PL = "Ţ", zL = "ţ", HL = "Т", UL = "т", jL = "⃛", GL = "⌕", VL = "𝔗", ZL = "𝔱", KL = "∴", WL = "∴", YL = "∴", JL = "Θ", XL = "θ", QL = "ϑ", eO = "ϑ", nO = "≈", tO = "∼", rO = "  ", oO = " ", sO = " ", cO = "≈", iO = "∼", aO = "Þ", lO = "þ", uO = "˜", fO = "∼", pO = "≃", hO = "≅", dO = "≈", gO = "⨱", bO = "⊠", _O = "×", mO = "⨰", vO = "∭", xO = "⤨", kO = "⌶", yO = "⫱", EO = "⊤", wO = "𝕋", AO = "𝕥", CO = "⫚", SO = "⤩", DO = "‴", RO = "™", TO = "™", MO = "▵", NO = "▿", qO = "◃", LO = "⊴", OO = "≜", IO = "▹", BO = "⊵", FO = "◬", $O = "≜", PO = "⨺", zO = "⃛", HO = "⨹", UO = "⧍", jO = "⨻", GO = "⏢", VO = "𝒯", ZO = "𝓉", KO = "Ц", WO = "ц", YO = "Ћ", JO = "ћ", XO = "Ŧ", QO = "ŧ", eI = "≬", nI = "↞", tI = "↠", rI = "Ú", oI = "ú", sI = "↑", cI = "↟", iI = "⇑", aI = "⥉", lI = "Ў", uI = "ў", fI = "Ŭ", pI = "ŭ", hI = "Û", dI = "û", gI = "У", bI = "у", _I = "⇅", mI = "Ű", vI = "ű", xI = "⥮", kI = "⥾", yI = "𝔘", EI = "𝔲", wI = "Ù", AI = "ù", CI = "⥣", SI = "↿", DI = "↾", RI = "▀", TI = "⌜", MI = "⌜", NI = "⌏", qI = "◸", LI = "Ū", OI = "ū", II = "¨", BI = "_", FI = "⏟", $I = "⎵", PI = "⏝", zI = "⋃", HI = "⊎", UI = "Ų", jI = "ų", GI = "𝕌", VI = "𝕦", ZI = "⤒", KI = "↑", WI = "↑", YI = "⇑", JI = "⇅", XI = "↕", QI = "↕", e5 = "⇕", n5 = "⥮", t5 = "↿", r5 = "↾", o5 = "⊎", s5 = "↖", c5 = "↗", i5 = "υ", a5 = "ϒ", l5 = "ϒ", u5 = "Υ", f5 = "υ", p5 = "↥", h5 = "⊥", d5 = "⇈", g5 = "⌝", b5 = "⌝", _5 = "⌎", m5 = "Ů", v5 = "ů", x5 = "◹", k5 = "𝒰", y5 = "𝓊", E5 = "⋰", w5 = "Ũ", A5 = "ũ", C5 = "▵", S5 = "▴", D5 = "⇈", R5 = "Ü", T5 = "ü", M5 = "⦧", N5 = "⦜", q5 = "ϵ", L5 = "ϰ", O5 = "∅", I5 = "ϕ", B5 = "ϖ", F5 = "∝", $5 = "↕", P5 = "⇕", z5 = "ϱ", H5 = "ς", U5 = "⊊︀", j5 = "⫋︀", G5 = "⊋︀", V5 = "⫌︀", Z5 = "ϑ", K5 = "⊲", W5 = "⊳", Y5 = "⫨", J5 = "⫫", X5 = "⫩", Q5 = "В", eB = "в", nB = "⊢", tB = "⊨", rB = "⊩", oB = "⊫", sB = "⫦", cB = "⊻", iB = "∨", aB = "⋁", lB = "≚", uB = "⋮", fB = "|", pB = "‖", hB = "|", dB = "‖", gB = "∣", bB = "|", _B = "❘", mB = "≀", vB = " ", xB = "𝔙", kB = "𝔳", yB = "⊲", EB = "⊂⃒", wB = "⊃⃒", AB = "𝕍", CB = "𝕧", SB = "∝", DB = "⊳", RB = "𝒱", TB = "𝓋", MB = "⫋︀", NB = "⊊︀", qB = "⫌︀", LB = "⊋︀", OB = "⊪", IB = "⦚", BB = "Ŵ", FB = "ŵ", $B = "⩟", PB = "∧", zB = "⋀", HB = "≙", UB = "℘", jB = "𝔚", GB = "𝔴", VB = "𝕎", ZB = "𝕨", KB = "℘", WB = "≀", YB = "≀", JB = "𝒲", XB = "𝓌", QB = "⋂", e6 = "◯", n6 = "⋃", t6 = "▽", r6 = "𝔛", o6 = "𝔵", s6 = "⟷", c6 = "⟺", i6 = "Ξ", a6 = "ξ", l6 = "⟵", u6 = "⟸", f6 = "⟼", p6 = "⋻", h6 = "⨀", d6 = "𝕏", g6 = "𝕩", b6 = "⨁", _6 = "⨂", m6 = "⟶", v6 = "⟹", x6 = "𝒳", k6 = "𝓍", y6 = "⨆", E6 = "⨄", w6 = "△", A6 = "⋁", C6 = "⋀", S6 = "Ý", D6 = "ý", R6 = "Я", T6 = "я", M6 = "Ŷ", N6 = "ŷ", q6 = "Ы", L6 = "ы", O6 = "¥", I6 = "𝔜", B6 = "𝔶", F6 = "Ї", $6 = "ї", P6 = "𝕐", z6 = "𝕪", H6 = "𝒴", U6 = "𝓎", j6 = "Ю", G6 = "ю", V6 = "ÿ", Z6 = "Ÿ", K6 = "Ź", W6 = "ź", Y6 = "Ž", J6 = "ž", X6 = "З", Q6 = "з", eF = "Ż", nF = "ż", tF = "ℨ", rF = "​", oF = "Ζ", sF = "ζ", cF = "𝔷", iF = "ℨ", aF = "Ж", lF = "ж", uF = "⇝", fF = "𝕫", pF = "ℤ", hF = "𝒵", dF = "𝓏", gF = "‍", bF = "‌", _F = {
  Aacute: Qo,
  aacute: es,
  Abreve: ns,
  abreve: ts,
  ac: rs,
  acd: os,
  acE: ss,
  Acirc: cs,
  acirc: is,
  acute: as,
  Acy: ls,
  acy: us,
  AElig: fs,
  aelig: ps,
  af: hs,
  Afr: ds,
  afr: gs,
  Agrave: bs,
  agrave: _s,
  alefsym: ms,
  aleph: vs,
  Alpha: xs,
  alpha: ks,
  Amacr: ys,
  amacr: Es,
  amalg: ws,
  amp: As,
  AMP: Cs,
  andand: Ss,
  And: Ds,
  and: Rs,
  andd: Ts,
  andslope: Ms,
  andv: Ns,
  ang: qs,
  ange: Ls,
  angle: Os,
  angmsdaa: Is,
  angmsdab: Bs,
  angmsdac: Fs,
  angmsdad: $s,
  angmsdae: Ps,
  angmsdaf: zs,
  angmsdag: Hs,
  angmsdah: Us,
  angmsd: js,
  angrt: Gs,
  angrtvb: Vs,
  angrtvbd: Zs,
  angsph: Ks,
  angst: Ws,
  angzarr: Ys,
  Aogon: Js,
  aogon: Xs,
  Aopf: Qs,
  aopf: ec,
  apacir: nc,
  ap: tc,
  apE: rc,
  ape: oc,
  apid: sc,
  apos: cc,
  ApplyFunction: ic,
  approx: ac,
  approxeq: lc,
  Aring: uc,
  aring: fc,
  Ascr: pc,
  ascr: hc,
  Assign: dc,
  ast: gc,
  asymp: bc,
  asympeq: _c,
  Atilde: mc,
  atilde: vc,
  Auml: xc,
  auml: kc,
  awconint: yc,
  awint: Ec,
  backcong: wc,
  backepsilon: Ac,
  backprime: Cc,
  backsim: Sc,
  backsimeq: Dc,
  Backslash: Rc,
  Barv: Tc,
  barvee: Mc,
  barwed: Nc,
  Barwed: qc,
  barwedge: Lc,
  bbrk: Oc,
  bbrktbrk: Ic,
  bcong: Bc,
  Bcy: Fc,
  bcy: $c,
  bdquo: Pc,
  becaus: zc,
  because: Hc,
  Because: Uc,
  bemptyv: jc,
  bepsi: Gc,
  bernou: Vc,
  Bernoullis: Zc,
  Beta: Kc,
  beta: Wc,
  beth: Yc,
  between: Jc,
  Bfr: Xc,
  bfr: Qc,
  bigcap: ei,
  bigcirc: ni,
  bigcup: ti,
  bigodot: ri,
  bigoplus: oi,
  bigotimes: si,
  bigsqcup: ci,
  bigstar: ii,
  bigtriangledown: ai,
  bigtriangleup: li,
  biguplus: ui,
  bigvee: fi,
  bigwedge: pi,
  bkarow: hi,
  blacklozenge: di,
  blacksquare: gi,
  blacktriangle: bi,
  blacktriangledown: _i,
  blacktriangleleft: mi,
  blacktriangleright: vi,
  blank: xi,
  blk12: ki,
  blk14: yi,
  blk34: Ei,
  block: wi,
  bne: Ai,
  bnequiv: Ci,
  bNot: Si,
  bnot: Di,
  Bopf: Ri,
  bopf: Ti,
  bot: Mi,
  bottom: Ni,
  bowtie: qi,
  boxbox: Li,
  boxdl: Oi,
  boxdL: Ii,
  boxDl: Bi,
  boxDL: Fi,
  boxdr: $i,
  boxdR: Pi,
  boxDr: zi,
  boxDR: Hi,
  boxh: Ui,
  boxH: ji,
  boxhd: Gi,
  boxHd: Vi,
  boxhD: Zi,
  boxHD: Ki,
  boxhu: Wi,
  boxHu: Yi,
  boxhU: Ji,
  boxHU: Xi,
  boxminus: Qi,
  boxplus: ea,
  boxtimes: na,
  boxul: ta,
  boxuL: ra,
  boxUl: oa,
  boxUL: sa,
  boxur: ca,
  boxuR: ia,
  boxUr: aa,
  boxUR: la,
  boxv: ua,
  boxV: fa,
  boxvh: pa,
  boxvH: ha,
  boxVh: da,
  boxVH: ga,
  boxvl: ba,
  boxvL: _a,
  boxVl: ma,
  boxVL: va,
  boxvr: xa,
  boxvR: ka,
  boxVr: ya,
  boxVR: Ea,
  bprime: wa,
  breve: Aa,
  Breve: Ca,
  brvbar: Sa,
  bscr: Da,
  Bscr: Ra,
  bsemi: Ta,
  bsim: Ma,
  bsime: Na,
  bsolb: qa,
  bsol: La,
  bsolhsub: Oa,
  bull: Ia,
  bullet: Ba,
  bump: Fa,
  bumpE: $a,
  bumpe: Pa,
  Bumpeq: za,
  bumpeq: Ha,
  Cacute: Ua,
  cacute: ja,
  capand: Ga,
  capbrcup: Va,
  capcap: Za,
  cap: Ka,
  Cap: Wa,
  capcup: Ya,
  capdot: Ja,
  CapitalDifferentialD: Xa,
  caps: Qa,
  caret: el,
  caron: nl,
  Cayleys: tl,
  ccaps: rl,
  Ccaron: ol,
  ccaron: sl,
  Ccedil: cl,
  ccedil: il,
  Ccirc: al,
  ccirc: ll,
  Cconint: ul,
  ccups: fl,
  ccupssm: pl,
  Cdot: hl,
  cdot: dl,
  cedil: gl,
  Cedilla: bl,
  cemptyv: _l,
  cent: ml,
  centerdot: vl,
  CenterDot: xl,
  cfr: kl,
  Cfr: yl,
  CHcy: El,
  chcy: wl,
  check: Al,
  checkmark: Cl,
  Chi: Sl,
  chi: Dl,
  circ: Rl,
  circeq: Tl,
  circlearrowleft: Ml,
  circlearrowright: Nl,
  circledast: ql,
  circledcirc: Ll,
  circleddash: Ol,
  CircleDot: Il,
  circledR: Bl,
  circledS: Fl,
  CircleMinus: $l,
  CirclePlus: Pl,
  CircleTimes: zl,
  cir: Hl,
  cirE: Ul,
  cire: jl,
  cirfnint: Gl,
  cirmid: Vl,
  cirscir: Zl,
  ClockwiseContourIntegral: Kl,
  CloseCurlyDoubleQuote: Wl,
  CloseCurlyQuote: Yl,
  clubs: Jl,
  clubsuit: Xl,
  colon: Ql,
  Colon: eu,
  Colone: nu,
  colone: tu,
  coloneq: ru,
  comma: ou,
  commat: su,
  comp: cu,
  compfn: iu,
  complement: au,
  complexes: lu,
  cong: uu,
  congdot: fu,
  Congruent: pu,
  conint: hu,
  Conint: du,
  ContourIntegral: gu,
  copf: bu,
  Copf: _u,
  coprod: mu,
  Coproduct: vu,
  copy: xu,
  COPY: ku,
  copysr: yu,
  CounterClockwiseContourIntegral: Eu,
  crarr: wu,
  cross: Au,
  Cross: Cu,
  Cscr: Su,
  cscr: Du,
  csub: Ru,
  csube: Tu,
  csup: Mu,
  csupe: Nu,
  ctdot: qu,
  cudarrl: Lu,
  cudarrr: Ou,
  cuepr: Iu,
  cuesc: Bu,
  cularr: Fu,
  cularrp: $u,
  cupbrcap: Pu,
  cupcap: zu,
  CupCap: Hu,
  cup: Uu,
  Cup: ju,
  cupcup: Gu,
  cupdot: Vu,
  cupor: Zu,
  cups: Ku,
  curarr: Wu,
  curarrm: Yu,
  curlyeqprec: Ju,
  curlyeqsucc: Xu,
  curlyvee: Qu,
  curlywedge: ef,
  curren: nf,
  curvearrowleft: tf,
  curvearrowright: rf,
  cuvee: of,
  cuwed: sf,
  cwconint: cf,
  cwint: af,
  cylcty: lf,
  dagger: uf,
  Dagger: ff,
  daleth: pf,
  darr: hf,
  Darr: df,
  dArr: gf,
  dash: bf,
  Dashv: _f,
  dashv: mf,
  dbkarow: vf,
  dblac: xf,
  Dcaron: kf,
  dcaron: yf,
  Dcy: Ef,
  dcy: wf,
  ddagger: Af,
  ddarr: Cf,
  DD: Sf,
  dd: Df,
  DDotrahd: Rf,
  ddotseq: Tf,
  deg: Mf,
  Del: Nf,
  Delta: qf,
  delta: Lf,
  demptyv: Of,
  dfisht: If,
  Dfr: Bf,
  dfr: Ff,
  dHar: $f,
  dharl: Pf,
  dharr: zf,
  DiacriticalAcute: Hf,
  DiacriticalDot: Uf,
  DiacriticalDoubleAcute: jf,
  DiacriticalGrave: Gf,
  DiacriticalTilde: Vf,
  diam: Zf,
  diamond: Kf,
  Diamond: Wf,
  diamondsuit: Yf,
  diams: Jf,
  die: Xf,
  DifferentialD: Qf,
  digamma: ep,
  disin: np,
  div: tp,
  divide: rp,
  divideontimes: op,
  divonx: sp,
  DJcy: cp,
  djcy: ip,
  dlcorn: ap,
  dlcrop: lp,
  dollar: up,
  Dopf: fp,
  dopf: pp,
  Dot: hp,
  dot: dp,
  DotDot: gp,
  doteq: bp,
  doteqdot: _p,
  DotEqual: mp,
  dotminus: vp,
  dotplus: xp,
  dotsquare: kp,
  doublebarwedge: yp,
  DoubleContourIntegral: Ep,
  DoubleDot: wp,
  DoubleDownArrow: Ap,
  DoubleLeftArrow: Cp,
  DoubleLeftRightArrow: Sp,
  DoubleLeftTee: Dp,
  DoubleLongLeftArrow: Rp,
  DoubleLongLeftRightArrow: Tp,
  DoubleLongRightArrow: Mp,
  DoubleRightArrow: Np,
  DoubleRightTee: qp,
  DoubleUpArrow: Lp,
  DoubleUpDownArrow: Op,
  DoubleVerticalBar: Ip,
  DownArrowBar: Bp,
  downarrow: Fp,
  DownArrow: $p,
  Downarrow: Pp,
  DownArrowUpArrow: zp,
  DownBreve: Hp,
  downdownarrows: Up,
  downharpoonleft: jp,
  downharpoonright: Gp,
  DownLeftRightVector: Vp,
  DownLeftTeeVector: Zp,
  DownLeftVectorBar: Kp,
  DownLeftVector: Wp,
  DownRightTeeVector: Yp,
  DownRightVectorBar: Jp,
  DownRightVector: Xp,
  DownTeeArrow: Qp,
  DownTee: eh,
  drbkarow: nh,
  drcorn: th,
  drcrop: rh,
  Dscr: oh,
  dscr: sh,
  DScy: ch,
  dscy: ih,
  dsol: ah,
  Dstrok: lh,
  dstrok: uh,
  dtdot: fh,
  dtri: ph,
  dtrif: hh,
  duarr: dh,
  duhar: gh,
  dwangle: bh,
  DZcy: _h,
  dzcy: mh,
  dzigrarr: vh,
  Eacute: xh,
  eacute: kh,
  easter: yh,
  Ecaron: Eh,
  ecaron: wh,
  Ecirc: Ah,
  ecirc: Ch,
  ecir: Sh,
  ecolon: Dh,
  Ecy: Rh,
  ecy: Th,
  eDDot: Mh,
  Edot: Nh,
  edot: qh,
  eDot: Lh,
  ee: Oh,
  efDot: Ih,
  Efr: Bh,
  efr: Fh,
  eg: $h,
  Egrave: Ph,
  egrave: zh,
  egs: Hh,
  egsdot: Uh,
  el: jh,
  Element: Gh,
  elinters: Vh,
  ell: Zh,
  els: Kh,
  elsdot: Wh,
  Emacr: Yh,
  emacr: Jh,
  empty: Xh,
  emptyset: Qh,
  EmptySmallSquare: ed,
  emptyv: nd,
  EmptyVerySmallSquare: td,
  emsp13: rd,
  emsp14: od,
  emsp: sd,
  ENG: cd,
  eng: id,
  ensp: ad,
  Eogon: ld,
  eogon: ud,
  Eopf: fd,
  eopf: pd,
  epar: hd,
  eparsl: dd,
  eplus: gd,
  epsi: bd,
  Epsilon: _d,
  epsilon: md,
  epsiv: vd,
  eqcirc: xd,
  eqcolon: kd,
  eqsim: yd,
  eqslantgtr: Ed,
  eqslantless: wd,
  Equal: Ad,
  equals: Cd,
  EqualTilde: Sd,
  equest: Dd,
  Equilibrium: Rd,
  equiv: Td,
  equivDD: Md,
  eqvparsl: Nd,
  erarr: qd,
  erDot: Ld,
  escr: Od,
  Escr: Id,
  esdot: Bd,
  Esim: Fd,
  esim: $d,
  Eta: Pd,
  eta: zd,
  ETH: Hd,
  eth: Ud,
  Euml: jd,
  euml: Gd,
  euro: Vd,
  excl: Zd,
  exist: Kd,
  Exists: Wd,
  expectation: Yd,
  exponentiale: Jd,
  ExponentialE: Xd,
  fallingdotseq: Qd,
  Fcy: eg,
  fcy: ng,
  female: tg,
  ffilig: rg,
  fflig: og,
  ffllig: sg,
  Ffr: cg,
  ffr: ig,
  filig: ag,
  FilledSmallSquare: lg,
  FilledVerySmallSquare: ug,
  fjlig: fg,
  flat: pg,
  fllig: hg,
  fltns: dg,
  fnof: gg,
  Fopf: bg,
  fopf: _g,
  forall: mg,
  ForAll: vg,
  fork: xg,
  forkv: kg,
  Fouriertrf: yg,
  fpartint: Eg,
  frac12: wg,
  frac13: Ag,
  frac14: Cg,
  frac15: Sg,
  frac16: Dg,
  frac18: Rg,
  frac23: Tg,
  frac25: Mg,
  frac34: Ng,
  frac35: qg,
  frac38: Lg,
  frac45: Og,
  frac56: Ig,
  frac58: Bg,
  frac78: Fg,
  frasl: $g,
  frown: Pg,
  fscr: zg,
  Fscr: Hg,
  gacute: Ug,
  Gamma: jg,
  gamma: Gg,
  Gammad: Vg,
  gammad: Zg,
  gap: Kg,
  Gbreve: Wg,
  gbreve: Yg,
  Gcedil: Jg,
  Gcirc: Xg,
  gcirc: Qg,
  Gcy: e0,
  gcy: n0,
  Gdot: t0,
  gdot: r0,
  ge: o0,
  gE: s0,
  gEl: c0,
  gel: i0,
  geq: a0,
  geqq: l0,
  geqslant: u0,
  gescc: f0,
  ges: p0,
  gesdot: h0,
  gesdoto: d0,
  gesdotol: g0,
  gesl: b0,
  gesles: _0,
  Gfr: m0,
  gfr: v0,
  gg: x0,
  Gg: k0,
  ggg: y0,
  gimel: E0,
  GJcy: w0,
  gjcy: A0,
  gla: C0,
  gl: S0,
  glE: D0,
  glj: R0,
  gnap: T0,
  gnapprox: M0,
  gne: N0,
  gnE: q0,
  gneq: L0,
  gneqq: O0,
  gnsim: I0,
  Gopf: B0,
  gopf: F0,
  grave: $0,
  GreaterEqual: P0,
  GreaterEqualLess: z0,
  GreaterFullEqual: H0,
  GreaterGreater: U0,
  GreaterLess: j0,
  GreaterSlantEqual: G0,
  GreaterTilde: V0,
  Gscr: Z0,
  gscr: K0,
  gsim: W0,
  gsime: Y0,
  gsiml: J0,
  gtcc: X0,
  gtcir: Q0,
  gt: eb,
  GT: nb,
  Gt: tb,
  gtdot: rb,
  gtlPar: ob,
  gtquest: sb,
  gtrapprox: cb,
  gtrarr: ib,
  gtrdot: ab,
  gtreqless: lb,
  gtreqqless: ub,
  gtrless: fb,
  gtrsim: pb,
  gvertneqq: hb,
  gvnE: db,
  Hacek: gb,
  hairsp: bb,
  half: _b,
  hamilt: mb,
  HARDcy: vb,
  hardcy: xb,
  harrcir: kb,
  harr: yb,
  hArr: Eb,
  harrw: wb,
  Hat: Ab,
  hbar: Cb,
  Hcirc: Sb,
  hcirc: Db,
  hearts: Rb,
  heartsuit: Tb,
  hellip: Mb,
  hercon: Nb,
  hfr: qb,
  Hfr: Lb,
  HilbertSpace: Ob,
  hksearow: Ib,
  hkswarow: Bb,
  hoarr: Fb,
  homtht: $b,
  hookleftarrow: Pb,
  hookrightarrow: zb,
  hopf: Hb,
  Hopf: Ub,
  horbar: jb,
  HorizontalLine: Gb,
  hscr: Vb,
  Hscr: Zb,
  hslash: Kb,
  Hstrok: Wb,
  hstrok: Yb,
  HumpDownHump: Jb,
  HumpEqual: Xb,
  hybull: Qb,
  hyphen: e_,
  Iacute: n_,
  iacute: t_,
  ic: r_,
  Icirc: o_,
  icirc: s_,
  Icy: c_,
  icy: i_,
  Idot: a_,
  IEcy: l_,
  iecy: u_,
  iexcl: f_,
  iff: p_,
  ifr: h_,
  Ifr: d_,
  Igrave: g_,
  igrave: b_,
  ii: __,
  iiiint: m_,
  iiint: v_,
  iinfin: x_,
  iiota: k_,
  IJlig: y_,
  ijlig: E_,
  Imacr: w_,
  imacr: A_,
  image: C_,
  ImaginaryI: S_,
  imagline: D_,
  imagpart: R_,
  imath: T_,
  Im: M_,
  imof: N_,
  imped: q_,
  Implies: L_,
  incare: O_,
  in: "∈",
  infin: I_,
  infintie: B_,
  inodot: F_,
  intcal: $_,
  int: P_,
  Int: z_,
  integers: H_,
  Integral: U_,
  intercal: j_,
  Intersection: G_,
  intlarhk: V_,
  intprod: Z_,
  InvisibleComma: K_,
  InvisibleTimes: W_,
  IOcy: Y_,
  iocy: J_,
  Iogon: X_,
  iogon: Q_,
  Iopf: em,
  iopf: nm,
  Iota: tm,
  iota: rm,
  iprod: om,
  iquest: sm,
  iscr: cm,
  Iscr: im,
  isin: am,
  isindot: lm,
  isinE: um,
  isins: fm,
  isinsv: pm,
  isinv: hm,
  it: dm,
  Itilde: gm,
  itilde: bm,
  Iukcy: _m,
  iukcy: mm,
  Iuml: vm,
  iuml: xm,
  Jcirc: km,
  jcirc: ym,
  Jcy: Em,
  jcy: wm,
  Jfr: Am,
  jfr: Cm,
  jmath: Sm,
  Jopf: Dm,
  jopf: Rm,
  Jscr: Tm,
  jscr: Mm,
  Jsercy: Nm,
  jsercy: qm,
  Jukcy: Lm,
  jukcy: Om,
  Kappa: Im,
  kappa: Bm,
  kappav: Fm,
  Kcedil: $m,
  kcedil: Pm,
  Kcy: zm,
  kcy: Hm,
  Kfr: Um,
  kfr: jm,
  kgreen: Gm,
  KHcy: Vm,
  khcy: Zm,
  KJcy: Km,
  kjcy: Wm,
  Kopf: Ym,
  kopf: Jm,
  Kscr: Xm,
  kscr: Qm,
  lAarr: e1,
  Lacute: n1,
  lacute: t1,
  laemptyv: r1,
  lagran: o1,
  Lambda: s1,
  lambda: c1,
  lang: i1,
  Lang: a1,
  langd: l1,
  langle: u1,
  lap: f1,
  Laplacetrf: p1,
  laquo: h1,
  larrb: d1,
  larrbfs: g1,
  larr: b1,
  Larr: _1,
  lArr: m1,
  larrfs: v1,
  larrhk: x1,
  larrlp: k1,
  larrpl: y1,
  larrsim: E1,
  larrtl: w1,
  latail: A1,
  lAtail: C1,
  lat: S1,
  late: D1,
  lates: R1,
  lbarr: T1,
  lBarr: M1,
  lbbrk: N1,
  lbrace: q1,
  lbrack: L1,
  lbrke: O1,
  lbrksld: I1,
  lbrkslu: B1,
  Lcaron: F1,
  lcaron: $1,
  Lcedil: P1,
  lcedil: z1,
  lceil: H1,
  lcub: U1,
  Lcy: j1,
  lcy: G1,
  ldca: V1,
  ldquo: Z1,
  ldquor: K1,
  ldrdhar: W1,
  ldrushar: Y1,
  ldsh: J1,
  le: X1,
  lE: Q1,
  LeftAngleBracket: ev,
  LeftArrowBar: nv,
  leftarrow: tv,
  LeftArrow: rv,
  Leftarrow: ov,
  LeftArrowRightArrow: sv,
  leftarrowtail: cv,
  LeftCeiling: iv,
  LeftDoubleBracket: av,
  LeftDownTeeVector: lv,
  LeftDownVectorBar: uv,
  LeftDownVector: fv,
  LeftFloor: pv,
  leftharpoondown: hv,
  leftharpoonup: dv,
  leftleftarrows: gv,
  leftrightarrow: bv,
  LeftRightArrow: _v,
  Leftrightarrow: mv,
  leftrightarrows: vv,
  leftrightharpoons: xv,
  leftrightsquigarrow: kv,
  LeftRightVector: yv,
  LeftTeeArrow: Ev,
  LeftTee: wv,
  LeftTeeVector: Av,
  leftthreetimes: Cv,
  LeftTriangleBar: Sv,
  LeftTriangle: Dv,
  LeftTriangleEqual: Rv,
  LeftUpDownVector: Tv,
  LeftUpTeeVector: Mv,
  LeftUpVectorBar: Nv,
  LeftUpVector: qv,
  LeftVectorBar: Lv,
  LeftVector: Ov,
  lEg: Iv,
  leg: Bv,
  leq: Fv,
  leqq: $v,
  leqslant: Pv,
  lescc: zv,
  les: Hv,
  lesdot: Uv,
  lesdoto: jv,
  lesdotor: Gv,
  lesg: Vv,
  lesges: Zv,
  lessapprox: Kv,
  lessdot: Wv,
  lesseqgtr: Yv,
  lesseqqgtr: Jv,
  LessEqualGreater: Xv,
  LessFullEqual: Qv,
  LessGreater: ex,
  lessgtr: nx,
  LessLess: tx,
  lesssim: rx,
  LessSlantEqual: ox,
  LessTilde: sx,
  lfisht: cx,
  lfloor: ix,
  Lfr: ax,
  lfr: lx,
  lg: ux,
  lgE: fx,
  lHar: px,
  lhard: hx,
  lharu: dx,
  lharul: gx,
  lhblk: bx,
  LJcy: _x,
  ljcy: mx,
  llarr: vx,
  ll: xx,
  Ll: kx,
  llcorner: yx,
  Lleftarrow: Ex,
  llhard: wx,
  lltri: Ax,
  Lmidot: Cx,
  lmidot: Sx,
  lmoustache: Dx,
  lmoust: Rx,
  lnap: Tx,
  lnapprox: Mx,
  lne: Nx,
  lnE: qx,
  lneq: Lx,
  lneqq: Ox,
  lnsim: Ix,
  loang: Bx,
  loarr: Fx,
  lobrk: $x,
  longleftarrow: Px,
  LongLeftArrow: zx,
  Longleftarrow: Hx,
  longleftrightarrow: Ux,
  LongLeftRightArrow: jx,
  Longleftrightarrow: Gx,
  longmapsto: Vx,
  longrightarrow: Zx,
  LongRightArrow: Kx,
  Longrightarrow: Wx,
  looparrowleft: Yx,
  looparrowright: Jx,
  lopar: Xx,
  Lopf: Qx,
  lopf: ek,
  loplus: nk,
  lotimes: tk,
  lowast: rk,
  lowbar: ok,
  LowerLeftArrow: sk,
  LowerRightArrow: ck,
  loz: ik,
  lozenge: ak,
  lozf: lk,
  lpar: uk,
  lparlt: fk,
  lrarr: pk,
  lrcorner: hk,
  lrhar: dk,
  lrhard: gk,
  lrm: bk,
  lrtri: _k,
  lsaquo: mk,
  lscr: vk,
  Lscr: xk,
  lsh: kk,
  Lsh: yk,
  lsim: Ek,
  lsime: wk,
  lsimg: Ak,
  lsqb: Ck,
  lsquo: Sk,
  lsquor: Dk,
  Lstrok: Rk,
  lstrok: Tk,
  ltcc: Mk,
  ltcir: Nk,
  lt: qk,
  LT: Lk,
  Lt: Ok,
  ltdot: Ik,
  lthree: Bk,
  ltimes: Fk,
  ltlarr: $k,
  ltquest: Pk,
  ltri: zk,
  ltrie: Hk,
  ltrif: Uk,
  ltrPar: jk,
  lurdshar: Gk,
  luruhar: Vk,
  lvertneqq: Zk,
  lvnE: Kk,
  macr: Wk,
  male: Yk,
  malt: Jk,
  maltese: Xk,
  Map: "⤅",
  map: Qk,
  mapsto: ey,
  mapstodown: ny,
  mapstoleft: ty,
  mapstoup: ry,
  marker: oy,
  mcomma: sy,
  Mcy: cy,
  mcy: iy,
  mdash: ay,
  mDDot: ly,
  measuredangle: uy,
  MediumSpace: fy,
  Mellintrf: py,
  Mfr: hy,
  mfr: dy,
  mho: gy,
  micro: by,
  midast: _y,
  midcir: my,
  mid: vy,
  middot: xy,
  minusb: ky,
  minus: yy,
  minusd: Ey,
  minusdu: wy,
  MinusPlus: Ay,
  mlcp: Cy,
  mldr: Sy,
  mnplus: Dy,
  models: Ry,
  Mopf: Ty,
  mopf: My,
  mp: Ny,
  mscr: qy,
  Mscr: Ly,
  mstpos: Oy,
  Mu: Iy,
  mu: By,
  multimap: Fy,
  mumap: $y,
  nabla: Py,
  Nacute: zy,
  nacute: Hy,
  nang: Uy,
  nap: jy,
  napE: Gy,
  napid: Vy,
  napos: Zy,
  napprox: Ky,
  natural: Wy,
  naturals: Yy,
  natur: Jy,
  nbsp: Xy,
  nbump: Qy,
  nbumpe: eE,
  ncap: nE,
  Ncaron: tE,
  ncaron: rE,
  Ncedil: oE,
  ncedil: sE,
  ncong: cE,
  ncongdot: iE,
  ncup: aE,
  Ncy: lE,
  ncy: uE,
  ndash: fE,
  nearhk: pE,
  nearr: hE,
  neArr: dE,
  nearrow: gE,
  ne: bE,
  nedot: _E,
  NegativeMediumSpace: mE,
  NegativeThickSpace: vE,
  NegativeThinSpace: xE,
  NegativeVeryThinSpace: kE,
  nequiv: yE,
  nesear: EE,
  nesim: wE,
  NestedGreaterGreater: AE,
  NestedLessLess: CE,
  NewLine: SE,
  nexist: DE,
  nexists: RE,
  Nfr: TE,
  nfr: ME,
  ngE: NE,
  nge: qE,
  ngeq: LE,
  ngeqq: OE,
  ngeqslant: IE,
  nges: BE,
  nGg: FE,
  ngsim: $E,
  nGt: PE,
  ngt: zE,
  ngtr: HE,
  nGtv: UE,
  nharr: jE,
  nhArr: GE,
  nhpar: VE,
  ni: ZE,
  nis: KE,
  nisd: WE,
  niv: YE,
  NJcy: JE,
  njcy: XE,
  nlarr: QE,
  nlArr: ew,
  nldr: nw,
  nlE: tw,
  nle: rw,
  nleftarrow: ow,
  nLeftarrow: sw,
  nleftrightarrow: cw,
  nLeftrightarrow: iw,
  nleq: aw,
  nleqq: lw,
  nleqslant: uw,
  nles: fw,
  nless: pw,
  nLl: hw,
  nlsim: dw,
  nLt: gw,
  nlt: bw,
  nltri: _w,
  nltrie: mw,
  nLtv: vw,
  nmid: xw,
  NoBreak: kw,
  NonBreakingSpace: yw,
  nopf: Ew,
  Nopf: ww,
  Not: Aw,
  not: Cw,
  NotCongruent: Sw,
  NotCupCap: Dw,
  NotDoubleVerticalBar: Rw,
  NotElement: Tw,
  NotEqual: Mw,
  NotEqualTilde: Nw,
  NotExists: qw,
  NotGreater: Lw,
  NotGreaterEqual: Ow,
  NotGreaterFullEqual: Iw,
  NotGreaterGreater: Bw,
  NotGreaterLess: Fw,
  NotGreaterSlantEqual: $w,
  NotGreaterTilde: Pw,
  NotHumpDownHump: zw,
  NotHumpEqual: Hw,
  notin: Uw,
  notindot: jw,
  notinE: Gw,
  notinva: Vw,
  notinvb: Zw,
  notinvc: Kw,
  NotLeftTriangleBar: Ww,
  NotLeftTriangle: Yw,
  NotLeftTriangleEqual: Jw,
  NotLess: Xw,
  NotLessEqual: Qw,
  NotLessGreater: eA,
  NotLessLess: nA,
  NotLessSlantEqual: tA,
  NotLessTilde: rA,
  NotNestedGreaterGreater: oA,
  NotNestedLessLess: sA,
  notni: cA,
  notniva: iA,
  notnivb: aA,
  notnivc: lA,
  NotPrecedes: uA,
  NotPrecedesEqual: fA,
  NotPrecedesSlantEqual: pA,
  NotReverseElement: hA,
  NotRightTriangleBar: dA,
  NotRightTriangle: gA,
  NotRightTriangleEqual: bA,
  NotSquareSubset: _A,
  NotSquareSubsetEqual: mA,
  NotSquareSuperset: vA,
  NotSquareSupersetEqual: xA,
  NotSubset: kA,
  NotSubsetEqual: yA,
  NotSucceeds: EA,
  NotSucceedsEqual: wA,
  NotSucceedsSlantEqual: AA,
  NotSucceedsTilde: CA,
  NotSuperset: SA,
  NotSupersetEqual: DA,
  NotTilde: RA,
  NotTildeEqual: TA,
  NotTildeFullEqual: MA,
  NotTildeTilde: NA,
  NotVerticalBar: qA,
  nparallel: LA,
  npar: OA,
  nparsl: IA,
  npart: BA,
  npolint: FA,
  npr: $A,
  nprcue: PA,
  nprec: zA,
  npreceq: HA,
  npre: UA,
  nrarrc: jA,
  nrarr: GA,
  nrArr: VA,
  nrarrw: ZA,
  nrightarrow: KA,
  nRightarrow: WA,
  nrtri: YA,
  nrtrie: JA,
  nsc: XA,
  nsccue: QA,
  nsce: eC,
  Nscr: nC,
  nscr: tC,
  nshortmid: rC,
  nshortparallel: oC,
  nsim: sC,
  nsime: cC,
  nsimeq: iC,
  nsmid: aC,
  nspar: lC,
  nsqsube: uC,
  nsqsupe: fC,
  nsub: pC,
  nsubE: hC,
  nsube: dC,
  nsubset: gC,
  nsubseteq: bC,
  nsubseteqq: _C,
  nsucc: mC,
  nsucceq: vC,
  nsup: xC,
  nsupE: kC,
  nsupe: yC,
  nsupset: EC,
  nsupseteq: wC,
  nsupseteqq: AC,
  ntgl: CC,
  Ntilde: SC,
  ntilde: DC,
  ntlg: RC,
  ntriangleleft: TC,
  ntrianglelefteq: MC,
  ntriangleright: NC,
  ntrianglerighteq: qC,
  Nu: LC,
  nu: OC,
  num: IC,
  numero: BC,
  numsp: FC,
  nvap: $C,
  nvdash: PC,
  nvDash: zC,
  nVdash: HC,
  nVDash: UC,
  nvge: jC,
  nvgt: GC,
  nvHarr: VC,
  nvinfin: ZC,
  nvlArr: KC,
  nvle: WC,
  nvlt: YC,
  nvltrie: JC,
  nvrArr: XC,
  nvrtrie: QC,
  nvsim: eS,
  nwarhk: nS,
  nwarr: tS,
  nwArr: rS,
  nwarrow: oS,
  nwnear: sS,
  Oacute: cS,
  oacute: iS,
  oast: aS,
  Ocirc: lS,
  ocirc: uS,
  ocir: fS,
  Ocy: pS,
  ocy: hS,
  odash: dS,
  Odblac: gS,
  odblac: bS,
  odiv: _S,
  odot: mS,
  odsold: vS,
  OElig: xS,
  oelig: kS,
  ofcir: yS,
  Ofr: ES,
  ofr: wS,
  ogon: AS,
  Ograve: CS,
  ograve: SS,
  ogt: DS,
  ohbar: RS,
  ohm: TS,
  oint: MS,
  olarr: NS,
  olcir: qS,
  olcross: LS,
  oline: OS,
  olt: IS,
  Omacr: BS,
  omacr: FS,
  Omega: $S,
  omega: PS,
  Omicron: zS,
  omicron: HS,
  omid: US,
  ominus: jS,
  Oopf: GS,
  oopf: VS,
  opar: ZS,
  OpenCurlyDoubleQuote: KS,
  OpenCurlyQuote: WS,
  operp: YS,
  oplus: JS,
  orarr: XS,
  Or: QS,
  or: e2,
  ord: n2,
  order: t2,
  orderof: r2,
  ordf: o2,
  ordm: s2,
  origof: c2,
  oror: i2,
  orslope: a2,
  orv: l2,
  oS: u2,
  Oscr: f2,
  oscr: p2,
  Oslash: h2,
  oslash: d2,
  osol: g2,
  Otilde: b2,
  otilde: _2,
  otimesas: m2,
  Otimes: v2,
  otimes: x2,
  Ouml: k2,
  ouml: y2,
  ovbar: E2,
  OverBar: w2,
  OverBrace: A2,
  OverBracket: C2,
  OverParenthesis: S2,
  para: D2,
  parallel: R2,
  par: T2,
  parsim: M2,
  parsl: N2,
  part: q2,
  PartialD: L2,
  Pcy: O2,
  pcy: I2,
  percnt: B2,
  period: F2,
  permil: $2,
  perp: P2,
  pertenk: z2,
  Pfr: H2,
  pfr: U2,
  Phi: j2,
  phi: G2,
  phiv: V2,
  phmmat: Z2,
  phone: K2,
  Pi: W2,
  pi: Y2,
  pitchfork: J2,
  piv: X2,
  planck: Q2,
  planckh: eD,
  plankv: nD,
  plusacir: tD,
  plusb: rD,
  pluscir: oD,
  plus: sD,
  plusdo: cD,
  plusdu: iD,
  pluse: aD,
  PlusMinus: lD,
  plusmn: uD,
  plussim: fD,
  plustwo: pD,
  pm: hD,
  Poincareplane: dD,
  pointint: gD,
  popf: bD,
  Popf: _D,
  pound: mD,
  prap: vD,
  Pr: xD,
  pr: kD,
  prcue: yD,
  precapprox: ED,
  prec: wD,
  preccurlyeq: AD,
  Precedes: CD,
  PrecedesEqual: SD,
  PrecedesSlantEqual: DD,
  PrecedesTilde: RD,
  preceq: TD,
  precnapprox: MD,
  precneqq: ND,
  precnsim: qD,
  pre: LD,
  prE: OD,
  precsim: ID,
  prime: BD,
  Prime: FD,
  primes: $D,
  prnap: PD,
  prnE: zD,
  prnsim: HD,
  prod: UD,
  Product: jD,
  profalar: GD,
  profline: VD,
  profsurf: ZD,
  prop: KD,
  Proportional: WD,
  Proportion: YD,
  propto: JD,
  prsim: XD,
  prurel: QD,
  Pscr: eR,
  pscr: nR,
  Psi: tR,
  psi: rR,
  puncsp: oR,
  Qfr: sR,
  qfr: cR,
  qint: iR,
  qopf: aR,
  Qopf: lR,
  qprime: uR,
  Qscr: fR,
  qscr: pR,
  quaternions: hR,
  quatint: dR,
  quest: gR,
  questeq: bR,
  quot: _R,
  QUOT: mR,
  rAarr: vR,
  race: xR,
  Racute: kR,
  racute: yR,
  radic: ER,
  raemptyv: wR,
  rang: AR,
  Rang: CR,
  rangd: SR,
  range: DR,
  rangle: RR,
  raquo: TR,
  rarrap: MR,
  rarrb: NR,
  rarrbfs: qR,
  rarrc: LR,
  rarr: OR,
  Rarr: IR,
  rArr: BR,
  rarrfs: FR,
  rarrhk: $R,
  rarrlp: PR,
  rarrpl: zR,
  rarrsim: HR,
  Rarrtl: UR,
  rarrtl: jR,
  rarrw: GR,
  ratail: VR,
  rAtail: ZR,
  ratio: KR,
  rationals: WR,
  rbarr: YR,
  rBarr: JR,
  RBarr: XR,
  rbbrk: QR,
  rbrace: eT,
  rbrack: nT,
  rbrke: tT,
  rbrksld: rT,
  rbrkslu: oT,
  Rcaron: sT,
  rcaron: cT,
  Rcedil: iT,
  rcedil: aT,
  rceil: lT,
  rcub: uT,
  Rcy: fT,
  rcy: pT,
  rdca: hT,
  rdldhar: dT,
  rdquo: gT,
  rdquor: bT,
  rdsh: _T,
  real: mT,
  realine: vT,
  realpart: xT,
  reals: kT,
  Re: yT,
  rect: ET,
  reg: wT,
  REG: AT,
  ReverseElement: CT,
  ReverseEquilibrium: ST,
  ReverseUpEquilibrium: DT,
  rfisht: RT,
  rfloor: TT,
  rfr: MT,
  Rfr: NT,
  rHar: qT,
  rhard: LT,
  rharu: OT,
  rharul: IT,
  Rho: BT,
  rho: FT,
  rhov: $T,
  RightAngleBracket: PT,
  RightArrowBar: zT,
  rightarrow: HT,
  RightArrow: UT,
  Rightarrow: jT,
  RightArrowLeftArrow: GT,
  rightarrowtail: VT,
  RightCeiling: ZT,
  RightDoubleBracket: KT,
  RightDownTeeVector: WT,
  RightDownVectorBar: YT,
  RightDownVector: JT,
  RightFloor: XT,
  rightharpoondown: QT,
  rightharpoonup: e3,
  rightleftarrows: n3,
  rightleftharpoons: t3,
  rightrightarrows: r3,
  rightsquigarrow: o3,
  RightTeeArrow: s3,
  RightTee: c3,
  RightTeeVector: i3,
  rightthreetimes: a3,
  RightTriangleBar: l3,
  RightTriangle: u3,
  RightTriangleEqual: f3,
  RightUpDownVector: p3,
  RightUpTeeVector: h3,
  RightUpVectorBar: d3,
  RightUpVector: g3,
  RightVectorBar: b3,
  RightVector: _3,
  ring: m3,
  risingdotseq: v3,
  rlarr: x3,
  rlhar: k3,
  rlm: y3,
  rmoustache: E3,
  rmoust: w3,
  rnmid: A3,
  roang: C3,
  roarr: S3,
  robrk: D3,
  ropar: R3,
  ropf: T3,
  Ropf: M3,
  roplus: N3,
  rotimes: q3,
  RoundImplies: L3,
  rpar: O3,
  rpargt: I3,
  rppolint: B3,
  rrarr: F3,
  Rrightarrow: $3,
  rsaquo: P3,
  rscr: z3,
  Rscr: H3,
  rsh: U3,
  Rsh: j3,
  rsqb: G3,
  rsquo: V3,
  rsquor: Z3,
  rthree: K3,
  rtimes: W3,
  rtri: Y3,
  rtrie: J3,
  rtrif: X3,
  rtriltri: Q3,
  RuleDelayed: eM,
  ruluhar: nM,
  rx: tM,
  Sacute: rM,
  sacute: oM,
  sbquo: sM,
  scap: cM,
  Scaron: iM,
  scaron: aM,
  Sc: lM,
  sc: uM,
  sccue: fM,
  sce: pM,
  scE: hM,
  Scedil: dM,
  scedil: gM,
  Scirc: bM,
  scirc: _M,
  scnap: mM,
  scnE: vM,
  scnsim: xM,
  scpolint: kM,
  scsim: yM,
  Scy: EM,
  scy: wM,
  sdotb: AM,
  sdot: CM,
  sdote: SM,
  searhk: DM,
  searr: RM,
  seArr: TM,
  searrow: MM,
  sect: NM,
  semi: qM,
  seswar: LM,
  setminus: OM,
  setmn: IM,
  sext: BM,
  Sfr: FM,
  sfr: $M,
  sfrown: PM,
  sharp: zM,
  SHCHcy: HM,
  shchcy: UM,
  SHcy: jM,
  shcy: GM,
  ShortDownArrow: VM,
  ShortLeftArrow: ZM,
  shortmid: KM,
  shortparallel: WM,
  ShortRightArrow: YM,
  ShortUpArrow: JM,
  shy: XM,
  Sigma: QM,
  sigma: eN,
  sigmaf: nN,
  sigmav: tN,
  sim: rN,
  simdot: oN,
  sime: sN,
  simeq: cN,
  simg: iN,
  simgE: aN,
  siml: lN,
  simlE: uN,
  simne: fN,
  simplus: pN,
  simrarr: hN,
  slarr: dN,
  SmallCircle: gN,
  smallsetminus: bN,
  smashp: _N,
  smeparsl: mN,
  smid: vN,
  smile: xN,
  smt: kN,
  smte: yN,
  smtes: EN,
  SOFTcy: wN,
  softcy: AN,
  solbar: CN,
  solb: SN,
  sol: DN,
  Sopf: RN,
  sopf: TN,
  spades: MN,
  spadesuit: NN,
  spar: qN,
  sqcap: LN,
  sqcaps: ON,
  sqcup: IN,
  sqcups: BN,
  Sqrt: FN,
  sqsub: $N,
  sqsube: PN,
  sqsubset: zN,
  sqsubseteq: HN,
  sqsup: UN,
  sqsupe: jN,
  sqsupset: GN,
  sqsupseteq: VN,
  square: ZN,
  Square: KN,
  SquareIntersection: WN,
  SquareSubset: YN,
  SquareSubsetEqual: JN,
  SquareSuperset: XN,
  SquareSupersetEqual: QN,
  SquareUnion: eq,
  squarf: nq,
  squ: tq,
  squf: rq,
  srarr: oq,
  Sscr: sq,
  sscr: cq,
  ssetmn: iq,
  ssmile: aq,
  sstarf: lq,
  Star: uq,
  star: fq,
  starf: pq,
  straightepsilon: hq,
  straightphi: dq,
  strns: gq,
  sub: bq,
  Sub: _q,
  subdot: mq,
  subE: vq,
  sube: xq,
  subedot: kq,
  submult: yq,
  subnE: Eq,
  subne: wq,
  subplus: Aq,
  subrarr: Cq,
  subset: Sq,
  Subset: Dq,
  subseteq: Rq,
  subseteqq: Tq,
  SubsetEqual: Mq,
  subsetneq: Nq,
  subsetneqq: qq,
  subsim: Lq,
  subsub: Oq,
  subsup: Iq,
  succapprox: Bq,
  succ: Fq,
  succcurlyeq: $q,
  Succeeds: Pq,
  SucceedsEqual: zq,
  SucceedsSlantEqual: Hq,
  SucceedsTilde: Uq,
  succeq: jq,
  succnapprox: Gq,
  succneqq: Vq,
  succnsim: Zq,
  succsim: Kq,
  SuchThat: Wq,
  sum: Yq,
  Sum: Jq,
  sung: Xq,
  sup1: Qq,
  sup2: eL,
  sup3: nL,
  sup: tL,
  Sup: rL,
  supdot: oL,
  supdsub: sL,
  supE: cL,
  supe: iL,
  supedot: aL,
  Superset: lL,
  SupersetEqual: uL,
  suphsol: fL,
  suphsub: pL,
  suplarr: hL,
  supmult: dL,
  supnE: gL,
  supne: bL,
  supplus: _L,
  supset: mL,
  Supset: vL,
  supseteq: xL,
  supseteqq: kL,
  supsetneq: yL,
  supsetneqq: EL,
  supsim: wL,
  supsub: AL,
  supsup: CL,
  swarhk: SL,
  swarr: DL,
  swArr: RL,
  swarrow: TL,
  swnwar: ML,
  szlig: NL,
  Tab: qL,
  target: LL,
  Tau: OL,
  tau: IL,
  tbrk: BL,
  Tcaron: FL,
  tcaron: $L,
  Tcedil: PL,
  tcedil: zL,
  Tcy: HL,
  tcy: UL,
  tdot: jL,
  telrec: GL,
  Tfr: VL,
  tfr: ZL,
  there4: KL,
  therefore: WL,
  Therefore: YL,
  Theta: JL,
  theta: XL,
  thetasym: QL,
  thetav: eO,
  thickapprox: nO,
  thicksim: tO,
  ThickSpace: rO,
  ThinSpace: oO,
  thinsp: sO,
  thkap: cO,
  thksim: iO,
  THORN: aO,
  thorn: lO,
  tilde: uO,
  Tilde: fO,
  TildeEqual: pO,
  TildeFullEqual: hO,
  TildeTilde: dO,
  timesbar: gO,
  timesb: bO,
  times: _O,
  timesd: mO,
  tint: vO,
  toea: xO,
  topbot: kO,
  topcir: yO,
  top: EO,
  Topf: wO,
  topf: AO,
  topfork: CO,
  tosa: SO,
  tprime: DO,
  trade: RO,
  TRADE: TO,
  triangle: MO,
  triangledown: NO,
  triangleleft: qO,
  trianglelefteq: LO,
  triangleq: OO,
  triangleright: IO,
  trianglerighteq: BO,
  tridot: FO,
  trie: $O,
  triminus: PO,
  TripleDot: zO,
  triplus: HO,
  trisb: UO,
  tritime: jO,
  trpezium: GO,
  Tscr: VO,
  tscr: ZO,
  TScy: KO,
  tscy: WO,
  TSHcy: YO,
  tshcy: JO,
  Tstrok: XO,
  tstrok: QO,
  twixt: eI,
  twoheadleftarrow: nI,
  twoheadrightarrow: tI,
  Uacute: rI,
  uacute: oI,
  uarr: sI,
  Uarr: cI,
  uArr: iI,
  Uarrocir: aI,
  Ubrcy: lI,
  ubrcy: uI,
  Ubreve: fI,
  ubreve: pI,
  Ucirc: hI,
  ucirc: dI,
  Ucy: gI,
  ucy: bI,
  udarr: _I,
  Udblac: mI,
  udblac: vI,
  udhar: xI,
  ufisht: kI,
  Ufr: yI,
  ufr: EI,
  Ugrave: wI,
  ugrave: AI,
  uHar: CI,
  uharl: SI,
  uharr: DI,
  uhblk: RI,
  ulcorn: TI,
  ulcorner: MI,
  ulcrop: NI,
  ultri: qI,
  Umacr: LI,
  umacr: OI,
  uml: II,
  UnderBar: BI,
  UnderBrace: FI,
  UnderBracket: $I,
  UnderParenthesis: PI,
  Union: zI,
  UnionPlus: HI,
  Uogon: UI,
  uogon: jI,
  Uopf: GI,
  uopf: VI,
  UpArrowBar: ZI,
  uparrow: KI,
  UpArrow: WI,
  Uparrow: YI,
  UpArrowDownArrow: JI,
  updownarrow: XI,
  UpDownArrow: QI,
  Updownarrow: e5,
  UpEquilibrium: n5,
  upharpoonleft: t5,
  upharpoonright: r5,
  uplus: o5,
  UpperLeftArrow: s5,
  UpperRightArrow: c5,
  upsi: i5,
  Upsi: a5,
  upsih: l5,
  Upsilon: u5,
  upsilon: f5,
  UpTeeArrow: p5,
  UpTee: h5,
  upuparrows: d5,
  urcorn: g5,
  urcorner: b5,
  urcrop: _5,
  Uring: m5,
  uring: v5,
  urtri: x5,
  Uscr: k5,
  uscr: y5,
  utdot: E5,
  Utilde: w5,
  utilde: A5,
  utri: C5,
  utrif: S5,
  uuarr: D5,
  Uuml: R5,
  uuml: T5,
  uwangle: M5,
  vangrt: N5,
  varepsilon: q5,
  varkappa: L5,
  varnothing: O5,
  varphi: I5,
  varpi: B5,
  varpropto: F5,
  varr: $5,
  vArr: P5,
  varrho: z5,
  varsigma: H5,
  varsubsetneq: U5,
  varsubsetneqq: j5,
  varsupsetneq: G5,
  varsupsetneqq: V5,
  vartheta: Z5,
  vartriangleleft: K5,
  vartriangleright: W5,
  vBar: Y5,
  Vbar: J5,
  vBarv: X5,
  Vcy: Q5,
  vcy: eB,
  vdash: nB,
  vDash: tB,
  Vdash: rB,
  VDash: oB,
  Vdashl: sB,
  veebar: cB,
  vee: iB,
  Vee: aB,
  veeeq: lB,
  vellip: uB,
  verbar: fB,
  Verbar: pB,
  vert: hB,
  Vert: dB,
  VerticalBar: gB,
  VerticalLine: bB,
  VerticalSeparator: _B,
  VerticalTilde: mB,
  VeryThinSpace: vB,
  Vfr: xB,
  vfr: kB,
  vltri: yB,
  vnsub: EB,
  vnsup: wB,
  Vopf: AB,
  vopf: CB,
  vprop: SB,
  vrtri: DB,
  Vscr: RB,
  vscr: TB,
  vsubnE: MB,
  vsubne: NB,
  vsupnE: qB,
  vsupne: LB,
  Vvdash: OB,
  vzigzag: IB,
  Wcirc: BB,
  wcirc: FB,
  wedbar: $B,
  wedge: PB,
  Wedge: zB,
  wedgeq: HB,
  weierp: UB,
  Wfr: jB,
  wfr: GB,
  Wopf: VB,
  wopf: ZB,
  wp: KB,
  wr: WB,
  wreath: YB,
  Wscr: JB,
  wscr: XB,
  xcap: QB,
  xcirc: e6,
  xcup: n6,
  xdtri: t6,
  Xfr: r6,
  xfr: o6,
  xharr: s6,
  xhArr: c6,
  Xi: i6,
  xi: a6,
  xlarr: l6,
  xlArr: u6,
  xmap: f6,
  xnis: p6,
  xodot: h6,
  Xopf: d6,
  xopf: g6,
  xoplus: b6,
  xotime: _6,
  xrarr: m6,
  xrArr: v6,
  Xscr: x6,
  xscr: k6,
  xsqcup: y6,
  xuplus: E6,
  xutri: w6,
  xvee: A6,
  xwedge: C6,
  Yacute: S6,
  yacute: D6,
  YAcy: R6,
  yacy: T6,
  Ycirc: M6,
  ycirc: N6,
  Ycy: q6,
  ycy: L6,
  yen: O6,
  Yfr: I6,
  yfr: B6,
  YIcy: F6,
  yicy: $6,
  Yopf: P6,
  yopf: z6,
  Yscr: H6,
  yscr: U6,
  YUcy: j6,
  yucy: G6,
  yuml: V6,
  Yuml: Z6,
  Zacute: K6,
  zacute: W6,
  Zcaron: Y6,
  zcaron: J6,
  Zcy: X6,
  zcy: Q6,
  Zdot: eF,
  zdot: nF,
  zeetrf: tF,
  ZeroWidthSpace: rF,
  Zeta: oF,
  zeta: sF,
  zfr: cF,
  Zfr: iF,
  ZHcy: aF,
  zhcy: lF,
  zigrarr: uF,
  zopf: fF,
  Zopf: pF,
  Zscr: hF,
  zscr: dF,
  zwj: gF,
  zwnj: bF
};
(function(n) {
  n.exports = _F;
})(Xo);
var nt = /[!-#%-\*,-\/:;\?@\[-\]_\{\}\xA1\xA7\xAB\xB6\xB7\xBB\xBF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166D\u166E\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2010-\u2027\u2030-\u2043\u2045-\u2051\u2053-\u205E\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E4E\u3001-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]|\uD800[\uDD00-\uDD02\uDF9F\uDFD0]|\uD801\uDD6F|\uD802[\uDC57\uDD1F\uDD3F\uDE50-\uDE58\uDE7F\uDEF0-\uDEF6\uDF39-\uDF3F\uDF99-\uDF9C]|\uD803[\uDF55-\uDF59]|\uD804[\uDC47-\uDC4D\uDCBB\uDCBC\uDCBE-\uDCC1\uDD40-\uDD43\uDD74\uDD75\uDDC5-\uDDC8\uDDCD\uDDDB\uDDDD-\uDDDF\uDE38-\uDE3D\uDEA9]|\uD805[\uDC4B-\uDC4F\uDC5B\uDC5D\uDCC6\uDDC1-\uDDD7\uDE41-\uDE43\uDE60-\uDE6C\uDF3C-\uDF3E]|\uD806[\uDC3B\uDE3F-\uDE46\uDE9A-\uDE9C\uDE9E-\uDEA2]|\uD807[\uDC41-\uDC45\uDC70\uDC71\uDEF7\uDEF8]|\uD809[\uDC70-\uDC74]|\uD81A[\uDE6E\uDE6F\uDEF5\uDF37-\uDF3B\uDF44]|\uD81B[\uDE97-\uDE9A]|\uD82F\uDC9F|\uD836[\uDE87-\uDE8B]|\uD83A[\uDD5E\uDD5F]/, Ie = {}, vt = {};
function mF(n) {
  var e, t, r = vt[n];
  if (r)
    return r;
  for (r = vt[n] = [], e = 0; e < 128; e++)
    t = String.fromCharCode(e), /^[0-9a-z]$/i.test(t) ? r.push(t) : r.push("%" + ("0" + e.toString(16).toUpperCase()).slice(-2));
  for (e = 0; e < n.length; e++)
    r[n.charCodeAt(e)] = n[e];
  return r;
}
function dn(n, e, t) {
  var r, s, c, i, o, a = "";
  for (typeof e != "string" && (t = e, e = dn.defaultChars), typeof t > "u" && (t = !0), o = mF(e), r = 0, s = n.length; r < s; r++) {
    if (c = n.charCodeAt(r), t && c === 37 && r + 2 < s && /^[0-9a-f]{2}$/i.test(n.slice(r + 1, r + 3))) {
      a += n.slice(r, r + 3), r += 2;
      continue;
    }
    if (c < 128) {
      a += o[c];
      continue;
    }
    if (c >= 55296 && c <= 57343) {
      if (c >= 55296 && c <= 56319 && r + 1 < s && (i = n.charCodeAt(r + 1), i >= 56320 && i <= 57343)) {
        a += encodeURIComponent(n[r] + n[r + 1]), r++;
        continue;
      }
      a += "%EF%BF%BD";
      continue;
    }
    a += encodeURIComponent(n[r]);
  }
  return a;
}
dn.defaultChars = ";/?:@&=+$,-_.!~*'()#";
dn.componentChars = "-_.!~*'()";
var vF = dn, xt = {};
function xF(n) {
  var e, t, r = xt[n];
  if (r)
    return r;
  for (r = xt[n] = [], e = 0; e < 128; e++)
    t = String.fromCharCode(e), r.push(t);
  for (e = 0; e < n.length; e++)
    t = n.charCodeAt(e), r[t] = "%" + ("0" + t.toString(16).toUpperCase()).slice(-2);
  return r;
}
function gn(n, e) {
  var t;
  return typeof e != "string" && (e = gn.defaultChars), t = xF(e), n.replace(/(%[a-f0-9]{2})+/gi, function(r) {
    var s, c, i, o, a, l, u, d = "";
    for (s = 0, c = r.length; s < c; s += 3) {
      if (i = parseInt(r.slice(s + 1, s + 3), 16), i < 128) {
        d += t[i];
        continue;
      }
      if ((i & 224) === 192 && s + 3 < c && (o = parseInt(r.slice(s + 4, s + 6), 16), (o & 192) === 128)) {
        u = i << 6 & 1984 | o & 63, u < 128 ? d += "��" : d += String.fromCharCode(u), s += 3;
        continue;
      }
      if ((i & 240) === 224 && s + 6 < c && (o = parseInt(r.slice(s + 4, s + 6), 16), a = parseInt(r.slice(s + 7, s + 9), 16), (o & 192) === 128 && (a & 192) === 128)) {
        u = i << 12 & 61440 | o << 6 & 4032 | a & 63, u < 2048 || u >= 55296 && u <= 57343 ? d += "���" : d += String.fromCharCode(u), s += 6;
        continue;
      }
      if ((i & 248) === 240 && s + 9 < c && (o = parseInt(r.slice(s + 4, s + 6), 16), a = parseInt(r.slice(s + 7, s + 9), 16), l = parseInt(r.slice(s + 10, s + 12), 16), (o & 192) === 128 && (a & 192) === 128 && (l & 192) === 128)) {
        u = i << 18 & 1835008 | o << 12 & 258048 | a << 6 & 4032 | l & 63, u < 65536 || u > 1114111 ? d += "����" : (u -= 65536, d += String.fromCharCode(55296 + (u >> 10), 56320 + (u & 1023))), s += 9;
        continue;
      }
      d += "�";
    }
    return d;
  });
}
gn.defaultChars = ";/?:@&=+$,#";
gn.componentChars = "";
var kF = gn, yF = function(e) {
  var t = "";
  return t += e.protocol || "", t += e.slashes ? "//" : "", t += e.auth ? e.auth + "@" : "", e.hostname && e.hostname.indexOf(":") !== -1 ? t += "[" + e.hostname + "]" : t += e.hostname || "", t += e.port ? ":" + e.port : "", t += e.pathname || "", t += e.search || "", t += e.hash || "", t;
};
function sn() {
  this.protocol = null, this.slashes = null, this.auth = null, this.port = null, this.hostname = null, this.hash = null, this.search = null, this.pathname = null;
}
var EF = /^([a-z0-9.+-]+:)/i, wF = /:[0-9]*$/, AF = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/, CF = ["<", ">", '"', "`", " ", "\r", `
`, "	"], SF = ["{", "}", "|", "\\", "^", "`"].concat(CF), DF = ["'"].concat(SF), kt = ["%", "/", "?", ";", "#"].concat(DF), yt = ["/", "?", "#"], RF = 255, Et = /^[+a-z0-9A-Z_-]{0,63}$/, TF = /^([+a-z0-9A-Z_-]{0,63})(.*)$/, wt = {
  javascript: !0,
  "javascript:": !0
}, At = {
  http: !0,
  https: !0,
  ftp: !0,
  gopher: !0,
  file: !0,
  "http:": !0,
  "https:": !0,
  "ftp:": !0,
  "gopher:": !0,
  "file:": !0
};
function MF(n, e) {
  if (n && n instanceof sn)
    return n;
  var t = new sn();
  return t.parse(n, e), t;
}
sn.prototype.parse = function(n, e) {
  var t, r, s, c, i, o = n;
  if (o = o.trim(), !e && n.split("#").length === 1) {
    var a = AF.exec(o);
    if (a)
      return this.pathname = a[1], a[2] && (this.search = a[2]), this;
  }
  var l = EF.exec(o);
  if (l && (l = l[0], s = l.toLowerCase(), this.protocol = l, o = o.substr(l.length)), (e || l || o.match(/^\/\/[^@\/]+@[^@\/]+/)) && (i = o.substr(0, 2) === "//", i && !(l && wt[l]) && (o = o.substr(2), this.slashes = !0)), !wt[l] && (i || l && !At[l])) {
    var u = -1;
    for (t = 0; t < yt.length; t++)
      c = o.indexOf(yt[t]), c !== -1 && (u === -1 || c < u) && (u = c);
    var d, p;
    for (u === -1 ? p = o.lastIndexOf("@") : p = o.lastIndexOf("@", u), p !== -1 && (d = o.slice(0, p), o = o.slice(p + 1), this.auth = d), u = -1, t = 0; t < kt.length; t++)
      c = o.indexOf(kt[t]), c !== -1 && (u === -1 || c < u) && (u = c);
    u === -1 && (u = o.length), o[u - 1] === ":" && u--;
    var h = o.slice(0, u);
    o = o.slice(u), this.parseHost(h), this.hostname = this.hostname || "";
    var m = this.hostname[0] === "[" && this.hostname[this.hostname.length - 1] === "]";
    if (!m) {
      var v = this.hostname.split(/\./);
      for (t = 0, r = v.length; t < r; t++) {
        var R = v[t];
        if (R && !R.match(Et)) {
          for (var A = "", w = 0, S = R.length; w < S; w++)
            R.charCodeAt(w) > 127 ? A += "x" : A += R[w];
          if (!A.match(Et)) {
            var N = v.slice(0, t), O = v.slice(t + 1), C = R.match(TF);
            C && (N.push(C[1]), O.unshift(C[2])), O.length && (o = O.join(".") + o), this.hostname = N.join(".");
            break;
          }
        }
      }
    }
    this.hostname.length > RF && (this.hostname = ""), m && (this.hostname = this.hostname.substr(1, this.hostname.length - 2));
  }
  var P = o.indexOf("#");
  P !== -1 && (this.hash = o.substr(P), o = o.slice(0, P));
  var K = o.indexOf("?");
  return K !== -1 && (this.search = o.substr(K), o = o.slice(0, K)), o && (this.pathname = o), At[s] && this.hostname && !this.pathname && (this.pathname = ""), this;
};
sn.prototype.parseHost = function(n) {
  var e = wF.exec(n);
  e && (e = e[0], e !== ":" && (this.port = e.substr(1)), n = n.substr(0, n.length - e.length)), n && (this.hostname = n);
};
var NF = MF;
Ie.encode = vF;
Ie.decode = kF;
Ie.format = yF;
Ie.parse = NF;
var Ee = {}, Nn, Ct;
function Dr() {
  return Ct || (Ct = 1, Nn = /[\0-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/), Nn;
}
var qn, St;
function Rr() {
  return St || (St = 1, qn = /[\0-\x1F\x7F-\x9F]/), qn;
}
var Ln, Dt;
function qF() {
  return Dt || (Dt = 1, Ln = /[\xAD\u0600-\u0605\u061C\u06DD\u070F\u08E2\u180E\u200B-\u200F\u202A-\u202E\u2060-\u2064\u2066-\u206F\uFEFF\uFFF9-\uFFFB]|\uD804[\uDCBD\uDCCD]|\uD82F[\uDCA0-\uDCA3]|\uD834[\uDD73-\uDD7A]|\uDB40[\uDC01\uDC20-\uDC7F]/), Ln;
}
var On, Rt;
function Tr() {
  return Rt || (Rt = 1, On = /[ \xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000]/), On;
}
var Tt;
function LF() {
  return Tt || (Tt = 1, Ee.Any = Dr(), Ee.Cc = Rr(), Ee.Cf = qF(), Ee.P = nt, Ee.Z = Tr()), Ee;
}
(function(n) {
  function e(k) {
    return Object.prototype.toString.call(k);
  }
  function t(k) {
    return e(k) === "[object String]";
  }
  var r = Object.prototype.hasOwnProperty;
  function s(k, j) {
    return r.call(k, j);
  }
  function c(k) {
    var j = Array.prototype.slice.call(arguments, 1);
    return j.forEach(function(f) {
      if (f) {
        if (typeof f != "object")
          throw new TypeError(f + "must be object");
        Object.keys(f).forEach(function(b) {
          k[b] = f[b];
        });
      }
    }), k;
  }
  function i(k, j, f) {
    return [].concat(k.slice(0, j), f, k.slice(j + 1));
  }
  function o(k) {
    return !(k >= 55296 && k <= 57343 || k >= 64976 && k <= 65007 || (k & 65535) === 65535 || (k & 65535) === 65534 || k >= 0 && k <= 8 || k === 11 || k >= 14 && k <= 31 || k >= 127 && k <= 159 || k > 1114111);
  }
  function a(k) {
    if (k > 65535) {
      k -= 65536;
      var j = 55296 + (k >> 10), f = 56320 + (k & 1023);
      return String.fromCharCode(j, f);
    }
    return String.fromCharCode(k);
  }
  var l = /\\([!"#$%&'()*+,\-.\/:;<=>?@[\\\]^_`{|}~])/g, u = /&([a-z#][a-z0-9]{1,31});/gi, d = new RegExp(l.source + "|" + u.source, "gi"), p = /^#((?:x[a-f0-9]{1,8}|[0-9]{1,8}))/i, h = on;
  function m(k, j) {
    var f = 0;
    return s(h, j) ? h[j] : j.charCodeAt(0) === 35 && p.test(j) && (f = j[1].toLowerCase() === "x" ? parseInt(j.slice(2), 16) : parseInt(j.slice(1), 10), o(f)) ? a(f) : k;
  }
  function v(k) {
    return k.indexOf("\\") < 0 ? k : k.replace(l, "$1");
  }
  function R(k) {
    return k.indexOf("\\") < 0 && k.indexOf("&") < 0 ? k : k.replace(d, function(j, f, b) {
      return f || m(j, b);
    });
  }
  var A = /[&<>"]/, w = /[&<>"]/g, S = {
    "&": "&amp;",
    "<": "&lt;",
    ">": "&gt;",
    '"': "&quot;"
  };
  function N(k) {
    return S[k];
  }
  function O(k) {
    return A.test(k) ? k.replace(w, N) : k;
  }
  var C = /[.?*+^$[\]\\(){}|-]/g;
  function P(k) {
    return k.replace(C, "\\$&");
  }
  function K(k) {
    switch (k) {
      case 9:
      case 32:
        return !0;
    }
    return !1;
  }
  function V(k) {
    if (k >= 8192 && k <= 8202)
      return !0;
    switch (k) {
      case 9:
      case 10:
      case 11:
      case 12:
      case 13:
      case 32:
      case 160:
      case 5760:
      case 8239:
      case 8287:
      case 12288:
        return !0;
    }
    return !1;
  }
  var B = nt;
  function U(k) {
    return B.test(k);
  }
  function ce(k) {
    switch (k) {
      case 33:
      case 34:
      case 35:
      case 36:
      case 37:
      case 38:
      case 39:
      case 40:
      case 41:
      case 42:
      case 43:
      case 44:
      case 45:
      case 46:
      case 47:
      case 58:
      case 59:
      case 60:
      case 61:
      case 62:
      case 63:
      case 64:
      case 91:
      case 92:
      case 93:
      case 94:
      case 95:
      case 96:
      case 123:
      case 124:
      case 125:
      case 126:
        return !0;
      default:
        return !1;
    }
  }
  function re(k) {
    return k = k.trim().replace(/\s+/g, " "), "ẞ".toLowerCase() === "Ṿ" && (k = k.replace(/ẞ/g, "ß")), k.toLowerCase().toUpperCase();
  }
  n.lib = {}, n.lib.mdurl = Ie, n.lib.ucmicro = LF(), n.assign = c, n.isString = t, n.has = s, n.unescapeMd = v, n.unescapeAll = R, n.isValidEntityCode = o, n.fromCodePoint = a, n.escapeHtml = O, n.arrayReplaceAt = i, n.isSpace = K, n.isWhiteSpace = V, n.isMdAsciiPunct = ce, n.isPunctChar = U, n.escapeRE = P, n.normalizeReference = re;
})(H);
var bn = {}, OF = function(e, t, r) {
  var s, c, i, o, a = -1, l = e.posMax, u = e.pos;
  for (e.pos = t + 1, s = 1; e.pos < l; ) {
    if (i = e.src.charCodeAt(e.pos), i === 93 && (s--, s === 0)) {
      c = !0;
      break;
    }
    if (o = e.pos, e.md.inline.skipToken(e), i === 91) {
      if (o === e.pos - 1)
        s++;
      else if (r)
        return e.pos = u, -1;
    }
  }
  return c && (a = e.pos), e.pos = u, a;
}, Mt = H.unescapeAll, IF = function(e, t, r) {
  var s, c, i = 0, o = t, a = {
    ok: !1,
    pos: 0,
    lines: 0,
    str: ""
  };
  if (e.charCodeAt(t) === 60) {
    for (t++; t < r; ) {
      if (s = e.charCodeAt(t), s === 10 || s === 60)
        return a;
      if (s === 62)
        return a.pos = t + 1, a.str = Mt(e.slice(o + 1, t)), a.ok = !0, a;
      if (s === 92 && t + 1 < r) {
        t += 2;
        continue;
      }
      t++;
    }
    return a;
  }
  for (c = 0; t < r && (s = e.charCodeAt(t), !(s === 32 || s < 32 || s === 127)); ) {
    if (s === 92 && t + 1 < r) {
      if (e.charCodeAt(t + 1) === 32)
        break;
      t += 2;
      continue;
    }
    if (s === 40 && (c++, c > 32))
      return a;
    if (s === 41) {
      if (c === 0)
        break;
      c--;
    }
    t++;
  }
  return o === t || c !== 0 || (a.str = Mt(e.slice(o, t)), a.lines = i, a.pos = t, a.ok = !0), a;
}, BF = H.unescapeAll, FF = function(e, t, r) {
  var s, c, i = 0, o = t, a = {
    ok: !1,
    pos: 0,
    lines: 0,
    str: ""
  };
  if (t >= r || (c = e.charCodeAt(t), c !== 34 && c !== 39 && c !== 40))
    return a;
  for (t++, c === 40 && (c = 41); t < r; ) {
    if (s = e.charCodeAt(t), s === c)
      return a.pos = t + 1, a.lines = i, a.str = BF(e.slice(o + 1, t)), a.ok = !0, a;
    if (s === 40 && c === 41)
      return a;
    s === 10 ? i++ : s === 92 && t + 1 < r && (t++, e.charCodeAt(t) === 10 && i++), t++;
  }
  return a;
};
bn.parseLinkLabel = OF;
bn.parseLinkDestination = IF;
bn.parseLinkTitle = FF;
var $F = H.assign, PF = H.unescapeAll, De = H.escapeHtml, ue = {};
ue.code_inline = function(n, e, t, r, s) {
  var c = n[e];
  return "<code" + s.renderAttrs(c) + ">" + De(n[e].content) + "</code>";
};
ue.code_block = function(n, e, t, r, s) {
  var c = n[e];
  return "<pre" + s.renderAttrs(c) + "><code>" + De(n[e].content) + `</code></pre>
`;
};
ue.fence = function(n, e, t, r, s) {
  var c = n[e], i = c.info ? PF(c.info).trim() : "", o = "", a = "", l, u, d, p, h;
  return i && (d = i.split(/(\s+)/g), o = d[0], a = d.slice(2).join("")), t.highlight ? l = t.highlight(c.content, o, a) || De(c.content) : l = De(c.content), l.indexOf("<pre") === 0 ? l + `
` : i ? (u = c.attrIndex("class"), p = c.attrs ? c.attrs.slice() : [], u < 0 ? p.push(["class", t.langPrefix + o]) : (p[u] = p[u].slice(), p[u][1] += " " + t.langPrefix + o), h = {
    attrs: p
  }, "<pre><code" + s.renderAttrs(h) + ">" + l + `</code></pre>
`) : "<pre><code" + s.renderAttrs(c) + ">" + l + `</code></pre>
`;
};
ue.image = function(n, e, t, r, s) {
  var c = n[e];
  return c.attrs[c.attrIndex("alt")][1] = s.renderInlineAsText(c.children, t, r), s.renderToken(n, e, t);
};
ue.hardbreak = function(n, e, t) {
  return t.xhtmlOut ? `<br />
` : `<br>
`;
};
ue.softbreak = function(n, e, t) {
  return t.breaks ? t.xhtmlOut ? `<br />
` : `<br>
` : `
`;
};
ue.text = function(n, e) {
  return De(n[e].content);
};
ue.html_block = function(n, e) {
  return n[e].content;
};
ue.html_inline = function(n, e) {
  return n[e].content;
};
function Be() {
  this.rules = $F({}, ue);
}
Be.prototype.renderAttrs = function(e) {
  var t, r, s;
  if (!e.attrs)
    return "";
  for (s = "", t = 0, r = e.attrs.length; t < r; t++)
    s += " " + De(e.attrs[t][0]) + '="' + De(e.attrs[t][1]) + '"';
  return s;
};
Be.prototype.renderToken = function(e, t, r) {
  var s, c = "", i = !1, o = e[t];
  return o.hidden ? "" : (o.block && o.nesting !== -1 && t && e[t - 1].hidden && (c += `
`), c += (o.nesting === -1 ? "</" : "<") + o.tag, c += this.renderAttrs(o), o.nesting === 0 && r.xhtmlOut && (c += " /"), o.block && (i = !0, o.nesting === 1 && t + 1 < e.length && (s = e[t + 1], (s.type === "inline" || s.hidden || s.nesting === -1 && s.tag === o.tag) && (i = !1))), c += i ? `>
` : ">", c);
};
Be.prototype.renderInline = function(n, e, t) {
  for (var r, s = "", c = this.rules, i = 0, o = n.length; i < o; i++)
    r = n[i].type, typeof c[r] < "u" ? s += c[r](n, i, e, t, this) : s += this.renderToken(n, i, e);
  return s;
};
Be.prototype.renderInlineAsText = function(n, e, t) {
  for (var r = "", s = 0, c = n.length; s < c; s++)
    n[s].type === "text" ? r += n[s].content : n[s].type === "image" ? r += this.renderInlineAsText(n[s].children, e, t) : n[s].type === "softbreak" && (r += `
`);
  return r;
};
Be.prototype.render = function(n, e, t) {
  var r, s, c, i = "", o = this.rules;
  for (r = 0, s = n.length; r < s; r++)
    c = n[r].type, c === "inline" ? i += this.renderInline(n[r].children, e, t) : typeof o[c] < "u" ? i += o[n[r].type](n, r, e, t, this) : i += this.renderToken(n, r, e, t);
  return i;
};
var zF = Be;
function le() {
  this.__rules__ = [], this.__cache__ = null;
}
le.prototype.__find__ = function(n) {
  for (var e = 0; e < this.__rules__.length; e++)
    if (this.__rules__[e].name === n)
      return e;
  return -1;
};
le.prototype.__compile__ = function() {
  var n = this, e = [""];
  n.__rules__.forEach(function(t) {
    t.enabled && t.alt.forEach(function(r) {
      e.indexOf(r) < 0 && e.push(r);
    });
  }), n.__cache__ = {}, e.forEach(function(t) {
    n.__cache__[t] = [], n.__rules__.forEach(function(r) {
      r.enabled && (t && r.alt.indexOf(t) < 0 || n.__cache__[t].push(r.fn));
    });
  });
};
le.prototype.at = function(n, e, t) {
  var r = this.__find__(n), s = t || {};
  if (r === -1)
    throw new Error("Parser rule not found: " + n);
  this.__rules__[r].fn = e, this.__rules__[r].alt = s.alt || [], this.__cache__ = null;
};
le.prototype.before = function(n, e, t, r) {
  var s = this.__find__(n), c = r || {};
  if (s === -1)
    throw new Error("Parser rule not found: " + n);
  this.__rules__.splice(s, 0, {
    name: e,
    enabled: !0,
    fn: t,
    alt: c.alt || []
  }), this.__cache__ = null;
};
le.prototype.after = function(n, e, t, r) {
  var s = this.__find__(n), c = r || {};
  if (s === -1)
    throw new Error("Parser rule not found: " + n);
  this.__rules__.splice(s + 1, 0, {
    name: e,
    enabled: !0,
    fn: t,
    alt: c.alt || []
  }), this.__cache__ = null;
};
le.prototype.push = function(n, e, t) {
  var r = t || {};
  this.__rules__.push({
    name: n,
    enabled: !0,
    fn: e,
    alt: r.alt || []
  }), this.__cache__ = null;
};
le.prototype.enable = function(n, e) {
  Array.isArray(n) || (n = [n]);
  var t = [];
  return n.forEach(function(r) {
    var s = this.__find__(r);
    if (s < 0) {
      if (e)
        return;
      throw new Error("Rules manager: invalid rule name " + r);
    }
    this.__rules__[s].enabled = !0, t.push(r);
  }, this), this.__cache__ = null, t;
};
le.prototype.enableOnly = function(n, e) {
  Array.isArray(n) || (n = [n]), this.__rules__.forEach(function(t) {
    t.enabled = !1;
  }), this.enable(n, e);
};
le.prototype.disable = function(n, e) {
  Array.isArray(n) || (n = [n]);
  var t = [];
  return n.forEach(function(r) {
    var s = this.__find__(r);
    if (s < 0) {
      if (e)
        return;
      throw new Error("Rules manager: invalid rule name " + r);
    }
    this.__rules__[s].enabled = !1, t.push(r);
  }, this), this.__cache__ = null, t;
};
le.prototype.getRules = function(n) {
  return this.__cache__ === null && this.__compile__(), this.__cache__[n] || [];
};
var tt = le, HF = /\r\n?|\n/g, UF = /\0/g, jF = function(e) {
  var t;
  t = e.src.replace(HF, `
`), t = t.replace(UF, "�"), e.src = t;
}, GF = function(e) {
  var t;
  e.inlineMode ? (t = new e.Token("inline", "", 0), t.content = e.src, t.map = [0, 1], t.children = [], e.tokens.push(t)) : e.md.block.parse(e.src, e.md, e.env, e.tokens);
}, VF = function(e) {
  var t = e.tokens, r, s, c;
  for (s = 0, c = t.length; s < c; s++)
    r = t[s], r.type === "inline" && e.md.inline.parse(r.content, e.md, e.env, r.children);
}, ZF = H.arrayReplaceAt;
function KF(n) {
  return /^<a[>\s]/i.test(n);
}
function WF(n) {
  return /^<\/a\s*>/i.test(n);
}
var YF = function(e) {
  var t, r, s, c, i, o, a, l, u, d, p, h, m, v, R, A, w = e.tokens, S;
  if (e.md.options.linkify) {
    for (r = 0, s = w.length; r < s; r++)
      if (!(w[r].type !== "inline" || !e.md.linkify.pretest(w[r].content)))
        for (c = w[r].children, m = 0, t = c.length - 1; t >= 0; t--) {
          if (o = c[t], o.type === "link_close") {
            for (t--; c[t].level !== o.level && c[t].type !== "link_open"; )
              t--;
            continue;
          }
          if (o.type === "html_inline" && (KF(o.content) && m > 0 && m--, WF(o.content) && m++), !(m > 0) && o.type === "text" && e.md.linkify.test(o.content)) {
            for (u = o.content, S = e.md.linkify.match(u), a = [], h = o.level, p = 0, S.length > 0 && S[0].index === 0 && t > 0 && c[t - 1].type === "text_special" && (S = S.slice(1)), l = 0; l < S.length; l++)
              v = S[l].url, R = e.md.normalizeLink(v), e.md.validateLink(R) && (A = S[l].text, S[l].schema ? S[l].schema === "mailto:" && !/^mailto:/i.test(A) ? A = e.md.normalizeLinkText("mailto:" + A).replace(/^mailto:/, "") : A = e.md.normalizeLinkText(A) : A = e.md.normalizeLinkText("http://" + A).replace(/^http:\/\//, ""), d = S[l].index, d > p && (i = new e.Token("text", "", 0), i.content = u.slice(p, d), i.level = h, a.push(i)), i = new e.Token("link_open", "a", 1), i.attrs = [["href", R]], i.level = h++, i.markup = "linkify", i.info = "auto", a.push(i), i = new e.Token("text", "", 0), i.content = A, i.level = h, a.push(i), i = new e.Token("link_close", "a", -1), i.level = --h, i.markup = "linkify", i.info = "auto", a.push(i), p = S[l].lastIndex);
            p < u.length && (i = new e.Token("text", "", 0), i.content = u.slice(p), i.level = h, a.push(i)), w[r].children = c = ZF(c, t, a);
          }
        }
  }
}, Mr = /\+-|\.\.|\?\?\?\?|!!!!|,,|--/, JF = /\((c|tm|r)\)/i, XF = /\((c|tm|r)\)/ig, QF = {
  c: "©",
  r: "®",
  tm: "™"
};
function e$(n, e) {
  return QF[e.toLowerCase()];
}
function n$(n) {
  var e, t, r = 0;
  for (e = n.length - 1; e >= 0; e--)
    t = n[e], t.type === "text" && !r && (t.content = t.content.replace(XF, e$)), t.type === "link_open" && t.info === "auto" && r--, t.type === "link_close" && t.info === "auto" && r++;
}
function t$(n) {
  var e, t, r = 0;
  for (e = n.length - 1; e >= 0; e--)
    t = n[e], t.type === "text" && !r && Mr.test(t.content) && (t.content = t.content.replace(/\+-/g, "±").replace(/\.{2,}/g, "…").replace(/([?!])…/g, "$1..").replace(/([?!]){4,}/g, "$1$1$1").replace(/,{2,}/g, ",").replace(/(^|[^-])---(?=[^-]|$)/mg, "$1—").replace(/(^|\s)--(?=\s|$)/mg, "$1–").replace(/(^|[^-\s])--(?=[^-\s]|$)/mg, "$1–")), t.type === "link_open" && t.info === "auto" && r--, t.type === "link_close" && t.info === "auto" && r++;
}
var r$ = function(e) {
  var t;
  if (e.md.options.typographer)
    for (t = e.tokens.length - 1; t >= 0; t--)
      e.tokens[t].type === "inline" && (JF.test(e.tokens[t].content) && n$(e.tokens[t].children), Mr.test(e.tokens[t].content) && t$(e.tokens[t].children));
}, Nt = H.isWhiteSpace, qt = H.isPunctChar, Lt = H.isMdAsciiPunct, o$ = /['"]/, Ot = /['"]/g, It = "’";
function Xe(n, e, t) {
  return n.slice(0, e) + t + n.slice(e + 1);
}
function s$(n, e) {
  var t, r, s, c, i, o, a, l, u, d, p, h, m, v, R, A, w, S, N, O, C;
  for (N = [], t = 0; t < n.length; t++) {
    for (r = n[t], a = n[t].level, w = N.length - 1; w >= 0 && !(N[w].level <= a); w--)
      ;
    if (N.length = w + 1, r.type !== "text")
      continue;
    s = r.content, i = 0, o = s.length;
    e:
      for (; i < o && (Ot.lastIndex = i, c = Ot.exec(s), !!c); ) {
        if (R = A = !0, i = c.index + 1, S = c[0] === "'", u = 32, c.index - 1 >= 0)
          u = s.charCodeAt(c.index - 1);
        else
          for (w = t - 1; w >= 0 && !(n[w].type === "softbreak" || n[w].type === "hardbreak"); w--)
            if (n[w].content) {
              u = n[w].content.charCodeAt(n[w].content.length - 1);
              break;
            }
        if (d = 32, i < o)
          d = s.charCodeAt(i);
        else
          for (w = t + 1; w < n.length && !(n[w].type === "softbreak" || n[w].type === "hardbreak"); w++)
            if (n[w].content) {
              d = n[w].content.charCodeAt(0);
              break;
            }
        if (p = Lt(u) || qt(String.fromCharCode(u)), h = Lt(d) || qt(String.fromCharCode(d)), m = Nt(u), v = Nt(d), v ? R = !1 : h && (m || p || (R = !1)), m ? A = !1 : p && (v || h || (A = !1)), d === 34 && c[0] === '"' && u >= 48 && u <= 57 && (A = R = !1), R && A && (R = p, A = h), !R && !A) {
          S && (r.content = Xe(r.content, c.index, It));
          continue;
        }
        if (A) {
          for (w = N.length - 1; w >= 0 && (l = N[w], !(N[w].level < a)); w--)
            if (l.single === S && N[w].level === a) {
              l = N[w], S ? (O = e.md.options.quotes[2], C = e.md.options.quotes[3]) : (O = e.md.options.quotes[0], C = e.md.options.quotes[1]), r.content = Xe(r.content, c.index, C), n[l.token].content = Xe(
                n[l.token].content,
                l.pos,
                O
              ), i += C.length - 1, l.token === t && (i += O.length - 1), s = r.content, o = s.length, N.length = w;
              continue e;
            }
        }
        R ? N.push({
          token: t,
          pos: c.index,
          single: S,
          level: a
        }) : A && S && (r.content = Xe(r.content, c.index, It));
      }
  }
}
var c$ = function(e) {
  var t;
  if (e.md.options.typographer)
    for (t = e.tokens.length - 1; t >= 0; t--)
      e.tokens[t].type !== "inline" || !o$.test(e.tokens[t].content) || s$(e.tokens[t].children, e);
}, i$ = function(e) {
  var t, r, s, c, i, o, a = e.tokens;
  for (t = 0, r = a.length; t < r; t++)
    if (a[t].type === "inline") {
      for (s = a[t].children, i = s.length, c = 0; c < i; c++)
        s[c].type === "text_special" && (s[c].type = "text");
      for (c = o = 0; c < i; c++)
        s[c].type === "text" && c + 1 < i && s[c + 1].type === "text" ? s[c + 1].content = s[c].content + s[c + 1].content : (c !== o && (s[o] = s[c]), o++);
      c !== o && (s.length = o);
    }
};
function Fe(n, e, t) {
  this.type = n, this.tag = e, this.attrs = null, this.map = null, this.nesting = t, this.level = 0, this.children = null, this.content = "", this.markup = "", this.info = "", this.meta = null, this.block = !1, this.hidden = !1;
}
Fe.prototype.attrIndex = function(e) {
  var t, r, s;
  if (!this.attrs)
    return -1;
  for (t = this.attrs, r = 0, s = t.length; r < s; r++)
    if (t[r][0] === e)
      return r;
  return -1;
};
Fe.prototype.attrPush = function(e) {
  this.attrs ? this.attrs.push(e) : this.attrs = [e];
};
Fe.prototype.attrSet = function(e, t) {
  var r = this.attrIndex(e), s = [e, t];
  r < 0 ? this.attrPush(s) : this.attrs[r] = s;
};
Fe.prototype.attrGet = function(e) {
  var t = this.attrIndex(e), r = null;
  return t >= 0 && (r = this.attrs[t][1]), r;
};
Fe.prototype.attrJoin = function(e, t) {
  var r = this.attrIndex(e);
  r < 0 ? this.attrPush([e, t]) : this.attrs[r][1] = this.attrs[r][1] + " " + t;
};
var rt = Fe, a$ = rt;
function Nr(n, e, t) {
  this.src = n, this.env = t, this.tokens = [], this.inlineMode = !1, this.md = e;
}
Nr.prototype.Token = a$;
var l$ = Nr, u$ = tt, In = [
  ["normalize", jF],
  ["block", GF],
  ["inline", VF],
  ["linkify", YF],
  ["replacements", r$],
  ["smartquotes", c$],
  // `text_join` finds `text_special` tokens (for escape sequences)
  // and joins them with the rest of the text
  ["text_join", i$]
];
function ot() {
  this.ruler = new u$();
  for (var n = 0; n < In.length; n++)
    this.ruler.push(In[n][0], In[n][1]);
}
ot.prototype.process = function(n) {
  var e, t, r;
  for (r = this.ruler.getRules(""), e = 0, t = r.length; e < t; e++)
    r[e](n);
};
ot.prototype.State = l$;
var f$ = ot, Bn = H.isSpace;
function Fn(n, e) {
  var t = n.bMarks[e] + n.tShift[e], r = n.eMarks[e];
  return n.src.slice(t, r);
}
function Bt(n) {
  var e = [], t = 0, r = n.length, s, c = !1, i = 0, o = "";
  for (s = n.charCodeAt(t); t < r; )
    s === 124 && (c ? (o += n.substring(i, t - 1), i = t) : (e.push(o + n.substring(i, t)), o = "", i = t + 1)), c = s === 92, t++, s = n.charCodeAt(t);
  return e.push(o + n.substring(i)), e;
}
var p$ = function(e, t, r, s) {
  var c, i, o, a, l, u, d, p, h, m, v, R, A, w, S, N, O, C;
  if (t + 2 > r || (u = t + 1, e.sCount[u] < e.blkIndent) || e.sCount[u] - e.blkIndent >= 4 || (o = e.bMarks[u] + e.tShift[u], o >= e.eMarks[u]) || (O = e.src.charCodeAt(o++), O !== 124 && O !== 45 && O !== 58) || o >= e.eMarks[u] || (C = e.src.charCodeAt(o++), C !== 124 && C !== 45 && C !== 58 && !Bn(C)) || O === 45 && Bn(C))
    return !1;
  for (; o < e.eMarks[u]; ) {
    if (c = e.src.charCodeAt(o), c !== 124 && c !== 45 && c !== 58 && !Bn(c))
      return !1;
    o++;
  }
  for (i = Fn(e, t + 1), d = i.split("|"), m = [], a = 0; a < d.length; a++) {
    if (v = d[a].trim(), !v) {
      if (a === 0 || a === d.length - 1)
        continue;
      return !1;
    }
    if (!/^:?-+:?$/.test(v))
      return !1;
    v.charCodeAt(v.length - 1) === 58 ? m.push(v.charCodeAt(0) === 58 ? "center" : "right") : v.charCodeAt(0) === 58 ? m.push("left") : m.push("");
  }
  if (i = Fn(e, t).trim(), i.indexOf("|") === -1 || e.sCount[t] - e.blkIndent >= 4 || (d = Bt(i), d.length && d[0] === "" && d.shift(), d.length && d[d.length - 1] === "" && d.pop(), p = d.length, p === 0 || p !== m.length))
    return !1;
  if (s)
    return !0;
  for (w = e.parentType, e.parentType = "table", N = e.md.block.ruler.getRules("blockquote"), h = e.push("table_open", "table", 1), h.map = R = [t, 0], h = e.push("thead_open", "thead", 1), h.map = [t, t + 1], h = e.push("tr_open", "tr", 1), h.map = [t, t + 1], a = 0; a < d.length; a++)
    h = e.push("th_open", "th", 1), m[a] && (h.attrs = [["style", "text-align:" + m[a]]]), h = e.push("inline", "", 0), h.content = d[a].trim(), h.children = [], h = e.push("th_close", "th", -1);
  for (h = e.push("tr_close", "tr", -1), h = e.push("thead_close", "thead", -1), u = t + 2; u < r && !(e.sCount[u] < e.blkIndent); u++) {
    for (S = !1, a = 0, l = N.length; a < l; a++)
      if (N[a](e, u, r, !0)) {
        S = !0;
        break;
      }
    if (S || (i = Fn(e, u).trim(), !i) || e.sCount[u] - e.blkIndent >= 4)
      break;
    for (d = Bt(i), d.length && d[0] === "" && d.shift(), d.length && d[d.length - 1] === "" && d.pop(), u === t + 2 && (h = e.push("tbody_open", "tbody", 1), h.map = A = [t + 2, 0]), h = e.push("tr_open", "tr", 1), h.map = [u, u + 1], a = 0; a < p; a++)
      h = e.push("td_open", "td", 1), m[a] && (h.attrs = [["style", "text-align:" + m[a]]]), h = e.push("inline", "", 0), h.content = d[a] ? d[a].trim() : "", h.children = [], h = e.push("td_close", "td", -1);
    h = e.push("tr_close", "tr", -1);
  }
  return A && (h = e.push("tbody_close", "tbody", -1), A[1] = u), h = e.push("table_close", "table", -1), R[1] = u, e.parentType = w, e.line = u, !0;
}, h$ = function(e, t, r) {
  var s, c, i;
  if (e.sCount[t] - e.blkIndent < 4)
    return !1;
  for (c = s = t + 1; s < r; ) {
    if (e.isEmpty(s)) {
      s++;
      continue;
    }
    if (e.sCount[s] - e.blkIndent >= 4) {
      s++, c = s;
      continue;
    }
    break;
  }
  return e.line = c, i = e.push("code_block", "code", 0), i.content = e.getLines(t, c, 4 + e.blkIndent, !1) + `
`, i.map = [t, e.line], !0;
}, d$ = function(e, t, r, s) {
  var c, i, o, a, l, u, d, p = !1, h = e.bMarks[t] + e.tShift[t], m = e.eMarks[t];
  if (e.sCount[t] - e.blkIndent >= 4 || h + 3 > m || (c = e.src.charCodeAt(h), c !== 126 && c !== 96) || (l = h, h = e.skipChars(h, c), i = h - l, i < 3) || (d = e.src.slice(l, h), o = e.src.slice(h, m), c === 96 && o.indexOf(String.fromCharCode(c)) >= 0))
    return !1;
  if (s)
    return !0;
  for (a = t; a++, !(a >= r || (h = l = e.bMarks[a] + e.tShift[a], m = e.eMarks[a], h < m && e.sCount[a] < e.blkIndent)); )
    if (e.src.charCodeAt(h) === c && !(e.sCount[a] - e.blkIndent >= 4) && (h = e.skipChars(h, c), !(h - l < i) && (h = e.skipSpaces(h), !(h < m)))) {
      p = !0;
      break;
    }
  return i = e.sCount[t], e.line = a + (p ? 1 : 0), u = e.push("fence", "code", 0), u.info = o, u.content = e.getLines(t + 1, a, i, !0), u.markup = d, u.map = [t, e.line], !0;
}, Ft = H.isSpace, g$ = function(e, t, r, s) {
  var c, i, o, a, l, u, d, p, h, m, v, R, A, w, S, N, O, C, P, K, V = e.lineMax, B = e.bMarks[t] + e.tShift[t], U = e.eMarks[t];
  if (e.sCount[t] - e.blkIndent >= 4 || e.src.charCodeAt(B++) !== 62)
    return !1;
  if (s)
    return !0;
  for (a = h = e.sCount[t] + 1, e.src.charCodeAt(B) === 32 ? (B++, a++, h++, c = !1, N = !0) : e.src.charCodeAt(B) === 9 ? (N = !0, (e.bsCount[t] + h) % 4 === 3 ? (B++, a++, h++, c = !1) : c = !0) : N = !1, m = [e.bMarks[t]], e.bMarks[t] = B; B < U && (i = e.src.charCodeAt(B), Ft(i)); ) {
    i === 9 ? h += 4 - (h + e.bsCount[t] + (c ? 1 : 0)) % 4 : h++;
    B++;
  }
  for (v = [e.bsCount[t]], e.bsCount[t] = e.sCount[t] + 1 + (N ? 1 : 0), u = B >= U, w = [e.sCount[t]], e.sCount[t] = h - a, S = [e.tShift[t]], e.tShift[t] = B - e.bMarks[t], C = e.md.block.ruler.getRules("blockquote"), A = e.parentType, e.parentType = "blockquote", p = t + 1; p < r && (K = e.sCount[p] < e.blkIndent, B = e.bMarks[p] + e.tShift[p], U = e.eMarks[p], !(B >= U)); p++) {
    if (e.src.charCodeAt(B++) === 62 && !K) {
      for (a = h = e.sCount[p] + 1, e.src.charCodeAt(B) === 32 ? (B++, a++, h++, c = !1, N = !0) : e.src.charCodeAt(B) === 9 ? (N = !0, (e.bsCount[p] + h) % 4 === 3 ? (B++, a++, h++, c = !1) : c = !0) : N = !1, m.push(e.bMarks[p]), e.bMarks[p] = B; B < U && (i = e.src.charCodeAt(B), Ft(i)); ) {
        i === 9 ? h += 4 - (h + e.bsCount[p] + (c ? 1 : 0)) % 4 : h++;
        B++;
      }
      u = B >= U, v.push(e.bsCount[p]), e.bsCount[p] = e.sCount[p] + 1 + (N ? 1 : 0), w.push(e.sCount[p]), e.sCount[p] = h - a, S.push(e.tShift[p]), e.tShift[p] = B - e.bMarks[p];
      continue;
    }
    if (u)
      break;
    for (O = !1, o = 0, l = C.length; o < l; o++)
      if (C[o](e, p, r, !0)) {
        O = !0;
        break;
      }
    if (O) {
      e.lineMax = p, e.blkIndent !== 0 && (m.push(e.bMarks[p]), v.push(e.bsCount[p]), S.push(e.tShift[p]), w.push(e.sCount[p]), e.sCount[p] -= e.blkIndent);
      break;
    }
    m.push(e.bMarks[p]), v.push(e.bsCount[p]), S.push(e.tShift[p]), w.push(e.sCount[p]), e.sCount[p] = -1;
  }
  for (R = e.blkIndent, e.blkIndent = 0, P = e.push("blockquote_open", "blockquote", 1), P.markup = ">", P.map = d = [t, 0], e.md.block.tokenize(e, t, p), P = e.push("blockquote_close", "blockquote", -1), P.markup = ">", e.lineMax = V, e.parentType = A, d[1] = e.line, o = 0; o < S.length; o++)
    e.bMarks[o + t] = m[o], e.tShift[o + t] = S[o], e.sCount[o + t] = w[o], e.bsCount[o + t] = v[o];
  return e.blkIndent = R, !0;
}, b$ = H.isSpace, _$ = function(e, t, r, s) {
  var c, i, o, a, l = e.bMarks[t] + e.tShift[t], u = e.eMarks[t];
  if (e.sCount[t] - e.blkIndent >= 4 || (c = e.src.charCodeAt(l++), c !== 42 && c !== 45 && c !== 95))
    return !1;
  for (i = 1; l < u; ) {
    if (o = e.src.charCodeAt(l++), o !== c && !b$(o))
      return !1;
    o === c && i++;
  }
  return i < 3 ? !1 : (s || (e.line = t + 1, a = e.push("hr", "hr", 0), a.map = [t, e.line], a.markup = Array(i + 1).join(String.fromCharCode(c))), !0);
}, qr = H.isSpace;
function $t(n, e) {
  var t, r, s, c;
  return r = n.bMarks[e] + n.tShift[e], s = n.eMarks[e], t = n.src.charCodeAt(r++), t !== 42 && t !== 45 && t !== 43 || r < s && (c = n.src.charCodeAt(r), !qr(c)) ? -1 : r;
}
function Pt(n, e) {
  var t, r = n.bMarks[e] + n.tShift[e], s = r, c = n.eMarks[e];
  if (s + 1 >= c || (t = n.src.charCodeAt(s++), t < 48 || t > 57))
    return -1;
  for (; ; ) {
    if (s >= c)
      return -1;
    if (t = n.src.charCodeAt(s++), t >= 48 && t <= 57) {
      if (s - r >= 10)
        return -1;
      continue;
    }
    if (t === 41 || t === 46)
      break;
    return -1;
  }
  return s < c && (t = n.src.charCodeAt(s), !qr(t)) ? -1 : s;
}
function m$(n, e) {
  var t, r, s = n.level + 2;
  for (t = e + 2, r = n.tokens.length - 2; t < r; t++)
    n.tokens[t].level === s && n.tokens[t].type === "paragraph_open" && (n.tokens[t + 2].hidden = !0, n.tokens[t].hidden = !0, t += 2);
}
var v$ = function(e, t, r, s) {
  var c, i, o, a, l, u, d, p, h, m, v, R, A, w, S, N, O, C, P, K, V, B, U, ce, re, k, j, f, b = !1, y = !0;
  if (e.sCount[t] - e.blkIndent >= 4 || e.listIndent >= 0 && e.sCount[t] - e.listIndent >= 4 && e.sCount[t] < e.blkIndent)
    return !1;
  if (s && e.parentType === "paragraph" && e.sCount[t] >= e.blkIndent && (b = !0), (U = Pt(e, t)) >= 0) {
    if (d = !0, re = e.bMarks[t] + e.tShift[t], A = Number(e.src.slice(re, U - 1)), b && A !== 1)
      return !1;
  } else if ((U = $t(e, t)) >= 0)
    d = !1;
  else
    return !1;
  if (b && e.skipSpaces(U) >= e.eMarks[t])
    return !1;
  if (R = e.src.charCodeAt(U - 1), s)
    return !0;
  for (v = e.tokens.length, d ? (f = e.push("ordered_list_open", "ol", 1), A !== 1 && (f.attrs = [["start", A]])) : f = e.push("bullet_list_open", "ul", 1), f.map = m = [t, 0], f.markup = String.fromCharCode(R), S = t, ce = !1, j = e.md.block.ruler.getRules("list"), C = e.parentType, e.parentType = "list"; S < r; ) {
    for (B = U, w = e.eMarks[S], u = N = e.sCount[S] + U - (e.bMarks[t] + e.tShift[t]); B < w; ) {
      if (c = e.src.charCodeAt(B), c === 9)
        N += 4 - (N + e.bsCount[S]) % 4;
      else if (c === 32)
        N++;
      else
        break;
      B++;
    }
    if (i = B, i >= w ? l = 1 : l = N - u, l > 4 && (l = 1), a = u + l, f = e.push("list_item_open", "li", 1), f.markup = String.fromCharCode(R), f.map = p = [t, 0], d && (f.info = e.src.slice(re, U - 1)), V = e.tight, K = e.tShift[t], P = e.sCount[t], O = e.listIndent, e.listIndent = e.blkIndent, e.blkIndent = a, e.tight = !0, e.tShift[t] = i - e.bMarks[t], e.sCount[t] = N, i >= w && e.isEmpty(t + 1) ? e.line = Math.min(e.line + 2, r) : e.md.block.tokenize(e, t, r, !0), (!e.tight || ce) && (y = !1), ce = e.line - t > 1 && e.isEmpty(e.line - 1), e.blkIndent = e.listIndent, e.listIndent = O, e.tShift[t] = K, e.sCount[t] = P, e.tight = V, f = e.push("list_item_close", "li", -1), f.markup = String.fromCharCode(R), S = t = e.line, p[1] = S, i = e.bMarks[t], S >= r || e.sCount[S] < e.blkIndent || e.sCount[t] - e.blkIndent >= 4)
      break;
    for (k = !1, o = 0, h = j.length; o < h; o++)
      if (j[o](e, S, r, !0)) {
        k = !0;
        break;
      }
    if (k)
      break;
    if (d) {
      if (U = Pt(e, S), U < 0)
        break;
      re = e.bMarks[S] + e.tShift[S];
    } else if (U = $t(e, S), U < 0)
      break;
    if (R !== e.src.charCodeAt(U - 1))
      break;
  }
  return d ? f = e.push("ordered_list_close", "ol", -1) : f = e.push("bullet_list_close", "ul", -1), f.markup = String.fromCharCode(R), m[1] = S, e.line = S, e.parentType = C, y && m$(e, v), !0;
}, x$ = H.normalizeReference, Qe = H.isSpace, k$ = function(e, t, r, s) {
  var c, i, o, a, l, u, d, p, h, m, v, R, A, w, S, N, O = 0, C = e.bMarks[t] + e.tShift[t], P = e.eMarks[t], K = t + 1;
  if (e.sCount[t] - e.blkIndent >= 4 || e.src.charCodeAt(C) !== 91)
    return !1;
  for (; ++C < P; )
    if (e.src.charCodeAt(C) === 93 && e.src.charCodeAt(C - 1) !== 92) {
      if (C + 1 === P || e.src.charCodeAt(C + 1) !== 58)
        return !1;
      break;
    }
  for (a = e.lineMax, S = e.md.block.ruler.getRules("reference"), m = e.parentType, e.parentType = "reference"; K < a && !e.isEmpty(K); K++)
    if (!(e.sCount[K] - e.blkIndent > 3) && !(e.sCount[K] < 0)) {
      for (w = !1, u = 0, d = S.length; u < d; u++)
        if (S[u](e, K, a, !0)) {
          w = !0;
          break;
        }
      if (w)
        break;
    }
  for (A = e.getLines(t, K, e.blkIndent, !1).trim(), P = A.length, C = 1; C < P; C++) {
    if (c = A.charCodeAt(C), c === 91)
      return !1;
    if (c === 93) {
      h = C;
      break;
    } else
      c === 10 ? O++ : c === 92 && (C++, C < P && A.charCodeAt(C) === 10 && O++);
  }
  if (h < 0 || A.charCodeAt(h + 1) !== 58)
    return !1;
  for (C = h + 2; C < P; C++)
    if (c = A.charCodeAt(C), c === 10)
      O++;
    else if (!Qe(c))
      break;
  if (v = e.md.helpers.parseLinkDestination(A, C, P), !v.ok || (l = e.md.normalizeLink(v.str), !e.md.validateLink(l)))
    return !1;
  for (C = v.pos, O += v.lines, i = C, o = O, R = C; C < P; C++)
    if (c = A.charCodeAt(C), c === 10)
      O++;
    else if (!Qe(c))
      break;
  for (v = e.md.helpers.parseLinkTitle(A, C, P), C < P && R !== C && v.ok ? (N = v.str, C = v.pos, O += v.lines) : (N = "", C = i, O = o); C < P && (c = A.charCodeAt(C), !!Qe(c)); )
    C++;
  if (C < P && A.charCodeAt(C) !== 10 && N)
    for (N = "", C = i, O = o; C < P && (c = A.charCodeAt(C), !!Qe(c)); )
      C++;
  return C < P && A.charCodeAt(C) !== 10 || (p = x$(A.slice(1, h)), !p) ? !1 : (s || (typeof e.env.references > "u" && (e.env.references = {}), typeof e.env.references[p] > "u" && (e.env.references[p] = { title: N, href: l }), e.parentType = m, e.line = t + O + 1), !0);
}, y$ = [
  "address",
  "article",
  "aside",
  "base",
  "basefont",
  "blockquote",
  "body",
  "caption",
  "center",
  "col",
  "colgroup",
  "dd",
  "details",
  "dialog",
  "dir",
  "div",
  "dl",
  "dt",
  "fieldset",
  "figcaption",
  "figure",
  "footer",
  "form",
  "frame",
  "frameset",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "head",
  "header",
  "hr",
  "html",
  "iframe",
  "legend",
  "li",
  "link",
  "main",
  "menu",
  "menuitem",
  "nav",
  "noframes",
  "ol",
  "optgroup",
  "option",
  "p",
  "param",
  "section",
  "source",
  "summary",
  "table",
  "tbody",
  "td",
  "tfoot",
  "th",
  "thead",
  "title",
  "tr",
  "track",
  "ul"
], _n = {}, E$ = "[a-zA-Z_:][a-zA-Z0-9:._-]*", w$ = "[^\"'=<>`\\x00-\\x20]+", A$ = "'[^']*'", C$ = '"[^"]*"', S$ = "(?:" + w$ + "|" + A$ + "|" + C$ + ")", D$ = "(?:\\s+" + E$ + "(?:\\s*=\\s*" + S$ + ")?)", Lr = "<[A-Za-z][A-Za-z0-9\\-]*" + D$ + "*\\s*\\/?>", Or = "<\\/[A-Za-z][A-Za-z0-9\\-]*\\s*>", R$ = "<!---->|<!--(?:-?[^>-])(?:-?[^-])*-->", T$ = "<[?][\\s\\S]*?[?]>", M$ = "<![A-Z]+\\s+[^>]*>", N$ = "<!\\[CDATA\\[[\\s\\S]*?\\]\\]>", q$ = new RegExp("^(?:" + Lr + "|" + Or + "|" + R$ + "|" + T$ + "|" + M$ + "|" + N$ + ")"), L$ = new RegExp("^(?:" + Lr + "|" + Or + ")");
_n.HTML_TAG_RE = q$;
_n.HTML_OPEN_CLOSE_TAG_RE = L$;
var O$ = y$, I$ = _n.HTML_OPEN_CLOSE_TAG_RE, Ne = [
  [/^<(script|pre|style|textarea)(?=(\s|>|$))/i, /<\/(script|pre|style|textarea)>/i, !0],
  [/^<!--/, /-->/, !0],
  [/^<\?/, /\?>/, !0],
  [/^<![A-Z]/, />/, !0],
  [/^<!\[CDATA\[/, /\]\]>/, !0],
  [new RegExp("^</?(" + O$.join("|") + ")(?=(\\s|/?>|$))", "i"), /^$/, !0],
  [new RegExp(I$.source + "\\s*$"), /^$/, !1]
], B$ = function(e, t, r, s) {
  var c, i, o, a, l = e.bMarks[t] + e.tShift[t], u = e.eMarks[t];
  if (e.sCount[t] - e.blkIndent >= 4 || !e.md.options.html || e.src.charCodeAt(l) !== 60)
    return !1;
  for (a = e.src.slice(l, u), c = 0; c < Ne.length && !Ne[c][0].test(a); c++)
    ;
  if (c === Ne.length)
    return !1;
  if (s)
    return Ne[c][2];
  if (i = t + 1, !Ne[c][1].test(a)) {
    for (; i < r && !(e.sCount[i] < e.blkIndent); i++)
      if (l = e.bMarks[i] + e.tShift[i], u = e.eMarks[i], a = e.src.slice(l, u), Ne[c][1].test(a)) {
        a.length !== 0 && i++;
        break;
      }
  }
  return e.line = i, o = e.push("html_block", "", 0), o.map = [t, i], o.content = e.getLines(t, i, e.blkIndent, !0), !0;
}, zt = H.isSpace, F$ = function(e, t, r, s) {
  var c, i, o, a, l = e.bMarks[t] + e.tShift[t], u = e.eMarks[t];
  if (e.sCount[t] - e.blkIndent >= 4 || (c = e.src.charCodeAt(l), c !== 35 || l >= u))
    return !1;
  for (i = 1, c = e.src.charCodeAt(++l); c === 35 && l < u && i <= 6; )
    i++, c = e.src.charCodeAt(++l);
  return i > 6 || l < u && !zt(c) ? !1 : (s || (u = e.skipSpacesBack(u, l), o = e.skipCharsBack(u, 35, l), o > l && zt(e.src.charCodeAt(o - 1)) && (u = o), e.line = t + 1, a = e.push("heading_open", "h" + String(i), 1), a.markup = "########".slice(0, i), a.map = [t, e.line], a = e.push("inline", "", 0), a.content = e.src.slice(l, u).trim(), a.map = [t, e.line], a.children = [], a = e.push("heading_close", "h" + String(i), -1), a.markup = "########".slice(0, i)), !0);
}, $$ = function(e, t, r) {
  var s, c, i, o, a, l, u, d, p, h = t + 1, m, v = e.md.block.ruler.getRules("paragraph");
  if (e.sCount[t] - e.blkIndent >= 4)
    return !1;
  for (m = e.parentType, e.parentType = "paragraph"; h < r && !e.isEmpty(h); h++)
    if (!(e.sCount[h] - e.blkIndent > 3)) {
      if (e.sCount[h] >= e.blkIndent && (l = e.bMarks[h] + e.tShift[h], u = e.eMarks[h], l < u && (p = e.src.charCodeAt(l), (p === 45 || p === 61) && (l = e.skipChars(l, p), l = e.skipSpaces(l), l >= u)))) {
        d = p === 61 ? 1 : 2;
        break;
      }
      if (!(e.sCount[h] < 0)) {
        for (c = !1, i = 0, o = v.length; i < o; i++)
          if (v[i](e, h, r, !0)) {
            c = !0;
            break;
          }
        if (c)
          break;
      }
    }
  return d ? (s = e.getLines(t, h, e.blkIndent, !1).trim(), e.line = h + 1, a = e.push("heading_open", "h" + String(d), 1), a.markup = String.fromCharCode(p), a.map = [t, e.line], a = e.push("inline", "", 0), a.content = s, a.map = [t, e.line - 1], a.children = [], a = e.push("heading_close", "h" + String(d), -1), a.markup = String.fromCharCode(p), e.parentType = m, !0) : !1;
}, P$ = function(e, t) {
  var r, s, c, i, o, a, l = t + 1, u = e.md.block.ruler.getRules("paragraph"), d = e.lineMax;
  for (a = e.parentType, e.parentType = "paragraph"; l < d && !e.isEmpty(l); l++)
    if (!(e.sCount[l] - e.blkIndent > 3) && !(e.sCount[l] < 0)) {
      for (s = !1, c = 0, i = u.length; c < i; c++)
        if (u[c](e, l, d, !0)) {
          s = !0;
          break;
        }
      if (s)
        break;
    }
  return r = e.getLines(t, l, e.blkIndent, !1).trim(), e.line = l, o = e.push("paragraph_open", "p", 1), o.map = [t, e.line], o = e.push("inline", "", 0), o.content = r, o.map = [t, e.line], o.children = [], o = e.push("paragraph_close", "p", -1), e.parentType = a, !0;
}, Ir = rt, mn = H.isSpace;
function fe(n, e, t, r) {
  var s, c, i, o, a, l, u, d;
  for (this.src = n, this.md = e, this.env = t, this.tokens = r, this.bMarks = [], this.eMarks = [], this.tShift = [], this.sCount = [], this.bsCount = [], this.blkIndent = 0, this.line = 0, this.lineMax = 0, this.tight = !1, this.ddIndent = -1, this.listIndent = -1, this.parentType = "root", this.level = 0, this.result = "", c = this.src, d = !1, i = o = l = u = 0, a = c.length; o < a; o++) {
    if (s = c.charCodeAt(o), !d)
      if (mn(s)) {
        l++, s === 9 ? u += 4 - u % 4 : u++;
        continue;
      } else
        d = !0;
    (s === 10 || o === a - 1) && (s !== 10 && o++, this.bMarks.push(i), this.eMarks.push(o), this.tShift.push(l), this.sCount.push(u), this.bsCount.push(0), d = !1, l = 0, u = 0, i = o + 1);
  }
  this.bMarks.push(c.length), this.eMarks.push(c.length), this.tShift.push(0), this.sCount.push(0), this.bsCount.push(0), this.lineMax = this.bMarks.length - 1;
}
fe.prototype.push = function(n, e, t) {
  var r = new Ir(n, e, t);
  return r.block = !0, t < 0 && this.level--, r.level = this.level, t > 0 && this.level++, this.tokens.push(r), r;
};
fe.prototype.isEmpty = function(e) {
  return this.bMarks[e] + this.tShift[e] >= this.eMarks[e];
};
fe.prototype.skipEmptyLines = function(e) {
  for (var t = this.lineMax; e < t && !(this.bMarks[e] + this.tShift[e] < this.eMarks[e]); e++)
    ;
  return e;
};
fe.prototype.skipSpaces = function(e) {
  for (var t, r = this.src.length; e < r && (t = this.src.charCodeAt(e), !!mn(t)); e++)
    ;
  return e;
};
fe.prototype.skipSpacesBack = function(e, t) {
  if (e <= t)
    return e;
  for (; e > t; )
    if (!mn(this.src.charCodeAt(--e)))
      return e + 1;
  return e;
};
fe.prototype.skipChars = function(e, t) {
  for (var r = this.src.length; e < r && this.src.charCodeAt(e) === t; e++)
    ;
  return e;
};
fe.prototype.skipCharsBack = function(e, t, r) {
  if (e <= r)
    return e;
  for (; e > r; )
    if (t !== this.src.charCodeAt(--e))
      return e + 1;
  return e;
};
fe.prototype.getLines = function(e, t, r, s) {
  var c, i, o, a, l, u, d, p = e;
  if (e >= t)
    return "";
  for (u = new Array(t - e), c = 0; p < t; p++, c++) {
    for (i = 0, d = a = this.bMarks[p], p + 1 < t || s ? l = this.eMarks[p] + 1 : l = this.eMarks[p]; a < l && i < r; ) {
      if (o = this.src.charCodeAt(a), mn(o))
        o === 9 ? i += 4 - (i + this.bsCount[p]) % 4 : i++;
      else if (a - d < this.tShift[p])
        i++;
      else
        break;
      a++;
    }
    i > r ? u[c] = new Array(i - r + 1).join(" ") + this.src.slice(a, l) : u[c] = this.src.slice(a, l);
  }
  return u.join("");
};
fe.prototype.Token = Ir;
var z$ = fe, H$ = tt, en = [
  // First 2 params - rule name & source. Secondary array - list of rules,
  // which can be terminated by this one.
  ["table", p$, ["paragraph", "reference"]],
  ["code", h$],
  ["fence", d$, ["paragraph", "reference", "blockquote", "list"]],
  ["blockquote", g$, ["paragraph", "reference", "blockquote", "list"]],
  ["hr", _$, ["paragraph", "reference", "blockquote", "list"]],
  ["list", v$, ["paragraph", "reference", "blockquote"]],
  ["reference", k$],
  ["html_block", B$, ["paragraph", "reference", "blockquote"]],
  ["heading", F$, ["paragraph", "reference", "blockquote"]],
  ["lheading", $$],
  ["paragraph", P$]
];
function vn() {
  this.ruler = new H$();
  for (var n = 0; n < en.length; n++)
    this.ruler.push(en[n][0], en[n][1], { alt: (en[n][2] || []).slice() });
}
vn.prototype.tokenize = function(n, e, t) {
  for (var r, s, c = this.ruler.getRules(""), i = c.length, o = e, a = !1, l = n.md.options.maxNesting; o < t && (n.line = o = n.skipEmptyLines(o), !(o >= t || n.sCount[o] < n.blkIndent)); ) {
    if (n.level >= l) {
      n.line = t;
      break;
    }
    for (s = 0; s < i && (r = c[s](n, o, t, !1), !r); s++)
      ;
    n.tight = !a, n.isEmpty(n.line - 1) && (a = !0), o = n.line, o < t && n.isEmpty(o) && (a = !0, o++, n.line = o);
  }
};
vn.prototype.parse = function(n, e, t, r) {
  var s;
  n && (s = new this.State(n, e, t, r), this.tokenize(s, s.line, s.lineMax));
};
vn.prototype.State = z$;
var U$ = vn;
function j$(n) {
  switch (n) {
    case 10:
    case 33:
    case 35:
    case 36:
    case 37:
    case 38:
    case 42:
    case 43:
    case 45:
    case 58:
    case 60:
    case 61:
    case 62:
    case 64:
    case 91:
    case 92:
    case 93:
    case 94:
    case 95:
    case 96:
    case 123:
    case 125:
    case 126:
      return !0;
    default:
      return !1;
  }
}
var G$ = function(e, t) {
  for (var r = e.pos; r < e.posMax && !j$(e.src.charCodeAt(r)); )
    r++;
  return r === e.pos ? !1 : (t || (e.pending += e.src.slice(e.pos, r)), e.pos = r, !0);
}, V$ = /(?:^|[^a-z0-9.+-])([a-z][a-z0-9.+-]*)$/i, Z$ = function(e, t) {
  var r, s, c, i, o, a, l, u;
  return !e.md.options.linkify || e.linkLevel > 0 || (r = e.pos, s = e.posMax, r + 3 > s) || e.src.charCodeAt(r) !== 58 || e.src.charCodeAt(r + 1) !== 47 || e.src.charCodeAt(r + 2) !== 47 || (c = e.pending.match(V$), !c) || (i = c[1], o = e.md.linkify.matchAtStart(e.src.slice(r - i.length)), !o) || (a = o.url, a = a.replace(/\*+$/, ""), l = e.md.normalizeLink(a), !e.md.validateLink(l)) ? !1 : (t || (e.pending = e.pending.slice(0, -i.length), u = e.push("link_open", "a", 1), u.attrs = [["href", l]], u.markup = "linkify", u.info = "auto", u = e.push("text", "", 0), u.content = e.md.normalizeLinkText(a), u = e.push("link_close", "a", -1), u.markup = "linkify", u.info = "auto"), e.pos += a.length - i.length, !0);
}, K$ = H.isSpace, W$ = function(e, t) {
  var r, s, c, i = e.pos;
  if (e.src.charCodeAt(i) !== 10)
    return !1;
  if (r = e.pending.length - 1, s = e.posMax, !t)
    if (r >= 0 && e.pending.charCodeAt(r) === 32)
      if (r >= 1 && e.pending.charCodeAt(r - 1) === 32) {
        for (c = r - 1; c >= 1 && e.pending.charCodeAt(c - 1) === 32; )
          c--;
        e.pending = e.pending.slice(0, c), e.push("hardbreak", "br", 0);
      } else
        e.pending = e.pending.slice(0, -1), e.push("softbreak", "br", 0);
    else
      e.push("softbreak", "br", 0);
  for (i++; i < s && K$(e.src.charCodeAt(i)); )
    i++;
  return e.pos = i, !0;
}, Y$ = H.isSpace, st = [];
for (var Ht = 0; Ht < 256; Ht++)
  st.push(0);
"\\!\"#$%&'()*+,./:;<=>?@[]^_`{|}~-".split("").forEach(function(n) {
  st[n.charCodeAt(0)] = 1;
});
var J$ = function(e, t) {
  var r, s, c, i, o, a = e.pos, l = e.posMax;
  if (e.src.charCodeAt(a) !== 92 || (a++, a >= l))
    return !1;
  if (r = e.src.charCodeAt(a), r === 10) {
    for (t || e.push("hardbreak", "br", 0), a++; a < l && (r = e.src.charCodeAt(a), !!Y$(r)); )
      a++;
    return e.pos = a, !0;
  }
  return i = e.src[a], r >= 55296 && r <= 56319 && a + 1 < l && (s = e.src.charCodeAt(a + 1), s >= 56320 && s <= 57343 && (i += e.src[a + 1], a++)), c = "\\" + i, t || (o = e.push("text_special", "", 0), r < 256 && st[r] !== 0 ? o.content = i : o.content = c, o.markup = c, o.info = "escape"), e.pos = a + 1, !0;
}, X$ = function(e, t) {
  var r, s, c, i, o, a, l, u, d = e.pos, p = e.src.charCodeAt(d);
  if (p !== 96)
    return !1;
  for (r = d, d++, s = e.posMax; d < s && e.src.charCodeAt(d) === 96; )
    d++;
  if (c = e.src.slice(r, d), l = c.length, e.backticksScanned && (e.backticks[l] || 0) <= r)
    return t || (e.pending += c), e.pos += l, !0;
  for (o = a = d; (o = e.src.indexOf("`", a)) !== -1; ) {
    for (a = o + 1; a < s && e.src.charCodeAt(a) === 96; )
      a++;
    if (u = a - o, u === l)
      return t || (i = e.push("code_inline", "code", 0), i.markup = c, i.content = e.src.slice(d, o).replace(/\n/g, " ").replace(/^ (.+) $/, "$1")), e.pos = a, !0;
    e.backticks[u] = o;
  }
  return e.backticksScanned = !0, t || (e.pending += c), e.pos += l, !0;
}, xn = {};
xn.tokenize = function(e, t) {
  var r, s, c, i, o, a = e.pos, l = e.src.charCodeAt(a);
  if (t || l !== 126 || (s = e.scanDelims(e.pos, !0), i = s.length, o = String.fromCharCode(l), i < 2))
    return !1;
  for (i % 2 && (c = e.push("text", "", 0), c.content = o, i--), r = 0; r < i; r += 2)
    c = e.push("text", "", 0), c.content = o + o, e.delimiters.push({
      marker: l,
      length: 0,
      // disable "rule of 3" length checks meant for emphasis
      token: e.tokens.length - 1,
      end: -1,
      open: s.can_open,
      close: s.can_close
    });
  return e.pos += s.length, !0;
};
function Ut(n, e) {
  var t, r, s, c, i, o = [], a = e.length;
  for (t = 0; t < a; t++)
    s = e[t], s.marker === 126 && s.end !== -1 && (c = e[s.end], i = n.tokens[s.token], i.type = "s_open", i.tag = "s", i.nesting = 1, i.markup = "~~", i.content = "", i = n.tokens[c.token], i.type = "s_close", i.tag = "s", i.nesting = -1, i.markup = "~~", i.content = "", n.tokens[c.token - 1].type === "text" && n.tokens[c.token - 1].content === "~" && o.push(c.token - 1));
  for (; o.length; ) {
    for (t = o.pop(), r = t + 1; r < n.tokens.length && n.tokens[r].type === "s_close"; )
      r++;
    r--, t !== r && (i = n.tokens[r], n.tokens[r] = n.tokens[t], n.tokens[t] = i);
  }
}
xn.postProcess = function(e) {
  var t, r = e.tokens_meta, s = e.tokens_meta.length;
  for (Ut(e, e.delimiters), t = 0; t < s; t++)
    r[t] && r[t].delimiters && Ut(e, r[t].delimiters);
};
var kn = {};
kn.tokenize = function(e, t) {
  var r, s, c, i = e.pos, o = e.src.charCodeAt(i);
  if (t || o !== 95 && o !== 42)
    return !1;
  for (s = e.scanDelims(e.pos, o === 42), r = 0; r < s.length; r++)
    c = e.push("text", "", 0), c.content = String.fromCharCode(o), e.delimiters.push({
      // Char code of the starting marker (number).
      //
      marker: o,
      // Total length of these series of delimiters.
      //
      length: s.length,
      // A position of the token this delimiter corresponds to.
      //
      token: e.tokens.length - 1,
      // If this delimiter is matched as a valid opener, `end` will be
      // equal to its position, otherwise it's `-1`.
      //
      end: -1,
      // Boolean flags that determine if this delimiter could open or close
      // an emphasis.
      //
      open: s.can_open,
      close: s.can_close
    });
  return e.pos += s.length, !0;
};
function jt(n, e) {
  var t, r, s, c, i, o, a = e.length;
  for (t = a - 1; t >= 0; t--)
    r = e[t], !(r.marker !== 95 && r.marker !== 42) && r.end !== -1 && (s = e[r.end], o = t > 0 && e[t - 1].end === r.end + 1 && // check that first two markers match and adjacent
    e[t - 1].marker === r.marker && e[t - 1].token === r.token - 1 && // check that last two markers are adjacent (we can safely assume they match)
    e[r.end + 1].token === s.token + 1, i = String.fromCharCode(r.marker), c = n.tokens[r.token], c.type = o ? "strong_open" : "em_open", c.tag = o ? "strong" : "em", c.nesting = 1, c.markup = o ? i + i : i, c.content = "", c = n.tokens[s.token], c.type = o ? "strong_close" : "em_close", c.tag = o ? "strong" : "em", c.nesting = -1, c.markup = o ? i + i : i, c.content = "", o && (n.tokens[e[t - 1].token].content = "", n.tokens[e[r.end + 1].token].content = "", t--));
}
kn.postProcess = function(e) {
  var t, r = e.tokens_meta, s = e.tokens_meta.length;
  for (jt(e, e.delimiters), t = 0; t < s; t++)
    r[t] && r[t].delimiters && jt(e, r[t].delimiters);
};
var Q$ = H.normalizeReference, $n = H.isSpace, e8 = function(e, t) {
  var r, s, c, i, o, a, l, u, d, p = "", h = "", m = e.pos, v = e.posMax, R = e.pos, A = !0;
  if (e.src.charCodeAt(e.pos) !== 91 || (o = e.pos + 1, i = e.md.helpers.parseLinkLabel(e, e.pos, !0), i < 0))
    return !1;
  if (a = i + 1, a < v && e.src.charCodeAt(a) === 40) {
    for (A = !1, a++; a < v && (s = e.src.charCodeAt(a), !(!$n(s) && s !== 10)); a++)
      ;
    if (a >= v)
      return !1;
    if (R = a, l = e.md.helpers.parseLinkDestination(e.src, a, e.posMax), l.ok) {
      for (p = e.md.normalizeLink(l.str), e.md.validateLink(p) ? a = l.pos : p = "", R = a; a < v && (s = e.src.charCodeAt(a), !(!$n(s) && s !== 10)); a++)
        ;
      if (l = e.md.helpers.parseLinkTitle(e.src, a, e.posMax), a < v && R !== a && l.ok)
        for (h = l.str, a = l.pos; a < v && (s = e.src.charCodeAt(a), !(!$n(s) && s !== 10)); a++)
          ;
    }
    (a >= v || e.src.charCodeAt(a) !== 41) && (A = !0), a++;
  }
  if (A) {
    if (typeof e.env.references > "u")
      return !1;
    if (a < v && e.src.charCodeAt(a) === 91 ? (R = a + 1, a = e.md.helpers.parseLinkLabel(e, a), a >= 0 ? c = e.src.slice(R, a++) : a = i + 1) : a = i + 1, c || (c = e.src.slice(o, i)), u = e.env.references[Q$(c)], !u)
      return e.pos = m, !1;
    p = u.href, h = u.title;
  }
  return t || (e.pos = o, e.posMax = i, d = e.push("link_open", "a", 1), d.attrs = r = [["href", p]], h && r.push(["title", h]), e.linkLevel++, e.md.inline.tokenize(e), e.linkLevel--, d = e.push("link_close", "a", -1)), e.pos = a, e.posMax = v, !0;
}, n8 = H.normalizeReference, Pn = H.isSpace, t8 = function(e, t) {
  var r, s, c, i, o, a, l, u, d, p, h, m, v, R = "", A = e.pos, w = e.posMax;
  if (e.src.charCodeAt(e.pos) !== 33 || e.src.charCodeAt(e.pos + 1) !== 91 || (a = e.pos + 2, o = e.md.helpers.parseLinkLabel(e, e.pos + 1, !1), o < 0))
    return !1;
  if (l = o + 1, l < w && e.src.charCodeAt(l) === 40) {
    for (l++; l < w && (s = e.src.charCodeAt(l), !(!Pn(s) && s !== 10)); l++)
      ;
    if (l >= w)
      return !1;
    for (v = l, d = e.md.helpers.parseLinkDestination(e.src, l, e.posMax), d.ok && (R = e.md.normalizeLink(d.str), e.md.validateLink(R) ? l = d.pos : R = ""), v = l; l < w && (s = e.src.charCodeAt(l), !(!Pn(s) && s !== 10)); l++)
      ;
    if (d = e.md.helpers.parseLinkTitle(e.src, l, e.posMax), l < w && v !== l && d.ok)
      for (p = d.str, l = d.pos; l < w && (s = e.src.charCodeAt(l), !(!Pn(s) && s !== 10)); l++)
        ;
    else
      p = "";
    if (l >= w || e.src.charCodeAt(l) !== 41)
      return e.pos = A, !1;
    l++;
  } else {
    if (typeof e.env.references > "u")
      return !1;
    if (l < w && e.src.charCodeAt(l) === 91 ? (v = l + 1, l = e.md.helpers.parseLinkLabel(e, l), l >= 0 ? i = e.src.slice(v, l++) : l = o + 1) : l = o + 1, i || (i = e.src.slice(a, o)), u = e.env.references[n8(i)], !u)
      return e.pos = A, !1;
    R = u.href, p = u.title;
  }
  return t || (c = e.src.slice(a, o), e.md.inline.parse(
    c,
    e.md,
    e.env,
    m = []
  ), h = e.push("image", "img", 0), h.attrs = r = [["src", R], ["alt", ""]], h.children = m, h.content = c, p && r.push(["title", p])), e.pos = l, e.posMax = w, !0;
}, r8 = /^([a-zA-Z0-9.!#$%&'*+\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*)$/, o8 = /^([a-zA-Z][a-zA-Z0-9+.\-]{1,31}):([^<>\x00-\x20]*)$/, s8 = function(e, t) {
  var r, s, c, i, o, a, l = e.pos;
  if (e.src.charCodeAt(l) !== 60)
    return !1;
  for (o = e.pos, a = e.posMax; ; ) {
    if (++l >= a || (i = e.src.charCodeAt(l), i === 60))
      return !1;
    if (i === 62)
      break;
  }
  return r = e.src.slice(o + 1, l), o8.test(r) ? (s = e.md.normalizeLink(r), e.md.validateLink(s) ? (t || (c = e.push("link_open", "a", 1), c.attrs = [["href", s]], c.markup = "autolink", c.info = "auto", c = e.push("text", "", 0), c.content = e.md.normalizeLinkText(r), c = e.push("link_close", "a", -1), c.markup = "autolink", c.info = "auto"), e.pos += r.length + 2, !0) : !1) : r8.test(r) ? (s = e.md.normalizeLink("mailto:" + r), e.md.validateLink(s) ? (t || (c = e.push("link_open", "a", 1), c.attrs = [["href", s]], c.markup = "autolink", c.info = "auto", c = e.push("text", "", 0), c.content = e.md.normalizeLinkText(r), c = e.push("link_close", "a", -1), c.markup = "autolink", c.info = "auto"), e.pos += r.length + 2, !0) : !1) : !1;
}, c8 = _n.HTML_TAG_RE;
function i8(n) {
  return /^<a[>\s]/i.test(n);
}
function a8(n) {
  return /^<\/a\s*>/i.test(n);
}
function l8(n) {
  var e = n | 32;
  return e >= 97 && e <= 122;
}
var u8 = function(e, t) {
  var r, s, c, i, o = e.pos;
  return !e.md.options.html || (c = e.posMax, e.src.charCodeAt(o) !== 60 || o + 2 >= c) || (r = e.src.charCodeAt(o + 1), r !== 33 && r !== 63 && r !== 47 && !l8(r)) || (s = e.src.slice(o).match(c8), !s) ? !1 : (t || (i = e.push("html_inline", "", 0), i.content = e.src.slice(o, o + s[0].length), i8(i.content) && e.linkLevel++, a8(i.content) && e.linkLevel--), e.pos += s[0].length, !0);
}, Gt = on, f8 = H.has, p8 = H.isValidEntityCode, Vt = H.fromCodePoint, h8 = /^&#((?:x[a-f0-9]{1,6}|[0-9]{1,7}));/i, d8 = /^&([a-z][a-z0-9]{1,31});/i, g8 = function(e, t) {
  var r, s, c, i, o = e.pos, a = e.posMax;
  if (e.src.charCodeAt(o) !== 38 || o + 1 >= a)
    return !1;
  if (r = e.src.charCodeAt(o + 1), r === 35) {
    if (c = e.src.slice(o).match(h8), c)
      return t || (s = c[1][0].toLowerCase() === "x" ? parseInt(c[1].slice(1), 16) : parseInt(c[1], 10), i = e.push("text_special", "", 0), i.content = p8(s) ? Vt(s) : Vt(65533), i.markup = c[0], i.info = "entity"), e.pos += c[0].length, !0;
  } else if (c = e.src.slice(o).match(d8), c && f8(Gt, c[1]))
    return t || (i = e.push("text_special", "", 0), i.content = Gt[c[1]], i.markup = c[0], i.info = "entity"), e.pos += c[0].length, !0;
  return !1;
};
function Zt(n, e) {
  var t, r, s, c, i, o, a, l, u = {}, d = e.length;
  if (d) {
    var p = 0, h = -2, m = [];
    for (t = 0; t < d; t++)
      if (s = e[t], m.push(0), (e[p].marker !== s.marker || h !== s.token - 1) && (p = t), h = s.token, s.length = s.length || 0, !!s.close) {
        for (u.hasOwnProperty(s.marker) || (u[s.marker] = [-1, -1, -1, -1, -1, -1]), i = u[s.marker][(s.open ? 3 : 0) + s.length % 3], r = p - m[p] - 1, o = r; r > i; r -= m[r] + 1)
          if (c = e[r], c.marker === s.marker && c.open && c.end < 0 && (a = !1, (c.close || s.open) && (c.length + s.length) % 3 === 0 && (c.length % 3 !== 0 || s.length % 3 !== 0) && (a = !0), !a)) {
            l = r > 0 && !e[r - 1].open ? m[r - 1] + 1 : 0, m[t] = t - r + l, m[r] = l, s.open = !1, c.end = t, c.close = !1, o = -1, h = -2;
            break;
          }
        o !== -1 && (u[s.marker][(s.open ? 3 : 0) + (s.length || 0) % 3] = o);
      }
  }
}
var b8 = function(e) {
  var t, r = e.tokens_meta, s = e.tokens_meta.length;
  for (Zt(e, e.delimiters), t = 0; t < s; t++)
    r[t] && r[t].delimiters && Zt(e, r[t].delimiters);
}, _8 = function(e) {
  var t, r, s = 0, c = e.tokens, i = e.tokens.length;
  for (t = r = 0; t < i; t++)
    c[t].nesting < 0 && s--, c[t].level = s, c[t].nesting > 0 && s++, c[t].type === "text" && t + 1 < i && c[t + 1].type === "text" ? c[t + 1].content = c[t].content + c[t + 1].content : (t !== r && (c[r] = c[t]), r++);
  t !== r && (c.length = r);
}, ct = rt, Kt = H.isWhiteSpace, Wt = H.isPunctChar, Yt = H.isMdAsciiPunct;
function Ye(n, e, t, r) {
  this.src = n, this.env = t, this.md = e, this.tokens = r, this.tokens_meta = Array(r.length), this.pos = 0, this.posMax = this.src.length, this.level = 0, this.pending = "", this.pendingLevel = 0, this.cache = {}, this.delimiters = [], this._prev_delimiters = [], this.backticks = {}, this.backticksScanned = !1, this.linkLevel = 0;
}
Ye.prototype.pushPending = function() {
  var n = new ct("text", "", 0);
  return n.content = this.pending, n.level = this.pendingLevel, this.tokens.push(n), this.pending = "", n;
};
Ye.prototype.push = function(n, e, t) {
  this.pending && this.pushPending();
  var r = new ct(n, e, t), s = null;
  return t < 0 && (this.level--, this.delimiters = this._prev_delimiters.pop()), r.level = this.level, t > 0 && (this.level++, this._prev_delimiters.push(this.delimiters), this.delimiters = [], s = { delimiters: this.delimiters }), this.pendingLevel = this.level, this.tokens.push(r), this.tokens_meta.push(s), r;
};
Ye.prototype.scanDelims = function(n, e) {
  var t = n, r, s, c, i, o, a, l, u, d, p = !0, h = !0, m = this.posMax, v = this.src.charCodeAt(n);
  for (r = n > 0 ? this.src.charCodeAt(n - 1) : 32; t < m && this.src.charCodeAt(t) === v; )
    t++;
  return c = t - n, s = t < m ? this.src.charCodeAt(t) : 32, l = Yt(r) || Wt(String.fromCharCode(r)), d = Yt(s) || Wt(String.fromCharCode(s)), a = Kt(r), u = Kt(s), u ? p = !1 : d && (a || l || (p = !1)), a ? h = !1 : l && (u || d || (h = !1)), e ? (i = p, o = h) : (i = p && (!h || l), o = h && (!p || d)), {
    can_open: i,
    can_close: o,
    length: c
  };
};
Ye.prototype.Token = ct;
var m8 = Ye, Jt = tt, zn = [
  ["text", G$],
  ["linkify", Z$],
  ["newline", W$],
  ["escape", J$],
  ["backticks", X$],
  ["strikethrough", xn.tokenize],
  ["emphasis", kn.tokenize],
  ["link", e8],
  ["image", t8],
  ["autolink", s8],
  ["html_inline", u8],
  ["entity", g8]
], Hn = [
  ["balance_pairs", b8],
  ["strikethrough", xn.postProcess],
  ["emphasis", kn.postProcess],
  // rules for pairs separate '**' into its own text tokens, which may be left unused,
  // rule below merges unused segments back with the rest of the text
  ["fragments_join", _8]
];
function Je() {
  var n;
  for (this.ruler = new Jt(), n = 0; n < zn.length; n++)
    this.ruler.push(zn[n][0], zn[n][1]);
  for (this.ruler2 = new Jt(), n = 0; n < Hn.length; n++)
    this.ruler2.push(Hn[n][0], Hn[n][1]);
}
Je.prototype.skipToken = function(n) {
  var e, t, r = n.pos, s = this.ruler.getRules(""), c = s.length, i = n.md.options.maxNesting, o = n.cache;
  if (typeof o[r] < "u") {
    n.pos = o[r];
    return;
  }
  if (n.level < i)
    for (t = 0; t < c && (n.level++, e = s[t](n, !0), n.level--, !e); t++)
      ;
  else
    n.pos = n.posMax;
  e || n.pos++, o[r] = n.pos;
};
Je.prototype.tokenize = function(n) {
  for (var e, t, r = this.ruler.getRules(""), s = r.length, c = n.posMax, i = n.md.options.maxNesting; n.pos < c; ) {
    if (n.level < i)
      for (t = 0; t < s && (e = r[t](n, !1), !e); t++)
        ;
    if (e) {
      if (n.pos >= c)
        break;
      continue;
    }
    n.pending += n.src[n.pos++];
  }
  n.pending && n.pushPending();
};
Je.prototype.parse = function(n, e, t, r) {
  var s, c, i, o = new this.State(n, e, t, r);
  for (this.tokenize(o), c = this.ruler2.getRules(""), i = c.length, s = 0; s < i; s++)
    c[s](o);
};
Je.prototype.State = m8;
var v8 = Je, Un, Xt;
function x8() {
  return Xt || (Xt = 1, Un = function(n) {
    var e = {};
    n = n || {}, e.src_Any = Dr().source, e.src_Cc = Rr().source, e.src_Z = Tr().source, e.src_P = nt.source, e.src_ZPCc = [e.src_Z, e.src_P, e.src_Cc].join("|"), e.src_ZCc = [e.src_Z, e.src_Cc].join("|");
    var t = "[><｜]";
    return e.src_pseudo_letter = "(?:(?!" + t + "|" + e.src_ZPCc + ")" + e.src_Any + ")", e.src_ip4 = "(?:(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)", e.src_auth = "(?:(?:(?!" + e.src_ZCc + "|[@/\\[\\]()]).)+@)?", e.src_port = "(?::(?:6(?:[0-4]\\d{3}|5(?:[0-4]\\d{2}|5(?:[0-2]\\d|3[0-5])))|[1-5]?\\d{1,4}))?", e.src_host_terminator = "(?=$|" + t + "|" + e.src_ZPCc + ")(?!" + (n["---"] ? "-(?!--)|" : "-|") + "_|:\\d|\\.-|\\.(?!$|" + e.src_ZPCc + "))", e.src_path = "(?:[/?#](?:(?!" + e.src_ZCc + "|" + t + `|[()[\\]{}.,"'?!\\-;]).|\\[(?:(?!` + e.src_ZCc + "|\\]).)*\\]|\\((?:(?!" + e.src_ZCc + "|[)]).)*\\)|\\{(?:(?!" + e.src_ZCc + '|[}]).)*\\}|\\"(?:(?!' + e.src_ZCc + `|["]).)+\\"|\\'(?:(?!` + e.src_ZCc + "|[']).)+\\'|\\'(?=" + e.src_pseudo_letter + "|[-])|\\.{2,}[a-zA-Z0-9%/&]|\\.(?!" + e.src_ZCc + "|[.]|$)|" + (n["---"] ? "\\-(?!--(?:[^-]|$))(?:-*)|" : "\\-+|") + ",(?!" + e.src_ZCc + "|$)|;(?!" + e.src_ZCc + "|$)|\\!+(?!" + e.src_ZCc + "|[!]|$)|\\?(?!" + e.src_ZCc + "|[?]|$))+|\\/)?", e.src_email_name = '[\\-;:&=\\+\\$,\\.a-zA-Z0-9_][\\-;:&=\\+\\$,\\"\\.a-zA-Z0-9_]*', e.src_xn = "xn--[a-z0-9\\-]{1,59}", e.src_domain_root = // Allow letters & digits (http://test1)
    "(?:" + e.src_xn + "|" + e.src_pseudo_letter + "{1,63})", e.src_domain = "(?:" + e.src_xn + "|(?:" + e.src_pseudo_letter + ")|(?:" + e.src_pseudo_letter + "(?:-|" + e.src_pseudo_letter + "){0,61}" + e.src_pseudo_letter + "))", e.src_host = "(?:(?:(?:(?:" + e.src_domain + ")\\.)*" + e.src_domain + "))", e.tpl_host_fuzzy = "(?:" + e.src_ip4 + "|(?:(?:(?:" + e.src_domain + ")\\.)+(?:%TLDS%)))", e.tpl_host_no_ip_fuzzy = "(?:(?:(?:" + e.src_domain + ")\\.)+(?:%TLDS%))", e.src_host_strict = e.src_host + e.src_host_terminator, e.tpl_host_fuzzy_strict = e.tpl_host_fuzzy + e.src_host_terminator, e.src_host_port_strict = e.src_host + e.src_port + e.src_host_terminator, e.tpl_host_port_fuzzy_strict = e.tpl_host_fuzzy + e.src_port + e.src_host_terminator, e.tpl_host_port_no_ip_fuzzy_strict = e.tpl_host_no_ip_fuzzy + e.src_port + e.src_host_terminator, e.tpl_host_fuzzy_test = "localhost|www\\.|\\.\\d{1,3}\\.|(?:\\.(?:%TLDS%)(?:" + e.src_ZPCc + "|>|$))", e.tpl_email_fuzzy = "(^|" + t + '|"|\\(|' + e.src_ZCc + ")(" + e.src_email_name + "@" + e.tpl_host_fuzzy_strict + ")", e.tpl_link_fuzzy = // Fuzzy link can't be prepended with .:/\- and non punctuation.
    // but can start with > (markdown blockquote)
    "(^|(?![.:/\\-_@])(?:[$+<=>^`|｜]|" + e.src_ZPCc + "))((?![$+<=>^`|｜])" + e.tpl_host_port_fuzzy_strict + e.src_path + ")", e.tpl_link_no_ip_fuzzy = // Fuzzy link can't be prepended with .:/\- and non punctuation.
    // but can start with > (markdown blockquote)
    "(^|(?![.:/\\-_@])(?:[$+<=>^`|｜]|" + e.src_ZPCc + "))((?![$+<=>^`|｜])" + e.tpl_host_port_no_ip_fuzzy_strict + e.src_path + ")", e;
  }), Un;
}
function Wn(n) {
  var e = Array.prototype.slice.call(arguments, 1);
  return e.forEach(function(t) {
    t && Object.keys(t).forEach(function(r) {
      n[r] = t[r];
    });
  }), n;
}
function yn(n) {
  return Object.prototype.toString.call(n);
}
function k8(n) {
  return yn(n) === "[object String]";
}
function y8(n) {
  return yn(n) === "[object Object]";
}
function E8(n) {
  return yn(n) === "[object RegExp]";
}
function Qt(n) {
  return yn(n) === "[object Function]";
}
function w8(n) {
  return n.replace(/[.?*+^$[\]\\(){}|-]/g, "\\$&");
}
var Br = {
  fuzzyLink: !0,
  fuzzyEmail: !0,
  fuzzyIP: !1
};
function A8(n) {
  return Object.keys(n || {}).reduce(function(e, t) {
    return e || Br.hasOwnProperty(t);
  }, !1);
}
var C8 = {
  "http:": {
    validate: function(n, e, t) {
      var r = n.slice(e);
      return t.re.http || (t.re.http = new RegExp(
        "^\\/\\/" + t.re.src_auth + t.re.src_host_port_strict + t.re.src_path,
        "i"
      )), t.re.http.test(r) ? r.match(t.re.http)[0].length : 0;
    }
  },
  "https:": "http:",
  "ftp:": "http:",
  "//": {
    validate: function(n, e, t) {
      var r = n.slice(e);
      return t.re.no_http || (t.re.no_http = new RegExp(
        "^" + t.re.src_auth + // Don't allow single-level domains, because of false positives like '//test'
        // with code comments
        "(?:localhost|(?:(?:" + t.re.src_domain + ")\\.)+" + t.re.src_domain_root + ")" + t.re.src_port + t.re.src_host_terminator + t.re.src_path,
        "i"
      )), t.re.no_http.test(r) ? e >= 3 && n[e - 3] === ":" || e >= 3 && n[e - 3] === "/" ? 0 : r.match(t.re.no_http)[0].length : 0;
    }
  },
  "mailto:": {
    validate: function(n, e, t) {
      var r = n.slice(e);
      return t.re.mailto || (t.re.mailto = new RegExp(
        "^" + t.re.src_email_name + "@" + t.re.src_host_strict,
        "i"
      )), t.re.mailto.test(r) ? r.match(t.re.mailto)[0].length : 0;
    }
  }
}, S8 = "a[cdefgilmnoqrstuwxz]|b[abdefghijmnorstvwyz]|c[acdfghiklmnoruvwxyz]|d[ejkmoz]|e[cegrstu]|f[ijkmor]|g[abdefghilmnpqrstuwy]|h[kmnrtu]|i[delmnoqrst]|j[emop]|k[eghimnprwyz]|l[abcikrstuvy]|m[acdeghklmnopqrstuvwxyz]|n[acefgilopruz]|om|p[aefghklmnrstwy]|qa|r[eosuw]|s[abcdeghijklmnortuvxyz]|t[cdfghjklmnortvwz]|u[agksyz]|v[aceginu]|w[fs]|y[et]|z[amw]", D8 = "biz|com|edu|gov|net|org|pro|web|xxx|aero|asia|coop|info|museum|name|shop|рф".split("|");
function R8(n) {
  n.__index__ = -1, n.__text_cache__ = "";
}
function T8(n) {
  return function(e, t) {
    var r = e.slice(t);
    return n.test(r) ? r.match(n)[0].length : 0;
  };
}
function er() {
  return function(n, e) {
    e.normalize(n);
  };
}
function cn(n) {
  var e = n.re = x8()(n.__opts__), t = n.__tlds__.slice();
  n.onCompile(), n.__tlds_replaced__ || t.push(S8), t.push(e.src_xn), e.src_tlds = t.join("|");
  function r(o) {
    return o.replace("%TLDS%", e.src_tlds);
  }
  e.email_fuzzy = RegExp(r(e.tpl_email_fuzzy), "i"), e.link_fuzzy = RegExp(r(e.tpl_link_fuzzy), "i"), e.link_no_ip_fuzzy = RegExp(r(e.tpl_link_no_ip_fuzzy), "i"), e.host_fuzzy_test = RegExp(r(e.tpl_host_fuzzy_test), "i");
  var s = [];
  n.__compiled__ = {};
  function c(o, a) {
    throw new Error('(LinkifyIt) Invalid schema "' + o + '": ' + a);
  }
  Object.keys(n.__schemas__).forEach(function(o) {
    var a = n.__schemas__[o];
    if (a !== null) {
      var l = { validate: null, link: null };
      if (n.__compiled__[o] = l, y8(a)) {
        E8(a.validate) ? l.validate = T8(a.validate) : Qt(a.validate) ? l.validate = a.validate : c(o, a), Qt(a.normalize) ? l.normalize = a.normalize : a.normalize ? c(o, a) : l.normalize = er();
        return;
      }
      if (k8(a)) {
        s.push(o);
        return;
      }
      c(o, a);
    }
  }), s.forEach(function(o) {
    n.__compiled__[n.__schemas__[o]] && (n.__compiled__[o].validate = n.__compiled__[n.__schemas__[o]].validate, n.__compiled__[o].normalize = n.__compiled__[n.__schemas__[o]].normalize);
  }), n.__compiled__[""] = { validate: null, normalize: er() };
  var i = Object.keys(n.__compiled__).filter(function(o) {
    return o.length > 0 && n.__compiled__[o];
  }).map(w8).join("|");
  n.re.schema_test = RegExp("(^|(?!_)(?:[><｜]|" + e.src_ZPCc + "))(" + i + ")", "i"), n.re.schema_search = RegExp("(^|(?!_)(?:[><｜]|" + e.src_ZPCc + "))(" + i + ")", "ig"), n.re.schema_at_start = RegExp("^" + n.re.schema_search.source, "i"), n.re.pretest = RegExp(
    "(" + n.re.schema_test.source + ")|(" + n.re.host_fuzzy_test.source + ")|@",
    "i"
  ), R8(n);
}
function M8(n, e) {
  var t = n.__index__, r = n.__last_index__, s = n.__text_cache__.slice(t, r);
  this.schema = n.__schema__.toLowerCase(), this.index = t + e, this.lastIndex = r + e, this.raw = s, this.text = s, this.url = s;
}
function Yn(n, e) {
  var t = new M8(n, e);
  return n.__compiled__[t.schema].normalize(t, n), t;
}
function te(n, e) {
  if (!(this instanceof te))
    return new te(n, e);
  e || A8(n) && (e = n, n = {}), this.__opts__ = Wn({}, Br, e), this.__index__ = -1, this.__last_index__ = -1, this.__schema__ = "", this.__text_cache__ = "", this.__schemas__ = Wn({}, C8, n), this.__compiled__ = {}, this.__tlds__ = D8, this.__tlds_replaced__ = !1, this.re = {}, cn(this);
}
te.prototype.add = function(e, t) {
  return this.__schemas__[e] = t, cn(this), this;
};
te.prototype.set = function(e) {
  return this.__opts__ = Wn(this.__opts__, e), this;
};
te.prototype.test = function(e) {
  if (this.__text_cache__ = e, this.__index__ = -1, !e.length)
    return !1;
  var t, r, s, c, i, o, a, l, u;
  if (this.re.schema_test.test(e)) {
    for (a = this.re.schema_search, a.lastIndex = 0; (t = a.exec(e)) !== null; )
      if (c = this.testSchemaAt(e, t[2], a.lastIndex), c) {
        this.__schema__ = t[2], this.__index__ = t.index + t[1].length, this.__last_index__ = t.index + t[0].length + c;
        break;
      }
  }
  return this.__opts__.fuzzyLink && this.__compiled__["http:"] && (l = e.search(this.re.host_fuzzy_test), l >= 0 && (this.__index__ < 0 || l < this.__index__) && (r = e.match(this.__opts__.fuzzyIP ? this.re.link_fuzzy : this.re.link_no_ip_fuzzy)) !== null && (i = r.index + r[1].length, (this.__index__ < 0 || i < this.__index__) && (this.__schema__ = "", this.__index__ = i, this.__last_index__ = r.index + r[0].length))), this.__opts__.fuzzyEmail && this.__compiled__["mailto:"] && (u = e.indexOf("@"), u >= 0 && (s = e.match(this.re.email_fuzzy)) !== null && (i = s.index + s[1].length, o = s.index + s[0].length, (this.__index__ < 0 || i < this.__index__ || i === this.__index__ && o > this.__last_index__) && (this.__schema__ = "mailto:", this.__index__ = i, this.__last_index__ = o))), this.__index__ >= 0;
};
te.prototype.pretest = function(e) {
  return this.re.pretest.test(e);
};
te.prototype.testSchemaAt = function(e, t, r) {
  return this.__compiled__[t.toLowerCase()] ? this.__compiled__[t.toLowerCase()].validate(e, r, this) : 0;
};
te.prototype.match = function(e) {
  var t = 0, r = [];
  this.__index__ >= 0 && this.__text_cache__ === e && (r.push(Yn(this, t)), t = this.__last_index__);
  for (var s = t ? e.slice(t) : e; this.test(s); )
    r.push(Yn(this, t)), s = s.slice(this.__last_index__), t += this.__last_index__;
  return r.length ? r : null;
};
te.prototype.matchAtStart = function(e) {
  if (this.__text_cache__ = e, this.__index__ = -1, !e.length)
    return null;
  var t = this.re.schema_at_start.exec(e);
  if (!t)
    return null;
  var r = this.testSchemaAt(e, t[2], t[0].length);
  return r ? (this.__schema__ = t[2], this.__index__ = t.index + t[1].length, this.__last_index__ = t.index + t[0].length + r, Yn(this, 0)) : null;
};
te.prototype.tlds = function(e, t) {
  return e = Array.isArray(e) ? e : [e], t ? (this.__tlds__ = this.__tlds__.concat(e).sort().filter(function(r, s, c) {
    return r !== c[s - 1];
  }).reverse(), cn(this), this) : (this.__tlds__ = e.slice(), this.__tlds_replaced__ = !0, cn(this), this);
};
te.prototype.normalize = function(e) {
  e.schema || (e.url = "http://" + e.url), e.schema === "mailto:" && !/^mailto:/i.test(e.url) && (e.url = "mailto:" + e.url);
};
te.prototype.onCompile = function() {
};
var N8 = te;
const q8 = {}, L8 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: q8
}, Symbol.toStringTag, { value: "Module" })), O8 = /* @__PURE__ */ Yo(L8);
var I8 = {
  options: {
    html: !1,
    // Enable HTML tags in source
    xhtmlOut: !1,
    // Use '/' to close single tags (<br />)
    breaks: !1,
    // Convert '\n' in paragraphs into <br>
    langPrefix: "language-",
    // CSS language prefix for fenced blocks
    linkify: !1,
    // autoconvert URL-like texts to links
    // Enable some language-neutral replacements + quotes beautification
    typographer: !1,
    // Double + single quotes replacement pairs, when typographer enabled,
    // and smartquotes on. Could be either a String or an Array.
    //
    // For example, you can use '«»„“' for Russian, '„“‚‘' for German,
    // and ['«\xA0', '\xA0»', '‹\xA0', '\xA0›'] for French (including nbsp).
    quotes: "“”‘’",
    /* “”‘’ */
    // Highlighter function. Should return escaped HTML,
    // or '' if the source string is not changed and should be escaped externaly.
    // If result starts with <pre... internal wrapper is skipped.
    //
    // function (/*str, lang*/) { return ''; }
    //
    highlight: null,
    maxNesting: 100
    // Internal protection, recursion limit
  },
  components: {
    core: {},
    block: {},
    inline: {}
  }
}, B8 = {
  options: {
    html: !1,
    // Enable HTML tags in source
    xhtmlOut: !1,
    // Use '/' to close single tags (<br />)
    breaks: !1,
    // Convert '\n' in paragraphs into <br>
    langPrefix: "language-",
    // CSS language prefix for fenced blocks
    linkify: !1,
    // autoconvert URL-like texts to links
    // Enable some language-neutral replacements + quotes beautification
    typographer: !1,
    // Double + single quotes replacement pairs, when typographer enabled,
    // and smartquotes on. Could be either a String or an Array.
    //
    // For example, you can use '«»„“' for Russian, '„“‚‘' for German,
    // and ['«\xA0', '\xA0»', '‹\xA0', '\xA0›'] for French (including nbsp).
    quotes: "“”‘’",
    /* “”‘’ */
    // Highlighter function. Should return escaped HTML,
    // or '' if the source string is not changed and should be escaped externaly.
    // If result starts with <pre... internal wrapper is skipped.
    //
    // function (/*str, lang*/) { return ''; }
    //
    highlight: null,
    maxNesting: 20
    // Internal protection, recursion limit
  },
  components: {
    core: {
      rules: [
        "normalize",
        "block",
        "inline",
        "text_join"
      ]
    },
    block: {
      rules: [
        "paragraph"
      ]
    },
    inline: {
      rules: [
        "text"
      ],
      rules2: [
        "balance_pairs",
        "fragments_join"
      ]
    }
  }
}, F8 = {
  options: {
    html: !0,
    // Enable HTML tags in source
    xhtmlOut: !0,
    // Use '/' to close single tags (<br />)
    breaks: !1,
    // Convert '\n' in paragraphs into <br>
    langPrefix: "language-",
    // CSS language prefix for fenced blocks
    linkify: !1,
    // autoconvert URL-like texts to links
    // Enable some language-neutral replacements + quotes beautification
    typographer: !1,
    // Double + single quotes replacement pairs, when typographer enabled,
    // and smartquotes on. Could be either a String or an Array.
    //
    // For example, you can use '«»„“' for Russian, '„“‚‘' for German,
    // and ['«\xA0', '\xA0»', '‹\xA0', '\xA0›'] for French (including nbsp).
    quotes: "“”‘’",
    /* “”‘’ */
    // Highlighter function. Should return escaped HTML,
    // or '' if the source string is not changed and should be escaped externaly.
    // If result starts with <pre... internal wrapper is skipped.
    //
    // function (/*str, lang*/) { return ''; }
    //
    highlight: null,
    maxNesting: 20
    // Internal protection, recursion limit
  },
  components: {
    core: {
      rules: [
        "normalize",
        "block",
        "inline",
        "text_join"
      ]
    },
    block: {
      rules: [
        "blockquote",
        "code",
        "fence",
        "heading",
        "hr",
        "html_block",
        "lheading",
        "list",
        "reference",
        "paragraph"
      ]
    },
    inline: {
      rules: [
        "autolink",
        "backticks",
        "emphasis",
        "entity",
        "escape",
        "html_inline",
        "image",
        "link",
        "newline",
        "text"
      ],
      rules2: [
        "balance_pairs",
        "emphasis",
        "fragments_join"
      ]
    }
  }
}, Ue = H, $8 = bn, P8 = zF, z8 = f$, H8 = U$, U8 = v8, j8 = N8, Ae = Ie, Fr = O8, G8 = {
  default: I8,
  zero: B8,
  commonmark: F8
}, V8 = /^(vbscript|javascript|file|data):/, Z8 = /^data:image\/(gif|png|jpeg|webp);/;
function K8(n) {
  var e = n.trim().toLowerCase();
  return V8.test(e) ? !!Z8.test(e) : !0;
}
var $r = ["http:", "https:", "mailto:"];
function W8(n) {
  var e = Ae.parse(n, !0);
  if (e.hostname && (!e.protocol || $r.indexOf(e.protocol) >= 0))
    try {
      e.hostname = Fr.toASCII(e.hostname);
    } catch {
    }
  return Ae.encode(Ae.format(e));
}
function Y8(n) {
  var e = Ae.parse(n, !0);
  if (e.hostname && (!e.protocol || $r.indexOf(e.protocol) >= 0))
    try {
      e.hostname = Fr.toUnicode(e.hostname);
    } catch {
    }
  return Ae.decode(Ae.format(e), Ae.decode.defaultChars + "%");
}
function se(n, e) {
  if (!(this instanceof se))
    return new se(n, e);
  e || Ue.isString(n) || (e = n || {}, n = "default"), this.inline = new U8(), this.block = new H8(), this.core = new z8(), this.renderer = new P8(), this.linkify = new j8(), this.validateLink = K8, this.normalizeLink = W8, this.normalizeLinkText = Y8, this.utils = Ue, this.helpers = Ue.assign({}, $8), this.options = {}, this.configure(n), e && this.set(e);
}
se.prototype.set = function(n) {
  return Ue.assign(this.options, n), this;
};
se.prototype.configure = function(n) {
  var e = this, t;
  if (Ue.isString(n) && (t = n, n = G8[t], !n))
    throw new Error('Wrong `markdown-it` preset "' + t + '", check name');
  if (!n)
    throw new Error("Wrong `markdown-it` preset, can't be empty");
  return n.options && e.set(n.options), n.components && Object.keys(n.components).forEach(function(r) {
    n.components[r].rules && e[r].ruler.enableOnly(n.components[r].rules), n.components[r].rules2 && e[r].ruler2.enableOnly(n.components[r].rules2);
  }), this;
};
se.prototype.enable = function(n, e) {
  var t = [];
  Array.isArray(n) || (n = [n]), ["core", "block", "inline"].forEach(function(s) {
    t = t.concat(this[s].ruler.enable(n, !0));
  }, this), t = t.concat(this.inline.ruler2.enable(n, !0));
  var r = n.filter(function(s) {
    return t.indexOf(s) < 0;
  });
  if (r.length && !e)
    throw new Error("MarkdownIt. Failed to enable unknown rule(s): " + r);
  return this;
};
se.prototype.disable = function(n, e) {
  var t = [];
  Array.isArray(n) || (n = [n]), ["core", "block", "inline"].forEach(function(s) {
    t = t.concat(this[s].ruler.disable(n, !0));
  }, this), t = t.concat(this.inline.ruler2.disable(n, !0));
  var r = n.filter(function(s) {
    return t.indexOf(s) < 0;
  });
  if (r.length && !e)
    throw new Error("MarkdownIt. Failed to disable unknown rule(s): " + r);
  return this;
};
se.prototype.use = function(n) {
  var e = [this].concat(Array.prototype.slice.call(arguments, 1));
  return n.apply(n, e), this;
};
se.prototype.parse = function(n, e) {
  if (typeof n != "string")
    throw new Error("Input data should be a String");
  var t = new this.core.State(n, this, e);
  return this.core.process(t), t.tokens;
};
se.prototype.render = function(n, e) {
  return e = e || {}, this.renderer.render(this.parse(n, e), this.options, e);
};
se.prototype.parseInline = function(n, e) {
  var t = new this.core.State(n, this, e);
  return t.inlineMode = !0, this.core.process(t), t.tokens;
};
se.prototype.renderInline = function(n, e) {
  return e = e || {}, this.renderer.render(this.parseInline(n, e), this.options, e);
};
var J8 = se;
(function(n) {
  n.exports = J8;
})(Jo);
const X8 = /* @__PURE__ */ Wo(Kn), Q8 = ["innerHTML"], e4 = /* @__PURE__ */ ae({
  __name: "RenderMd",
  props: {
    source: {
      type: String,
      required: !0
    },
    hljs: {
      type: Object,
      required: !0
    }
  },
  setup(n) {
    const e = n, t = new X8({
      typographer: !0,
      html: !0,
      highlight: function(s, c) {
        if (c && e.hljs.getLanguage(c))
          try {
            return e.hljs.highlight(s, { language: c }).value;
          } catch (i) {
            throw new Error(`Code parse error ${i}`);
          }
        return "";
      }
    }), r = Qn(() => {
      const s = e.source;
      return t == null ? void 0 : t.render(s);
    });
    return (s, c) => (D(), q("div", {
      class: "md-content prosed",
      innerHTML: ne(r)
    }, null, 8, Q8));
  }
});
var it = { exports: {} };
function at(n) {
  return n instanceof Map ? n.clear = n.delete = n.set = function() {
    throw new Error("map is read-only");
  } : n instanceof Set && (n.add = n.clear = n.delete = function() {
    throw new Error("set is read-only");
  }), Object.freeze(n), Object.getOwnPropertyNames(n).forEach(function(e) {
    var t = n[e];
    typeof t == "object" && !Object.isFrozen(t) && at(t);
  }), n;
}
it.exports = at;
it.exports.default = at;
let nr = class {
  /**
   * @param {CompiledMode} mode
   */
  constructor(e) {
    e.data === void 0 && (e.data = {}), this.data = e.data, this.isMatchIgnored = !1;
  }
  ignoreMatch() {
    this.isMatchIgnored = !0;
  }
};
function Pr(n) {
  return n.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#x27;");
}
function me(n, ...e) {
  const t = /* @__PURE__ */ Object.create(null);
  for (const r in n)
    t[r] = n[r];
  return e.forEach(function(r) {
    for (const s in r)
      t[s] = r[s];
  }), /** @type {T} */
  t;
}
const n4 = "</span>", tr = (n) => !!n.scope || n.sublanguage && n.language, t4 = (n, { prefix: e }) => {
  if (n.includes(".")) {
    const t = n.split(".");
    return [
      `${e}${t.shift()}`,
      ...t.map((r, s) => `${r}${"_".repeat(s + 1)}`)
    ].join(" ");
  }
  return `${e}${n}`;
};
let r4 = class {
  /**
   * Creates a new HTMLRenderer
   *
   * @param {Tree} parseTree - the parse tree (must support `walk` API)
   * @param {{classPrefix: string}} options
   */
  constructor(e, t) {
    this.buffer = "", this.classPrefix = t.classPrefix, e.walk(this);
  }
  /**
   * Adds texts to the output stream
   *
   * @param {string} text */
  addText(e) {
    this.buffer += Pr(e);
  }
  /**
   * Adds a node open to the output stream (if needed)
   *
   * @param {Node} node */
  openNode(e) {
    if (!tr(e))
      return;
    let t = "";
    e.sublanguage ? t = `language-${e.language}` : t = t4(e.scope, { prefix: this.classPrefix }), this.span(t);
  }
  /**
   * Adds a node close to the output stream (if needed)
   *
   * @param {Node} node */
  closeNode(e) {
    tr(e) && (this.buffer += n4);
  }
  /**
   * returns the accumulated buffer
  */
  value() {
    return this.buffer;
  }
  // helpers
  /**
   * Builds a span element
   *
   * @param {string} className */
  span(e) {
    this.buffer += `<span class="${e}">`;
  }
};
const rr = (n = {}) => {
  const e = { children: [] };
  return Object.assign(e, n), e;
};
let o4 = class zr {
  constructor() {
    this.rootNode = rr(), this.stack = [this.rootNode];
  }
  get top() {
    return this.stack[this.stack.length - 1];
  }
  get root() {
    return this.rootNode;
  }
  /** @param {Node} node */
  add(e) {
    this.top.children.push(e);
  }
  /** @param {string} scope */
  openNode(e) {
    const t = rr({ scope: e });
    this.add(t), this.stack.push(t);
  }
  closeNode() {
    if (this.stack.length > 1)
      return this.stack.pop();
  }
  closeAllNodes() {
    for (; this.closeNode(); )
      ;
  }
  toJSON() {
    return JSON.stringify(this.rootNode, null, 4);
  }
  /**
   * @typedef { import("./html_renderer").Renderer } Renderer
   * @param {Renderer} builder
   */
  walk(e) {
    return this.constructor._walk(e, this.rootNode);
  }
  /**
   * @param {Renderer} builder
   * @param {Node} node
   */
  static _walk(e, t) {
    return typeof t == "string" ? e.addText(t) : t.children && (e.openNode(t), t.children.forEach((r) => this._walk(e, r)), e.closeNode(t)), e;
  }
  /**
   * @param {Node} node
   */
  static _collapse(e) {
    typeof e != "string" && e.children && (e.children.every((t) => typeof t == "string") ? e.children = [e.children.join("")] : e.children.forEach((t) => {
      zr._collapse(t);
    }));
  }
}, s4 = class extends o4 {
  /**
   * @param {*} options
   */
  constructor(e) {
    super(), this.options = e;
  }
  /**
   * @param {string} text
   * @param {string} scope
   */
  addKeyword(e, t) {
    e !== "" && (this.openNode(t), this.addText(e), this.closeNode());
  }
  /**
   * @param {string} text
   */
  addText(e) {
    e !== "" && this.add(e);
  }
  /**
   * @param {Emitter & {root: DataNode}} emitter
   * @param {string} name
   */
  addSublanguage(e, t) {
    const r = e.root;
    r.sublanguage = !0, r.language = t, this.add(r);
  }
  toHTML() {
    return new r4(this, this.options).value();
  }
  finalize() {
    return !0;
  }
};
function je(n) {
  return n ? typeof n == "string" ? n : n.source : null;
}
function Hr(n) {
  return Re("(?=", n, ")");
}
function c4(n) {
  return Re("(?:", n, ")*");
}
function i4(n) {
  return Re("(?:", n, ")?");
}
function Re(...n) {
  return n.map((t) => je(t)).join("");
}
function a4(n) {
  const e = n[n.length - 1];
  return typeof e == "object" && e.constructor === Object ? (n.splice(n.length - 1, 1), e) : {};
}
function lt(...n) {
  return "(" + (a4(n).capture ? "" : "?:") + n.map((r) => je(r)).join("|") + ")";
}
function Ur(n) {
  return new RegExp(n.toString() + "|").exec("").length - 1;
}
function l4(n, e) {
  const t = n && n.exec(e);
  return t && t.index === 0;
}
const u4 = /\[(?:[^\\\]]|\\.)*\]|\(\??|\\([1-9][0-9]*)|\\./;
function ut(n, { joinWith: e }) {
  let t = 0;
  return n.map((r) => {
    t += 1;
    const s = t;
    let c = je(r), i = "";
    for (; c.length > 0; ) {
      const o = u4.exec(c);
      if (!o) {
        i += c;
        break;
      }
      i += c.substring(0, o.index), c = c.substring(o.index + o[0].length), o[0][0] === "\\" && o[1] ? i += "\\" + String(Number(o[1]) + s) : (i += o[0], o[0] === "(" && t++);
    }
    return i;
  }).map((r) => `(${r})`).join(e);
}
const f4 = /\b\B/, jr = "[a-zA-Z]\\w*", ft = "[a-zA-Z_]\\w*", Gr = "\\b\\d+(\\.\\d+)?", Vr = "(-?)(\\b0[xX][a-fA-F0-9]+|(\\b\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)", Zr = "\\b(0b[01]+)", p4 = "!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|-|-=|/=|/|:|;|<<|<<=|<=|<|===|==|=|>>>=|>>=|>=|>>>|>>|>|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~", h4 = (n = {}) => {
  const e = /^#![ ]*\//;
  return n.binary && (n.begin = Re(
    e,
    /.*\b/,
    n.binary,
    /\b.*/
  )), me({
    scope: "meta",
    begin: e,
    end: /$/,
    relevance: 0,
    /** @type {ModeCallback} */
    "on:begin": (t, r) => {
      t.index !== 0 && r.ignoreMatch();
    }
  }, n);
}, Ge = {
  begin: "\\\\[\\s\\S]",
  relevance: 0
}, d4 = {
  scope: "string",
  begin: "'",
  end: "'",
  illegal: "\\n",
  contains: [Ge]
}, g4 = {
  scope: "string",
  begin: '"',
  end: '"',
  illegal: "\\n",
  contains: [Ge]
}, b4 = {
  begin: /\b(a|an|the|are|I'm|isn't|don't|doesn't|won't|but|just|should|pretty|simply|enough|gonna|going|wtf|so|such|will|you|your|they|like|more)\b/
}, En = function(n, e, t = {}) {
  const r = me(
    {
      scope: "comment",
      begin: n,
      end: e,
      contains: []
    },
    t
  );
  r.contains.push({
    scope: "doctag",
    // hack to avoid the space from being included. the space is necessary to
    // match here to prevent the plain text rule below from gobbling up doctags
    begin: "[ ]*(?=(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):)",
    end: /(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):/,
    excludeBegin: !0,
    relevance: 0
  });
  const s = lt(
    // list of common 1 and 2 letter words in English
    "I",
    "a",
    "is",
    "so",
    "us",
    "to",
    "at",
    "if",
    "in",
    "it",
    "on",
    // note: this is not an exhaustive list of contractions, just popular ones
    /[A-Za-z]+['](d|ve|re|ll|t|s|n)/,
    // contractions - can't we'd they're let's, etc
    /[A-Za-z]+[-][a-z]+/,
    // `no-way`, etc.
    /[A-Za-z][a-z]{2,}/
    // allow capitalized words at beginning of sentences
  );
  return r.contains.push(
    {
      // TODO: how to include ", (, ) without breaking grammars that use these for
      // comment delimiters?
      // begin: /[ ]+([()"]?([A-Za-z'-]{3,}|is|a|I|so|us|[tT][oO]|at|if|in|it|on)[.]?[()":]?([.][ ]|[ ]|\))){3}/
      // ---
      // this tries to find sequences of 3 english words in a row (without any
      // "programming" type syntax) this gives us a strong signal that we've
      // TRULY found a comment - vs perhaps scanning with the wrong language.
      // It's possible to find something that LOOKS like the start of the
      // comment - but then if there is no readable text - good chance it is a
      // false match and not a comment.
      //
      // for a visual example please see:
      // https://github.com/highlightjs/highlight.js/issues/2827
      begin: Re(
        /[ ]+/,
        // necessary to prevent us gobbling up doctags like /* @author Bob Mcgill */
        "(",
        s,
        /[.]?[:]?([.][ ]|[ ])/,
        "){3}"
      )
      // look for 3 words in a row
    }
  ), r;
}, _4 = En("//", "$"), m4 = En("/\\*", "\\*/"), v4 = En("#", "$"), x4 = {
  scope: "number",
  begin: Gr,
  relevance: 0
}, k4 = {
  scope: "number",
  begin: Vr,
  relevance: 0
}, y4 = {
  scope: "number",
  begin: Zr,
  relevance: 0
}, E4 = {
  // this outer rule makes sure we actually have a WHOLE regex and not simply
  // an expression such as:
  //
  //     3 / something
  //
  // (which will then blow up when regex's `illegal` sees the newline)
  begin: /(?=\/[^/\n]*\/)/,
  contains: [{
    scope: "regexp",
    begin: /\//,
    end: /\/[gimuy]*/,
    illegal: /\n/,
    contains: [
      Ge,
      {
        begin: /\[/,
        end: /\]/,
        relevance: 0,
        contains: [Ge]
      }
    ]
  }]
}, w4 = {
  scope: "title",
  begin: jr,
  relevance: 0
}, A4 = {
  scope: "title",
  begin: ft,
  relevance: 0
}, C4 = {
  // excludes method names from keyword processing
  begin: "\\.\\s*" + ft,
  relevance: 0
}, S4 = function(n) {
  return Object.assign(
    n,
    {
      /** @type {ModeCallback} */
      "on:begin": (e, t) => {
        t.data._beginMatch = e[1];
      },
      /** @type {ModeCallback} */
      "on:end": (e, t) => {
        t.data._beginMatch !== e[1] && t.ignoreMatch();
      }
    }
  );
};
var nn = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  MATCH_NOTHING_RE: f4,
  IDENT_RE: jr,
  UNDERSCORE_IDENT_RE: ft,
  NUMBER_RE: Gr,
  C_NUMBER_RE: Vr,
  BINARY_NUMBER_RE: Zr,
  RE_STARTERS_RE: p4,
  SHEBANG: h4,
  BACKSLASH_ESCAPE: Ge,
  APOS_STRING_MODE: d4,
  QUOTE_STRING_MODE: g4,
  PHRASAL_WORDS_MODE: b4,
  COMMENT: En,
  C_LINE_COMMENT_MODE: _4,
  C_BLOCK_COMMENT_MODE: m4,
  HASH_COMMENT_MODE: v4,
  NUMBER_MODE: x4,
  C_NUMBER_MODE: k4,
  BINARY_NUMBER_MODE: y4,
  REGEXP_MODE: E4,
  TITLE_MODE: w4,
  UNDERSCORE_TITLE_MODE: A4,
  METHOD_GUARD: C4,
  END_SAME_AS_BEGIN: S4
});
function D4(n, e) {
  n.input[n.index - 1] === "." && e.ignoreMatch();
}
function R4(n, e) {
  n.className !== void 0 && (n.scope = n.className, delete n.className);
}
function T4(n, e) {
  e && n.beginKeywords && (n.begin = "\\b(" + n.beginKeywords.split(" ").join("|") + ")(?!\\.)(?=\\b|\\s)", n.__beforeBegin = D4, n.keywords = n.keywords || n.beginKeywords, delete n.beginKeywords, n.relevance === void 0 && (n.relevance = 0));
}
function M4(n, e) {
  Array.isArray(n.illegal) && (n.illegal = lt(...n.illegal));
}
function N4(n, e) {
  if (n.match) {
    if (n.begin || n.end)
      throw new Error("begin & end are not supported with match");
    n.begin = n.match, delete n.match;
  }
}
function q4(n, e) {
  n.relevance === void 0 && (n.relevance = 1);
}
const L4 = (n, e) => {
  if (!n.beforeMatch)
    return;
  if (n.starts)
    throw new Error("beforeMatch cannot be used with starts");
  const t = Object.assign({}, n);
  Object.keys(n).forEach((r) => {
    delete n[r];
  }), n.keywords = t.keywords, n.begin = Re(t.beforeMatch, Hr(t.begin)), n.starts = {
    relevance: 0,
    contains: [
      Object.assign(t, { endsParent: !0 })
    ]
  }, n.relevance = 0, delete t.beforeMatch;
}, O4 = [
  "of",
  "and",
  "for",
  "in",
  "not",
  "or",
  "if",
  "then",
  "parent",
  // common variable name
  "list",
  // common variable name
  "value"
  // common variable name
], I4 = "keyword";
function Kr(n, e, t = I4) {
  const r = /* @__PURE__ */ Object.create(null);
  return typeof n == "string" ? s(t, n.split(" ")) : Array.isArray(n) ? s(t, n) : Object.keys(n).forEach(function(c) {
    Object.assign(
      r,
      Kr(n[c], e, c)
    );
  }), r;
  function s(c, i) {
    e && (i = i.map((o) => o.toLowerCase())), i.forEach(function(o) {
      const a = o.split("|");
      r[a[0]] = [c, B4(a[0], a[1])];
    });
  }
}
function B4(n, e) {
  return e ? Number(e) : F4(n) ? 0 : 1;
}
function F4(n) {
  return O4.includes(n.toLowerCase());
}
const or = {}, Ce = (n) => {
  console.error(n);
}, sr = (n, ...e) => {
  console.log(`WARN: ${n}`, ...e);
}, qe = (n, e) => {
  or[`${n}/${e}`] || (console.log(`Deprecated as of ${n}. ${e}`), or[`${n}/${e}`] = !0);
}, an = new Error();
function Wr(n, e, { key: t }) {
  let r = 0;
  const s = n[t], c = {}, i = {};
  for (let o = 1; o <= e.length; o++)
    i[o + r] = s[o], c[o + r] = !0, r += Ur(e[o - 1]);
  n[t] = i, n[t]._emit = c, n[t]._multi = !0;
}
function $4(n) {
  if (Array.isArray(n.begin)) {
    if (n.skip || n.excludeBegin || n.returnBegin)
      throw Ce("skip, excludeBegin, returnBegin not compatible with beginScope: {}"), an;
    if (typeof n.beginScope != "object" || n.beginScope === null)
      throw Ce("beginScope must be object"), an;
    Wr(n, n.begin, { key: "beginScope" }), n.begin = ut(n.begin, { joinWith: "" });
  }
}
function P4(n) {
  if (Array.isArray(n.end)) {
    if (n.skip || n.excludeEnd || n.returnEnd)
      throw Ce("skip, excludeEnd, returnEnd not compatible with endScope: {}"), an;
    if (typeof n.endScope != "object" || n.endScope === null)
      throw Ce("endScope must be object"), an;
    Wr(n, n.end, { key: "endScope" }), n.end = ut(n.end, { joinWith: "" });
  }
}
function z4(n) {
  n.scope && typeof n.scope == "object" && n.scope !== null && (n.beginScope = n.scope, delete n.scope);
}
function H4(n) {
  z4(n), typeof n.beginScope == "string" && (n.beginScope = { _wrap: n.beginScope }), typeof n.endScope == "string" && (n.endScope = { _wrap: n.endScope }), $4(n), P4(n);
}
function U4(n) {
  function e(i, o) {
    return new RegExp(
      je(i),
      "m" + (n.case_insensitive ? "i" : "") + (n.unicodeRegex ? "u" : "") + (o ? "g" : "")
    );
  }
  class t {
    constructor() {
      this.matchIndexes = {}, this.regexes = [], this.matchAt = 1, this.position = 0;
    }
    // @ts-ignore
    addRule(o, a) {
      a.position = this.position++, this.matchIndexes[this.matchAt] = a, this.regexes.push([a, o]), this.matchAt += Ur(o) + 1;
    }
    compile() {
      this.regexes.length === 0 && (this.exec = () => null);
      const o = this.regexes.map((a) => a[1]);
      this.matcherRe = e(ut(o, { joinWith: "|" }), !0), this.lastIndex = 0;
    }
    /** @param {string} s */
    exec(o) {
      this.matcherRe.lastIndex = this.lastIndex;
      const a = this.matcherRe.exec(o);
      if (!a)
        return null;
      const l = a.findIndex((d, p) => p > 0 && d !== void 0), u = this.matchIndexes[l];
      return a.splice(0, l), Object.assign(a, u);
    }
  }
  class r {
    constructor() {
      this.rules = [], this.multiRegexes = [], this.count = 0, this.lastIndex = 0, this.regexIndex = 0;
    }
    // @ts-ignore
    getMatcher(o) {
      if (this.multiRegexes[o])
        return this.multiRegexes[o];
      const a = new t();
      return this.rules.slice(o).forEach(([l, u]) => a.addRule(l, u)), a.compile(), this.multiRegexes[o] = a, a;
    }
    resumingScanAtSamePosition() {
      return this.regexIndex !== 0;
    }
    considerAll() {
      this.regexIndex = 0;
    }
    // @ts-ignore
    addRule(o, a) {
      this.rules.push([o, a]), a.type === "begin" && this.count++;
    }
    /** @param {string} s */
    exec(o) {
      const a = this.getMatcher(this.regexIndex);
      a.lastIndex = this.lastIndex;
      let l = a.exec(o);
      if (this.resumingScanAtSamePosition() && !(l && l.index === this.lastIndex)) {
        const u = this.getMatcher(0);
        u.lastIndex = this.lastIndex + 1, l = u.exec(o);
      }
      return l && (this.regexIndex += l.position + 1, this.regexIndex === this.count && this.considerAll()), l;
    }
  }
  function s(i) {
    const o = new r();
    return i.contains.forEach((a) => o.addRule(a.begin, { rule: a, type: "begin" })), i.terminatorEnd && o.addRule(i.terminatorEnd, { type: "end" }), i.illegal && o.addRule(i.illegal, { type: "illegal" }), o;
  }
  function c(i, o) {
    const a = (
      /** @type CompiledMode */
      i
    );
    if (i.isCompiled)
      return a;
    [
      R4,
      // do this early so compiler extensions generally don't have to worry about
      // the distinction between match/begin
      N4,
      H4,
      L4
    ].forEach((u) => u(i, o)), n.compilerExtensions.forEach((u) => u(i, o)), i.__beforeBegin = null, [
      T4,
      // do this later so compiler extensions that come earlier have access to the
      // raw array if they wanted to perhaps manipulate it, etc.
      M4,
      // default to 1 relevance if not specified
      q4
    ].forEach((u) => u(i, o)), i.isCompiled = !0;
    let l = null;
    return typeof i.keywords == "object" && i.keywords.$pattern && (i.keywords = Object.assign({}, i.keywords), l = i.keywords.$pattern, delete i.keywords.$pattern), l = l || /\w+/, i.keywords && (i.keywords = Kr(i.keywords, n.case_insensitive)), a.keywordPatternRe = e(l, !0), o && (i.begin || (i.begin = /\B|\b/), a.beginRe = e(a.begin), !i.end && !i.endsWithParent && (i.end = /\B|\b/), i.end && (a.endRe = e(a.end)), a.terminatorEnd = je(a.end) || "", i.endsWithParent && o.terminatorEnd && (a.terminatorEnd += (i.end ? "|" : "") + o.terminatorEnd)), i.illegal && (a.illegalRe = e(
      /** @type {RegExp | string} */
      i.illegal
    )), i.contains || (i.contains = []), i.contains = [].concat(...i.contains.map(function(u) {
      return j4(u === "self" ? i : u);
    })), i.contains.forEach(function(u) {
      c(
        /** @type Mode */
        u,
        a
      );
    }), i.starts && c(i.starts, o), a.matcher = s(a), a;
  }
  if (n.compilerExtensions || (n.compilerExtensions = []), n.contains && n.contains.includes("self"))
    throw new Error("ERR: contains `self` is not supported at the top-level of a language.  See documentation.");
  return n.classNameAliases = me(n.classNameAliases || {}), c(
    /** @type Mode */
    n
  );
}
function Yr(n) {
  return n ? n.endsWithParent || Yr(n.starts) : !1;
}
function j4(n) {
  return n.variants && !n.cachedVariants && (n.cachedVariants = n.variants.map(function(e) {
    return me(n, { variants: null }, e);
  })), n.cachedVariants ? n.cachedVariants : Yr(n) ? me(n, { starts: n.starts ? me(n.starts) : null }) : Object.isFrozen(n) ? me(n) : n;
}
var G4 = "11.6.0";
let V4 = class extends Error {
  constructor(e, t) {
    super(e), this.name = "HTMLInjectionError", this.html = t;
  }
};
const jn = Pr, cr = me, ir = Symbol("nomatch"), Z4 = 7, K4 = function(n) {
  const e = /* @__PURE__ */ Object.create(null), t = /* @__PURE__ */ Object.create(null), r = [];
  let s = !0;
  const c = "Could not find the language '{}', did you forget to load/include a language module?", i = { disableAutodetect: !0, name: "Plain text", contains: [] };
  let o = {
    ignoreUnescapedHTML: !1,
    throwUnescapedHTML: !1,
    noHighlightRe: /^(no-?highlight)$/i,
    languageDetectRe: /\blang(?:uage)?-([\w-]+)\b/i,
    classPrefix: "hljs-",
    cssSelector: "pre code",
    languages: null,
    // beta configuration options, subject to change, welcome to discuss
    // https://github.com/highlightjs/highlight.js/issues/1086
    __emitter: s4
  };
  function a(f) {
    return o.noHighlightRe.test(f);
  }
  function l(f) {
    let b = f.className + " ";
    b += f.parentNode ? f.parentNode.className : "";
    const y = o.languageDetectRe.exec(b);
    if (y) {
      const T = V(y[1]);
      return T || (sr(c.replace("{}", y[1])), sr("Falling back to no-highlight mode for this block.", f)), T ? y[1] : "no-highlight";
    }
    return b.split(/\s+/).find((T) => a(T) || V(T));
  }
  function u(f, b, y) {
    let T = "", I = "";
    typeof b == "object" ? (T = f, y = b.ignoreIllegals, I = b.language) : (qe("10.7.0", "highlight(lang, code, ...args) has been deprecated."), qe("10.7.0", `Please use highlight(code, options) instead.
https://github.com/highlightjs/highlight.js/issues/2277`), I = f, T = b), y === void 0 && (y = !0);
    const Z = {
      code: T,
      language: I
    };
    k("before:highlight", Z);
    const J = Z.result ? Z.result : d(Z.language, Z.code, y);
    return J.code = Z.code, k("after:highlight", J), J;
  }
  function d(f, b, y, T) {
    const I = /* @__PURE__ */ Object.create(null);
    function Z(g, _) {
      return g.keywords[_];
    }
    function J() {
      if (!x.keywords) {
        $.addText(L);
        return;
      }
      let g = 0;
      x.keywordPatternRe.lastIndex = 0;
      let _ = x.keywordPatternRe.exec(L), E = "";
      for (; _; ) {
        E += L.substring(g, _.index);
        const M = Q.case_insensitive ? _[0].toLowerCase() : _[0], z = Z(x, M);
        if (z) {
          const [Y, Tn] = z;
          if ($.addText(E), E = "", I[M] = (I[M] || 0) + 1, I[M] <= Z4 && (de += Tn), Y.startsWith("_"))
            E += _[0];
          else {
            const Mn = Q.classNameAliases[Y] || Y;
            $.addKeyword(_[0], Mn);
          }
        } else
          E += _[0];
        g = x.keywordPatternRe.lastIndex, _ = x.keywordPatternRe.exec(L);
      }
      E += L.substring(g), $.addText(E);
    }
    function pe() {
      if (L === "")
        return;
      let g = null;
      if (typeof x.subLanguage == "string") {
        if (!e[x.subLanguage]) {
          $.addText(L);
          return;
        }
        g = d(x.subLanguage, L, !0, He[x.subLanguage]), He[x.subLanguage] = /** @type {CompiledMode} */
        g._top;
      } else
        g = h(L, x.subLanguage.length ? x.subLanguage : null);
      x.relevance > 0 && (de += g.relevance), $.addSublanguage(g._emitter, g.language);
    }
    function G() {
      x.subLanguage != null ? pe() : J(), L = "";
    }
    function X(g, _) {
      let E = 1;
      const M = _.length - 1;
      for (; E <= M; ) {
        if (!g._emit[E]) {
          E++;
          continue;
        }
        const z = Q.classNameAliases[g[E]] || g[E], Y = _[E];
        z ? $.addKeyword(Y, z) : (L = Y, J(), L = ""), E++;
      }
    }
    function $e(g, _) {
      return g.scope && typeof g.scope == "string" && $.openNode(Q.classNameAliases[g.scope] || g.scope), g.beginScope && (g.beginScope._wrap ? ($.addKeyword(L, Q.classNameAliases[g.beginScope._wrap] || g.beginScope._wrap), L = "") : g.beginScope._multi && (X(g.beginScope, _), L = "")), x = Object.create(g, { parent: { value: x } }), x;
    }
    function Pe(g, _, E) {
      let M = l4(g.endRe, E);
      if (M) {
        if (g["on:end"]) {
          const z = new nr(g);
          g["on:end"](_, z), z.isMatchIgnored && (M = !1);
        }
        if (M) {
          for (; g.endsParent && g.parent; )
            g = g.parent;
          return g;
        }
      }
      if (g.endsWithParent)
        return Pe(g.parent, _, E);
    }
    function An(g) {
      return x.matcher.regexIndex === 0 ? (L += g[0], 1) : (ye = !0, 0);
    }
    function Cn(g) {
      const _ = g[0], E = g.rule, M = new nr(E), z = [E.__beforeBegin, E["on:begin"]];
      for (const Y of z)
        if (Y && (Y(g, M), M.isMatchIgnored))
          return An(_);
      return E.skip ? L += _ : (E.excludeBegin && (L += _), G(), !E.returnBegin && !E.excludeBegin && (L = _)), $e(E, g), E.returnBegin ? 0 : _.length;
    }
    function Sn(g) {
      const _ = g[0], E = b.substring(g.index), M = Pe(x, g, E);
      if (!M)
        return ir;
      const z = x;
      x.endScope && x.endScope._wrap ? (G(), $.addKeyword(_, x.endScope._wrap)) : x.endScope && x.endScope._multi ? (G(), X(x.endScope, g)) : z.skip ? L += _ : (z.returnEnd || z.excludeEnd || (L += _), G(), z.excludeEnd && (L = _));
      do
        x.scope && $.closeNode(), !x.skip && !x.subLanguage && (de += x.relevance), x = x.parent;
      while (x !== M.parent);
      return M.starts && $e(M.starts, g), z.returnEnd ? 0 : _.length;
    }
    function Dn() {
      const g = [];
      for (let _ = x; _ !== Q; _ = _.parent)
        _.scope && g.unshift(_.scope);
      g.forEach((_) => $.openNode(_));
    }
    let he = {};
    function ze(g, _) {
      const E = _ && _[0];
      if (L += g, E == null)
        return G(), 0;
      if (he.type === "begin" && _.type === "end" && he.index === _.index && E === "") {
        if (L += b.slice(_.index, _.index + 1), !s) {
          const M = new Error(`0 width match regex (${f})`);
          throw M.languageName = f, M.badRule = he.rule, M;
        }
        return 1;
      }
      if (he = _, _.type === "begin")
        return Cn(_);
      if (_.type === "illegal" && !y) {
        const M = new Error('Illegal lexeme "' + E + '" for mode "' + (x.scope || "<unnamed>") + '"');
        throw M.mode = x, M;
      } else if (_.type === "end") {
        const M = Sn(_);
        if (M !== ir)
          return M;
      }
      if (_.type === "illegal" && E === "")
        return 1;
      if (ke > 1e5 && ke > _.index * 3)
        throw new Error("potential infinite loop, way more iterations than matches");
      return L += E, E.length;
    }
    const Q = V(f);
    if (!Q)
      throw Ce(c.replace("{}", f)), new Error('Unknown language: "' + f + '"');
    const Rn = U4(Q);
    let xe = "", x = T || Rn;
    const He = {}, $ = new o.__emitter(o);
    Dn();
    let L = "", de = 0, ee = 0, ke = 0, ye = !1;
    try {
      for (x.matcher.considerAll(); ; ) {
        ke++, ye ? ye = !1 : x.matcher.considerAll(), x.matcher.lastIndex = ee;
        const g = x.matcher.exec(b);
        if (!g)
          break;
        const _ = b.substring(ee, g.index), E = ze(_, g);
        ee = g.index + E;
      }
      return ze(b.substring(ee)), $.closeAllNodes(), $.finalize(), xe = $.toHTML(), {
        language: f,
        value: xe,
        relevance: de,
        illegal: !1,
        _emitter: $,
        _top: x
      };
    } catch (g) {
      if (g.message && g.message.includes("Illegal"))
        return {
          language: f,
          value: jn(b),
          illegal: !0,
          relevance: 0,
          _illegalBy: {
            message: g.message,
            index: ee,
            context: b.slice(ee - 100, ee + 100),
            mode: g.mode,
            resultSoFar: xe
          },
          _emitter: $
        };
      if (s)
        return {
          language: f,
          value: jn(b),
          illegal: !1,
          relevance: 0,
          errorRaised: g,
          _emitter: $,
          _top: x
        };
      throw g;
    }
  }
  function p(f) {
    const b = {
      value: jn(f),
      illegal: !1,
      relevance: 0,
      _top: i,
      _emitter: new o.__emitter(o)
    };
    return b._emitter.addText(f), b;
  }
  function h(f, b) {
    b = b || o.languages || Object.keys(e);
    const y = p(f), T = b.filter(V).filter(U).map(
      (G) => d(G, f, !1)
    );
    T.unshift(y);
    const I = T.sort((G, X) => {
      if (G.relevance !== X.relevance)
        return X.relevance - G.relevance;
      if (G.language && X.language) {
        if (V(G.language).supersetOf === X.language)
          return 1;
        if (V(X.language).supersetOf === G.language)
          return -1;
      }
      return 0;
    }), [Z, J] = I, pe = Z;
    return pe.secondBest = J, pe;
  }
  function m(f, b, y) {
    const T = b && t[b] || y;
    f.classList.add("hljs"), f.classList.add(`language-${T}`);
  }
  function v(f) {
    let b = null;
    const y = l(f);
    if (a(y))
      return;
    if (k(
      "before:highlightElement",
      { el: f, language: y }
    ), f.children.length > 0 && (o.ignoreUnescapedHTML || (console.warn("One of your code blocks includes unescaped HTML. This is a potentially serious security risk."), console.warn("https://github.com/highlightjs/highlight.js/wiki/security"), console.warn("The element with unescaped HTML:"), console.warn(f)), o.throwUnescapedHTML))
      throw new V4(
        "One of your code blocks includes unescaped HTML.",
        f.innerHTML
      );
    b = f;
    const T = b.textContent, I = y ? u(T, { language: y, ignoreIllegals: !0 }) : h(T);
    f.innerHTML = I.value, m(f, y, I.language), f.result = {
      language: I.language,
      // TODO: remove with version 11.0
      re: I.relevance,
      relevance: I.relevance
    }, I.secondBest && (f.secondBest = {
      language: I.secondBest.language,
      relevance: I.secondBest.relevance
    }), k("after:highlightElement", { el: f, result: I, text: T });
  }
  function R(f) {
    o = cr(o, f);
  }
  const A = () => {
    N(), qe("10.6.0", "initHighlighting() deprecated.  Use highlightAll() now.");
  };
  function w() {
    N(), qe("10.6.0", "initHighlightingOnLoad() deprecated.  Use highlightAll() now.");
  }
  let S = !1;
  function N() {
    if (document.readyState === "loading") {
      S = !0;
      return;
    }
    document.querySelectorAll(o.cssSelector).forEach(v);
  }
  function O() {
    S && N();
  }
  typeof window < "u" && window.addEventListener && window.addEventListener("DOMContentLoaded", O, !1);
  function C(f, b) {
    let y = null;
    try {
      y = b(n);
    } catch (T) {
      if (Ce("Language definition for '{}' could not be registered.".replace("{}", f)), s)
        Ce(T);
      else
        throw T;
      y = i;
    }
    y.name || (y.name = f), e[f] = y, y.rawDefinition = b.bind(null, n), y.aliases && B(y.aliases, { languageName: f });
  }
  function P(f) {
    delete e[f];
    for (const b of Object.keys(t))
      t[b] === f && delete t[b];
  }
  function K() {
    return Object.keys(e);
  }
  function V(f) {
    return f = (f || "").toLowerCase(), e[f] || e[t[f]];
  }
  function B(f, { languageName: b }) {
    typeof f == "string" && (f = [f]), f.forEach((y) => {
      t[y.toLowerCase()] = b;
    });
  }
  function U(f) {
    const b = V(f);
    return b && !b.disableAutodetect;
  }
  function ce(f) {
    f["before:highlightBlock"] && !f["before:highlightElement"] && (f["before:highlightElement"] = (b) => {
      f["before:highlightBlock"](
        Object.assign({ block: b.el }, b)
      );
    }), f["after:highlightBlock"] && !f["after:highlightElement"] && (f["after:highlightElement"] = (b) => {
      f["after:highlightBlock"](
        Object.assign({ block: b.el }, b)
      );
    });
  }
  function re(f) {
    ce(f), r.push(f);
  }
  function k(f, b) {
    const y = f;
    r.forEach(function(T) {
      T[y] && T[y](b);
    });
  }
  function j(f) {
    return qe("10.7.0", "highlightBlock will be removed entirely in v12.0"), qe("10.7.0", "Please use highlightElement now."), v(f);
  }
  Object.assign(n, {
    highlight: u,
    highlightAuto: h,
    highlightAll: N,
    highlightElement: v,
    // TODO: Remove with v12 API
    highlightBlock: j,
    configure: R,
    initHighlighting: A,
    initHighlightingOnLoad: w,
    registerLanguage: C,
    unregisterLanguage: P,
    listLanguages: K,
    getLanguage: V,
    registerAliases: B,
    autoDetection: U,
    inherit: cr,
    addPlugin: re
  }), n.debugMode = function() {
    s = !1;
  }, n.safeMode = function() {
    s = !0;
  }, n.versionString = G4, n.regex = {
    concat: Re,
    lookahead: Hr,
    either: lt,
    optional: i4,
    anyNumberOfTimes: c4
  };
  for (const f in nn)
    typeof nn[f] == "object" && it.exports(nn[f]);
  return Object.assign(n, nn), n;
};
var Ve = K4({}), W4 = Ve;
Ve.HighlightJS = Ve;
Ve.default = Ve;
const ge = W4;
function ln(n) {
  const e = n.regex, t = /[\p{XID_Start}_]\p{XID_Continue}*/u, r = [
    "and",
    "as",
    "assert",
    "async",
    "await",
    "break",
    "case",
    "class",
    "continue",
    "def",
    "del",
    "elif",
    "else",
    "except",
    "finally",
    "for",
    "from",
    "global",
    "if",
    "import",
    "in",
    "is",
    "lambda",
    "match",
    "nonlocal|10",
    "not",
    "or",
    "pass",
    "raise",
    "return",
    "try",
    "while",
    "with",
    "yield"
  ], o = {
    $pattern: /[A-Za-z]\w+|__\w+__/,
    keyword: r,
    built_in: [
      "__import__",
      "abs",
      "all",
      "any",
      "ascii",
      "bin",
      "bool",
      "breakpoint",
      "bytearray",
      "bytes",
      "callable",
      "chr",
      "classmethod",
      "compile",
      "complex",
      "delattr",
      "dict",
      "dir",
      "divmod",
      "enumerate",
      "eval",
      "exec",
      "filter",
      "float",
      "format",
      "frozenset",
      "getattr",
      "globals",
      "hasattr",
      "hash",
      "help",
      "hex",
      "id",
      "input",
      "int",
      "isinstance",
      "issubclass",
      "iter",
      "len",
      "list",
      "locals",
      "map",
      "max",
      "memoryview",
      "min",
      "next",
      "object",
      "oct",
      "open",
      "ord",
      "pow",
      "print",
      "property",
      "range",
      "repr",
      "reversed",
      "round",
      "set",
      "setattr",
      "slice",
      "sorted",
      "staticmethod",
      "str",
      "sum",
      "super",
      "tuple",
      "type",
      "vars",
      "zip"
    ],
    literal: [
      "__debug__",
      "Ellipsis",
      "False",
      "None",
      "NotImplemented",
      "True"
    ],
    type: [
      "Any",
      "Callable",
      "Coroutine",
      "Dict",
      "List",
      "Literal",
      "Generic",
      "Optional",
      "Sequence",
      "Set",
      "Tuple",
      "Type",
      "Union"
    ]
  }, a = {
    className: "meta",
    begin: /^(>>>|\.\.\.) /
  }, l = {
    className: "subst",
    begin: /\{/,
    end: /\}/,
    keywords: o,
    illegal: /#/
  }, u = {
    begin: /\{\{/,
    relevance: 0
  }, d = {
    className: "string",
    contains: [n.BACKSLASH_ESCAPE],
    variants: [
      {
        begin: /([uU]|[bB]|[rR]|[bB][rR]|[rR][bB])?'''/,
        end: /'''/,
        contains: [
          n.BACKSLASH_ESCAPE,
          a
        ],
        relevance: 10
      },
      {
        begin: /([uU]|[bB]|[rR]|[bB][rR]|[rR][bB])?"""/,
        end: /"""/,
        contains: [
          n.BACKSLASH_ESCAPE,
          a
        ],
        relevance: 10
      },
      {
        begin: /([fF][rR]|[rR][fF]|[fF])'''/,
        end: /'''/,
        contains: [
          n.BACKSLASH_ESCAPE,
          a,
          u,
          l
        ]
      },
      {
        begin: /([fF][rR]|[rR][fF]|[fF])"""/,
        end: /"""/,
        contains: [
          n.BACKSLASH_ESCAPE,
          a,
          u,
          l
        ]
      },
      {
        begin: /([uU]|[rR])'/,
        end: /'/,
        relevance: 10
      },
      {
        begin: /([uU]|[rR])"/,
        end: /"/,
        relevance: 10
      },
      {
        begin: /([bB]|[bB][rR]|[rR][bB])'/,
        end: /'/
      },
      {
        begin: /([bB]|[bB][rR]|[rR][bB])"/,
        end: /"/
      },
      {
        begin: /([fF][rR]|[rR][fF]|[fF])'/,
        end: /'/,
        contains: [
          n.BACKSLASH_ESCAPE,
          u,
          l
        ]
      },
      {
        begin: /([fF][rR]|[rR][fF]|[fF])"/,
        end: /"/,
        contains: [
          n.BACKSLASH_ESCAPE,
          u,
          l
        ]
      },
      n.APOS_STRING_MODE,
      n.QUOTE_STRING_MODE
    ]
  }, p = "[0-9](_?[0-9])*", h = `(\\b(${p}))?\\.(${p})|\\b(${p})\\.`, m = `\\b|${r.join("|")}`, v = {
    className: "number",
    relevance: 0,
    variants: [
      // exponentfloat, pointfloat
      // https://docs.python.org/3.9/reference/lexical_analysis.html#floating-point-literals
      // optionally imaginary
      // https://docs.python.org/3.9/reference/lexical_analysis.html#imaginary-literals
      // Note: no leading \b because floats can start with a decimal point
      // and we don't want to mishandle e.g. `fn(.5)`,
      // no trailing \b for pointfloat because it can end with a decimal point
      // and we don't want to mishandle e.g. `0..hex()`; this should be safe
      // because both MUST contain a decimal point and so cannot be confused with
      // the interior part of an identifier
      {
        begin: `(\\b(${p})|(${h}))[eE][+-]?(${p})[jJ]?(?=${m})`
      },
      {
        begin: `(${h})[jJ]?`
      },
      // decinteger, bininteger, octinteger, hexinteger
      // https://docs.python.org/3.9/reference/lexical_analysis.html#integer-literals
      // optionally "long" in Python 2
      // https://docs.python.org/2.7/reference/lexical_analysis.html#integer-and-long-integer-literals
      // decinteger is optionally imaginary
      // https://docs.python.org/3.9/reference/lexical_analysis.html#imaginary-literals
      {
        begin: `\\b([1-9](_?[0-9])*|0+(_?0)*)[lLjJ]?(?=${m})`
      },
      {
        begin: `\\b0[bB](_?[01])+[lL]?(?=${m})`
      },
      {
        begin: `\\b0[oO](_?[0-7])+[lL]?(?=${m})`
      },
      {
        begin: `\\b0[xX](_?[0-9a-fA-F])+[lL]?(?=${m})`
      },
      // imagnumber (digitpart-based)
      // https://docs.python.org/3.9/reference/lexical_analysis.html#imaginary-literals
      {
        begin: `\\b(${p})[jJ](?=${m})`
      }
    ]
  }, R = {
    className: "comment",
    begin: e.lookahead(/# type:/),
    end: /$/,
    keywords: o,
    contains: [
      {
        // prevent keywords from coloring `type`
        begin: /# type:/
      },
      // comment within a datatype comment includes no keywords
      {
        begin: /#/,
        end: /\b\B/,
        endsWithParent: !0
      }
    ]
  }, A = {
    className: "params",
    variants: [
      // Exclude params in functions without params
      {
        className: "",
        begin: /\(\s*\)/,
        skip: !0
      },
      {
        begin: /\(/,
        end: /\)/,
        excludeBegin: !0,
        excludeEnd: !0,
        keywords: o,
        contains: [
          "self",
          a,
          v,
          d,
          n.HASH_COMMENT_MODE
        ]
      }
    ]
  };
  return l.contains = [
    d,
    v,
    a
  ], {
    name: "Python",
    aliases: [
      "py",
      "gyp",
      "ipython"
    ],
    unicodeRegex: !0,
    keywords: o,
    illegal: /(<\/|->|\?)|=>/,
    contains: [
      a,
      v,
      {
        // very common convention
        begin: /\bself\b/
      },
      {
        // eat "if" prior to string so that it won't accidentally be
        // labeled as an f-string
        beginKeywords: "if",
        relevance: 0
      },
      d,
      R,
      n.HASH_COMMENT_MODE,
      {
        match: [
          /\bdef/,
          /\s+/,
          t
        ],
        scope: {
          1: "keyword",
          3: "title.function"
        },
        contains: [A]
      },
      {
        variants: [
          {
            match: [
              /\bclass/,
              /\s+/,
              t,
              /\s*/,
              /\(\s*/,
              t,
              /\s*\)/
            ]
          },
          {
            match: [
              /\bclass/,
              /\s+/,
              t
            ]
          }
        ],
        scope: {
          1: "keyword",
          3: "title.class",
          6: "title.class.inherited"
        }
      },
      {
        className: "meta",
        begin: /^[\t ]*@/,
        end: /(?=#)|$/,
        contains: [
          v,
          A,
          d
        ]
      }
    ]
  };
}
var pt = { exports: {} };
function ht(n) {
  return n instanceof Map ? n.clear = n.delete = n.set = function() {
    throw new Error("map is read-only");
  } : n instanceof Set && (n.add = n.clear = n.delete = function() {
    throw new Error("set is read-only");
  }), Object.freeze(n), Object.getOwnPropertyNames(n).forEach(function(e) {
    var t = n[e];
    typeof t == "object" && !Object.isFrozen(t) && ht(t);
  }), n;
}
pt.exports = ht;
pt.exports.default = ht;
class ar {
  constructor(e) {
    e.data === void 0 && (e.data = {}), this.data = e.data, this.isMatchIgnored = !1;
  }
  ignoreMatch() {
    this.isMatchIgnored = !0;
  }
}
function Jr(n) {
  return n.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#x27;");
}
function ve(n, ...e) {
  const t = /* @__PURE__ */ Object.create(null);
  for (const r in n)
    t[r] = n[r];
  return e.forEach(function(r) {
    for (const s in r)
      t[s] = r[s];
  }), t;
}
const Y4 = "</span>", lr = (n) => !!n.scope || n.sublanguage && n.language, J4 = (n, { prefix: e }) => {
  if (n.includes(".")) {
    const t = n.split(".");
    return [
      `${e}${t.shift()}`,
      ...t.map((r, s) => `${r}${"_".repeat(s + 1)}`)
    ].join(" ");
  }
  return `${e}${n}`;
};
class X4 {
  constructor(e, t) {
    this.buffer = "", this.classPrefix = t.classPrefix, e.walk(this);
  }
  addText(e) {
    this.buffer += Jr(e);
  }
  openNode(e) {
    if (!lr(e))
      return;
    let t = "";
    e.sublanguage ? t = `language-${e.language}` : t = J4(e.scope, { prefix: this.classPrefix }), this.span(t);
  }
  closeNode(e) {
    lr(e) && (this.buffer += Y4);
  }
  value() {
    return this.buffer;
  }
  span(e) {
    this.buffer += `<span class="${e}">`;
  }
}
const ur = (n = {}) => {
  const e = { children: [] };
  return Object.assign(e, n), e;
};
class dt {
  constructor() {
    this.rootNode = ur(), this.stack = [this.rootNode];
  }
  get top() {
    return this.stack[this.stack.length - 1];
  }
  get root() {
    return this.rootNode;
  }
  add(e) {
    this.top.children.push(e);
  }
  openNode(e) {
    const t = ur({ scope: e });
    this.add(t), this.stack.push(t);
  }
  closeNode() {
    if (this.stack.length > 1)
      return this.stack.pop();
  }
  closeAllNodes() {
    for (; this.closeNode(); )
      ;
  }
  toJSON() {
    return JSON.stringify(this.rootNode, null, 4);
  }
  walk(e) {
    return this.constructor._walk(e, this.rootNode);
  }
  static _walk(e, t) {
    return typeof t == "string" ? e.addText(t) : t.children && (e.openNode(t), t.children.forEach((r) => this._walk(e, r)), e.closeNode(t)), e;
  }
  static _collapse(e) {
    typeof e != "string" && e.children && (e.children.every((t) => typeof t == "string") ? e.children = [e.children.join("")] : e.children.forEach((t) => {
      dt._collapse(t);
    }));
  }
}
class Q4 extends dt {
  constructor(e) {
    super(), this.options = e;
  }
  addKeyword(e, t) {
    e !== "" && (this.openNode(t), this.addText(e), this.closeNode());
  }
  addText(e) {
    e !== "" && this.add(e);
  }
  addSublanguage(e, t) {
    const r = e.root;
    r.sublanguage = !0, r.language = t, this.add(r);
  }
  toHTML() {
    return new X4(this, this.options).value();
  }
  finalize() {
    return !0;
  }
}
function Ze(n) {
  return n ? typeof n == "string" ? n : n.source : null;
}
function Xr(n) {
  return Te("(?=", n, ")");
}
function e9(n) {
  return Te("(?:", n, ")*");
}
function n9(n) {
  return Te("(?:", n, ")?");
}
function Te(...n) {
  return n.map((t) => Ze(t)).join("");
}
function t9(n) {
  const e = n[n.length - 1];
  return typeof e == "object" && e.constructor === Object ? (n.splice(n.length - 1, 1), e) : {};
}
function gt(...n) {
  return "(" + (t9(n).capture ? "" : "?:") + n.map((r) => Ze(r)).join("|") + ")";
}
function Qr(n) {
  return new RegExp(n.toString() + "|").exec("").length - 1;
}
function r9(n, e) {
  const t = n && n.exec(e);
  return t && t.index === 0;
}
const o9 = /\[(?:[^\\\]]|\\.)*\]|\(\??|\\([1-9][0-9]*)|\\./;
function bt(n, { joinWith: e }) {
  let t = 0;
  return n.map((r) => {
    t += 1;
    const s = t;
    let c = Ze(r), i = "";
    for (; c.length > 0; ) {
      const o = o9.exec(c);
      if (!o) {
        i += c;
        break;
      }
      i += c.substring(0, o.index), c = c.substring(o.index + o[0].length), o[0][0] === "\\" && o[1] ? i += "\\" + String(Number(o[1]) + s) : (i += o[0], o[0] === "(" && t++);
    }
    return i;
  }).map((r) => `(${r})`).join(e);
}
const s9 = /\b\B/, eo = "[a-zA-Z]\\w*", _t = "[a-zA-Z_]\\w*", no = "\\b\\d+(\\.\\d+)?", to = "(-?)(\\b0[xX][a-fA-F0-9]+|(\\b\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)", ro = "\\b(0b[01]+)", c9 = "!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|-|-=|/=|/|:|;|<<|<<=|<=|<|===|==|=|>>>=|>>=|>=|>>>|>>|>|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~", i9 = (n = {}) => {
  const e = /^#![ ]*\//;
  return n.binary && (n.begin = Te(
    e,
    /.*\b/,
    n.binary,
    /\b.*/
  )), ve({
    scope: "meta",
    begin: e,
    end: /$/,
    relevance: 0,
    "on:begin": (t, r) => {
      t.index !== 0 && r.ignoreMatch();
    }
  }, n);
}, Ke = {
  begin: "\\\\[\\s\\S]",
  relevance: 0
}, a9 = {
  scope: "string",
  begin: "'",
  end: "'",
  illegal: "\\n",
  contains: [Ke]
}, l9 = {
  scope: "string",
  begin: '"',
  end: '"',
  illegal: "\\n",
  contains: [Ke]
}, u9 = {
  begin: /\b(a|an|the|are|I'm|isn't|don't|doesn't|won't|but|just|should|pretty|simply|enough|gonna|going|wtf|so|such|will|you|your|they|like|more)\b/
}, wn = function(n, e, t = {}) {
  const r = ve(
    {
      scope: "comment",
      begin: n,
      end: e,
      contains: []
    },
    t
  );
  r.contains.push({
    scope: "doctag",
    begin: "[ ]*(?=(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):)",
    end: /(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):/,
    excludeBegin: !0,
    relevance: 0
  });
  const s = gt(
    "I",
    "a",
    "is",
    "so",
    "us",
    "to",
    "at",
    "if",
    "in",
    "it",
    "on",
    /[A-Za-z]+['](d|ve|re|ll|t|s|n)/,
    /[A-Za-z]+[-][a-z]+/,
    /[A-Za-z][a-z]{2,}/
  );
  return r.contains.push(
    {
      begin: Te(
        /[ ]+/,
        "(",
        s,
        /[.]?[:]?([.][ ]|[ ])/,
        "){3}"
      )
    }
  ), r;
}, f9 = wn("//", "$"), p9 = wn("/\\*", "\\*/"), h9 = wn("#", "$"), d9 = {
  scope: "number",
  begin: no,
  relevance: 0
}, g9 = {
  scope: "number",
  begin: to,
  relevance: 0
}, b9 = {
  scope: "number",
  begin: ro,
  relevance: 0
}, _9 = {
  begin: /(?=\/[^/\n]*\/)/,
  contains: [{
    scope: "regexp",
    begin: /\//,
    end: /\/[gimuy]*/,
    illegal: /\n/,
    contains: [
      Ke,
      {
        begin: /\[/,
        end: /\]/,
        relevance: 0,
        contains: [Ke]
      }
    ]
  }]
}, m9 = {
  scope: "title",
  begin: eo,
  relevance: 0
}, v9 = {
  scope: "title",
  begin: _t,
  relevance: 0
}, x9 = {
  begin: "\\.\\s*" + _t,
  relevance: 0
}, k9 = function(n) {
  return Object.assign(
    n,
    {
      "on:begin": (e, t) => {
        t.data._beginMatch = e[1];
      },
      "on:end": (e, t) => {
        t.data._beginMatch !== e[1] && t.ignoreMatch();
      }
    }
  );
};
var tn = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  MATCH_NOTHING_RE: s9,
  IDENT_RE: eo,
  UNDERSCORE_IDENT_RE: _t,
  NUMBER_RE: no,
  C_NUMBER_RE: to,
  BINARY_NUMBER_RE: ro,
  RE_STARTERS_RE: c9,
  SHEBANG: i9,
  BACKSLASH_ESCAPE: Ke,
  APOS_STRING_MODE: a9,
  QUOTE_STRING_MODE: l9,
  PHRASAL_WORDS_MODE: u9,
  COMMENT: wn,
  C_LINE_COMMENT_MODE: f9,
  C_BLOCK_COMMENT_MODE: p9,
  HASH_COMMENT_MODE: h9,
  NUMBER_MODE: d9,
  C_NUMBER_MODE: g9,
  BINARY_NUMBER_MODE: b9,
  REGEXP_MODE: _9,
  TITLE_MODE: m9,
  UNDERSCORE_TITLE_MODE: v9,
  METHOD_GUARD: x9,
  END_SAME_AS_BEGIN: k9
});
function y9(n, e) {
  n.input[n.index - 1] === "." && e.ignoreMatch();
}
function E9(n, e) {
  n.className !== void 0 && (n.scope = n.className, delete n.className);
}
function w9(n, e) {
  e && n.beginKeywords && (n.begin = "\\b(" + n.beginKeywords.split(" ").join("|") + ")(?!\\.)(?=\\b|\\s)", n.__beforeBegin = y9, n.keywords = n.keywords || n.beginKeywords, delete n.beginKeywords, n.relevance === void 0 && (n.relevance = 0));
}
function A9(n, e) {
  Array.isArray(n.illegal) && (n.illegal = gt(...n.illegal));
}
function C9(n, e) {
  if (n.match) {
    if (n.begin || n.end)
      throw new Error("begin & end are not supported with match");
    n.begin = n.match, delete n.match;
  }
}
function S9(n, e) {
  n.relevance === void 0 && (n.relevance = 1);
}
const D9 = (n, e) => {
  if (!n.beforeMatch)
    return;
  if (n.starts)
    throw new Error("beforeMatch cannot be used with starts");
  const t = Object.assign({}, n);
  Object.keys(n).forEach((r) => {
    delete n[r];
  }), n.keywords = t.keywords, n.begin = Te(t.beforeMatch, Xr(t.begin)), n.starts = {
    relevance: 0,
    contains: [
      Object.assign(t, { endsParent: !0 })
    ]
  }, n.relevance = 0, delete t.beforeMatch;
}, R9 = [
  "of",
  "and",
  "for",
  "in",
  "not",
  "or",
  "if",
  "then",
  "parent",
  "list",
  "value"
], T9 = "keyword";
function oo(n, e, t = T9) {
  const r = /* @__PURE__ */ Object.create(null);
  return typeof n == "string" ? s(t, n.split(" ")) : Array.isArray(n) ? s(t, n) : Object.keys(n).forEach(function(c) {
    Object.assign(
      r,
      oo(n[c], e, c)
    );
  }), r;
  function s(c, i) {
    e && (i = i.map((o) => o.toLowerCase())), i.forEach(function(o) {
      const a = o.split("|");
      r[a[0]] = [c, M9(a[0], a[1])];
    });
  }
}
function M9(n, e) {
  return e ? Number(e) : N9(n) ? 0 : 1;
}
function N9(n) {
  return R9.includes(n.toLowerCase());
}
const fr = {}, Se = (n) => {
  console.error(n);
}, pr = (n, ...e) => {
  console.log(`WARN: ${n}`, ...e);
}, Le = (n, e) => {
  fr[`${n}/${e}`] || (console.log(`Deprecated as of ${n}. ${e}`), fr[`${n}/${e}`] = !0);
}, un = new Error();
function so(n, e, { key: t }) {
  let r = 0;
  const s = n[t], c = {}, i = {};
  for (let o = 1; o <= e.length; o++)
    i[o + r] = s[o], c[o + r] = !0, r += Qr(e[o - 1]);
  n[t] = i, n[t]._emit = c, n[t]._multi = !0;
}
function q9(n) {
  if (Array.isArray(n.begin)) {
    if (n.skip || n.excludeBegin || n.returnBegin)
      throw Se("skip, excludeBegin, returnBegin not compatible with beginScope: {}"), un;
    if (typeof n.beginScope != "object" || n.beginScope === null)
      throw Se("beginScope must be object"), un;
    so(n, n.begin, { key: "beginScope" }), n.begin = bt(n.begin, { joinWith: "" });
  }
}
function L9(n) {
  if (Array.isArray(n.end)) {
    if (n.skip || n.excludeEnd || n.returnEnd)
      throw Se("skip, excludeEnd, returnEnd not compatible with endScope: {}"), un;
    if (typeof n.endScope != "object" || n.endScope === null)
      throw Se("endScope must be object"), un;
    so(n, n.end, { key: "endScope" }), n.end = bt(n.end, { joinWith: "" });
  }
}
function O9(n) {
  n.scope && typeof n.scope == "object" && n.scope !== null && (n.beginScope = n.scope, delete n.scope);
}
function I9(n) {
  O9(n), typeof n.beginScope == "string" && (n.beginScope = { _wrap: n.beginScope }), typeof n.endScope == "string" && (n.endScope = { _wrap: n.endScope }), q9(n), L9(n);
}
function B9(n) {
  function e(i, o) {
    return new RegExp(
      Ze(i),
      "m" + (n.case_insensitive ? "i" : "") + (n.unicodeRegex ? "u" : "") + (o ? "g" : "")
    );
  }
  class t {
    constructor() {
      this.matchIndexes = {}, this.regexes = [], this.matchAt = 1, this.position = 0;
    }
    addRule(o, a) {
      a.position = this.position++, this.matchIndexes[this.matchAt] = a, this.regexes.push([a, o]), this.matchAt += Qr(o) + 1;
    }
    compile() {
      this.regexes.length === 0 && (this.exec = () => null);
      const o = this.regexes.map((a) => a[1]);
      this.matcherRe = e(bt(o, { joinWith: "|" }), !0), this.lastIndex = 0;
    }
    exec(o) {
      this.matcherRe.lastIndex = this.lastIndex;
      const a = this.matcherRe.exec(o);
      if (!a)
        return null;
      const l = a.findIndex((d, p) => p > 0 && d !== void 0), u = this.matchIndexes[l];
      return a.splice(0, l), Object.assign(a, u);
    }
  }
  class r {
    constructor() {
      this.rules = [], this.multiRegexes = [], this.count = 0, this.lastIndex = 0, this.regexIndex = 0;
    }
    getMatcher(o) {
      if (this.multiRegexes[o])
        return this.multiRegexes[o];
      const a = new t();
      return this.rules.slice(o).forEach(([l, u]) => a.addRule(l, u)), a.compile(), this.multiRegexes[o] = a, a;
    }
    resumingScanAtSamePosition() {
      return this.regexIndex !== 0;
    }
    considerAll() {
      this.regexIndex = 0;
    }
    addRule(o, a) {
      this.rules.push([o, a]), a.type === "begin" && this.count++;
    }
    exec(o) {
      const a = this.getMatcher(this.regexIndex);
      a.lastIndex = this.lastIndex;
      let l = a.exec(o);
      if (this.resumingScanAtSamePosition() && !(l && l.index === this.lastIndex)) {
        const u = this.getMatcher(0);
        u.lastIndex = this.lastIndex + 1, l = u.exec(o);
      }
      return l && (this.regexIndex += l.position + 1, this.regexIndex === this.count && this.considerAll()), l;
    }
  }
  function s(i) {
    const o = new r();
    return i.contains.forEach((a) => o.addRule(a.begin, { rule: a, type: "begin" })), i.terminatorEnd && o.addRule(i.terminatorEnd, { type: "end" }), i.illegal && o.addRule(i.illegal, { type: "illegal" }), o;
  }
  function c(i, o) {
    const a = i;
    if (i.isCompiled)
      return a;
    [
      E9,
      C9,
      I9,
      D9
    ].forEach((u) => u(i, o)), n.compilerExtensions.forEach((u) => u(i, o)), i.__beforeBegin = null, [
      w9,
      A9,
      S9
    ].forEach((u) => u(i, o)), i.isCompiled = !0;
    let l = null;
    return typeof i.keywords == "object" && i.keywords.$pattern && (i.keywords = Object.assign({}, i.keywords), l = i.keywords.$pattern, delete i.keywords.$pattern), l = l || /\w+/, i.keywords && (i.keywords = oo(i.keywords, n.case_insensitive)), a.keywordPatternRe = e(l, !0), o && (i.begin || (i.begin = /\B|\b/), a.beginRe = e(a.begin), !i.end && !i.endsWithParent && (i.end = /\B|\b/), i.end && (a.endRe = e(a.end)), a.terminatorEnd = Ze(a.end) || "", i.endsWithParent && o.terminatorEnd && (a.terminatorEnd += (i.end ? "|" : "") + o.terminatorEnd)), i.illegal && (a.illegalRe = e(i.illegal)), i.contains || (i.contains = []), i.contains = [].concat(...i.contains.map(function(u) {
      return F9(u === "self" ? i : u);
    })), i.contains.forEach(function(u) {
      c(u, a);
    }), i.starts && c(i.starts, o), a.matcher = s(a), a;
  }
  if (n.compilerExtensions || (n.compilerExtensions = []), n.contains && n.contains.includes("self"))
    throw new Error("ERR: contains `self` is not supported at the top-level of a language.  See documentation.");
  return n.classNameAliases = ve(n.classNameAliases || {}), c(n);
}
function co(n) {
  return n ? n.endsWithParent || co(n.starts) : !1;
}
function F9(n) {
  return n.variants && !n.cachedVariants && (n.cachedVariants = n.variants.map(function(e) {
    return ve(n, { variants: null }, e);
  })), n.cachedVariants ? n.cachedVariants : co(n) ? ve(n, { starts: n.starts ? ve(n.starts) : null }) : Object.isFrozen(n) ? ve(n) : n;
}
var $9 = "11.6.0";
class P9 extends Error {
  constructor(e, t) {
    super(e), this.name = "HTMLInjectionError", this.html = t;
  }
}
const Gn = Jr, hr = ve, dr = Symbol("nomatch"), z9 = 7, H9 = function(n) {
  const e = /* @__PURE__ */ Object.create(null), t = /* @__PURE__ */ Object.create(null), r = [];
  let s = !0;
  const c = "Could not find the language '{}', did you forget to load/include a language module?", i = { disableAutodetect: !0, name: "Plain text", contains: [] };
  let o = {
    ignoreUnescapedHTML: !1,
    throwUnescapedHTML: !1,
    noHighlightRe: /^(no-?highlight)$/i,
    languageDetectRe: /\blang(?:uage)?-([\w-]+)\b/i,
    classPrefix: "hljs-",
    cssSelector: "pre code",
    languages: null,
    __emitter: Q4
  };
  function a(f) {
    return o.noHighlightRe.test(f);
  }
  function l(f) {
    let b = f.className + " ";
    b += f.parentNode ? f.parentNode.className : "";
    const y = o.languageDetectRe.exec(b);
    if (y) {
      const T = V(y[1]);
      return T || (pr(c.replace("{}", y[1])), pr("Falling back to no-highlight mode for this block.", f)), T ? y[1] : "no-highlight";
    }
    return b.split(/\s+/).find((T) => a(T) || V(T));
  }
  function u(f, b, y) {
    let T = "", I = "";
    typeof b == "object" ? (T = f, y = b.ignoreIllegals, I = b.language) : (Le("10.7.0", "highlight(lang, code, ...args) has been deprecated."), Le("10.7.0", `Please use highlight(code, options) instead.
https://github.com/highlightjs/highlight.js/issues/2277`), I = f, T = b), y === void 0 && (y = !0);
    const Z = {
      code: T,
      language: I
    };
    k("before:highlight", Z);
    const J = Z.result ? Z.result : d(Z.language, Z.code, y);
    return J.code = Z.code, k("after:highlight", J), J;
  }
  function d(f, b, y, T) {
    const I = /* @__PURE__ */ Object.create(null);
    function Z(g, _) {
      return g.keywords[_];
    }
    function J() {
      if (!x.keywords) {
        $.addText(L);
        return;
      }
      let g = 0;
      x.keywordPatternRe.lastIndex = 0;
      let _ = x.keywordPatternRe.exec(L), E = "";
      for (; _; ) {
        E += L.substring(g, _.index);
        const M = Q.case_insensitive ? _[0].toLowerCase() : _[0], z = Z(x, M);
        if (z) {
          const [Y, Tn] = z;
          if ($.addText(E), E = "", I[M] = (I[M] || 0) + 1, I[M] <= z9 && (de += Tn), Y.startsWith("_"))
            E += _[0];
          else {
            const Mn = Q.classNameAliases[Y] || Y;
            $.addKeyword(_[0], Mn);
          }
        } else
          E += _[0];
        g = x.keywordPatternRe.lastIndex, _ = x.keywordPatternRe.exec(L);
      }
      E += L.substring(g), $.addText(E);
    }
    function pe() {
      if (L === "")
        return;
      let g = null;
      if (typeof x.subLanguage == "string") {
        if (!e[x.subLanguage]) {
          $.addText(L);
          return;
        }
        g = d(x.subLanguage, L, !0, He[x.subLanguage]), He[x.subLanguage] = g._top;
      } else
        g = h(L, x.subLanguage.length ? x.subLanguage : null);
      x.relevance > 0 && (de += g.relevance), $.addSublanguage(g._emitter, g.language);
    }
    function G() {
      x.subLanguage != null ? pe() : J(), L = "";
    }
    function X(g, _) {
      let E = 1;
      const M = _.length - 1;
      for (; E <= M; ) {
        if (!g._emit[E]) {
          E++;
          continue;
        }
        const z = Q.classNameAliases[g[E]] || g[E], Y = _[E];
        z ? $.addKeyword(Y, z) : (L = Y, J(), L = ""), E++;
      }
    }
    function $e(g, _) {
      return g.scope && typeof g.scope == "string" && $.openNode(Q.classNameAliases[g.scope] || g.scope), g.beginScope && (g.beginScope._wrap ? ($.addKeyword(L, Q.classNameAliases[g.beginScope._wrap] || g.beginScope._wrap), L = "") : g.beginScope._multi && (X(g.beginScope, _), L = "")), x = Object.create(g, { parent: { value: x } }), x;
    }
    function Pe(g, _, E) {
      let M = r9(g.endRe, E);
      if (M) {
        if (g["on:end"]) {
          const z = new ar(g);
          g["on:end"](_, z), z.isMatchIgnored && (M = !1);
        }
        if (M) {
          for (; g.endsParent && g.parent; )
            g = g.parent;
          return g;
        }
      }
      if (g.endsWithParent)
        return Pe(g.parent, _, E);
    }
    function An(g) {
      return x.matcher.regexIndex === 0 ? (L += g[0], 1) : (ye = !0, 0);
    }
    function Cn(g) {
      const _ = g[0], E = g.rule, M = new ar(E), z = [E.__beforeBegin, E["on:begin"]];
      for (const Y of z)
        if (Y && (Y(g, M), M.isMatchIgnored))
          return An(_);
      return E.skip ? L += _ : (E.excludeBegin && (L += _), G(), !E.returnBegin && !E.excludeBegin && (L = _)), $e(E, g), E.returnBegin ? 0 : _.length;
    }
    function Sn(g) {
      const _ = g[0], E = b.substring(g.index), M = Pe(x, g, E);
      if (!M)
        return dr;
      const z = x;
      x.endScope && x.endScope._wrap ? (G(), $.addKeyword(_, x.endScope._wrap)) : x.endScope && x.endScope._multi ? (G(), X(x.endScope, g)) : z.skip ? L += _ : (z.returnEnd || z.excludeEnd || (L += _), G(), z.excludeEnd && (L = _));
      do
        x.scope && $.closeNode(), !x.skip && !x.subLanguage && (de += x.relevance), x = x.parent;
      while (x !== M.parent);
      return M.starts && $e(M.starts, g), z.returnEnd ? 0 : _.length;
    }
    function Dn() {
      const g = [];
      for (let _ = x; _ !== Q; _ = _.parent)
        _.scope && g.unshift(_.scope);
      g.forEach((_) => $.openNode(_));
    }
    let he = {};
    function ze(g, _) {
      const E = _ && _[0];
      if (L += g, E == null)
        return G(), 0;
      if (he.type === "begin" && _.type === "end" && he.index === _.index && E === "") {
        if (L += b.slice(_.index, _.index + 1), !s) {
          const M = new Error(`0 width match regex (${f})`);
          throw M.languageName = f, M.badRule = he.rule, M;
        }
        return 1;
      }
      if (he = _, _.type === "begin")
        return Cn(_);
      if (_.type === "illegal" && !y) {
        const M = new Error('Illegal lexeme "' + E + '" for mode "' + (x.scope || "<unnamed>") + '"');
        throw M.mode = x, M;
      } else if (_.type === "end") {
        const M = Sn(_);
        if (M !== dr)
          return M;
      }
      if (_.type === "illegal" && E === "")
        return 1;
      if (ke > 1e5 && ke > _.index * 3)
        throw new Error("potential infinite loop, way more iterations than matches");
      return L += E, E.length;
    }
    const Q = V(f);
    if (!Q)
      throw Se(c.replace("{}", f)), new Error('Unknown language: "' + f + '"');
    const Rn = B9(Q);
    let xe = "", x = T || Rn;
    const He = {}, $ = new o.__emitter(o);
    Dn();
    let L = "", de = 0, ee = 0, ke = 0, ye = !1;
    try {
      for (x.matcher.considerAll(); ; ) {
        ke++, ye ? ye = !1 : x.matcher.considerAll(), x.matcher.lastIndex = ee;
        const g = x.matcher.exec(b);
        if (!g)
          break;
        const _ = b.substring(ee, g.index), E = ze(_, g);
        ee = g.index + E;
      }
      return ze(b.substring(ee)), $.closeAllNodes(), $.finalize(), xe = $.toHTML(), {
        language: f,
        value: xe,
        relevance: de,
        illegal: !1,
        _emitter: $,
        _top: x
      };
    } catch (g) {
      if (g.message && g.message.includes("Illegal"))
        return {
          language: f,
          value: Gn(b),
          illegal: !0,
          relevance: 0,
          _illegalBy: {
            message: g.message,
            index: ee,
            context: b.slice(ee - 100, ee + 100),
            mode: g.mode,
            resultSoFar: xe
          },
          _emitter: $
        };
      if (s)
        return {
          language: f,
          value: Gn(b),
          illegal: !1,
          relevance: 0,
          errorRaised: g,
          _emitter: $,
          _top: x
        };
      throw g;
    }
  }
  function p(f) {
    const b = {
      value: Gn(f),
      illegal: !1,
      relevance: 0,
      _top: i,
      _emitter: new o.__emitter(o)
    };
    return b._emitter.addText(f), b;
  }
  function h(f, b) {
    b = b || o.languages || Object.keys(e);
    const y = p(f), T = b.filter(V).filter(U).map(
      (G) => d(G, f, !1)
    );
    T.unshift(y);
    const I = T.sort((G, X) => {
      if (G.relevance !== X.relevance)
        return X.relevance - G.relevance;
      if (G.language && X.language) {
        if (V(G.language).supersetOf === X.language)
          return 1;
        if (V(X.language).supersetOf === G.language)
          return -1;
      }
      return 0;
    }), [Z, J] = I, pe = Z;
    return pe.secondBest = J, pe;
  }
  function m(f, b, y) {
    const T = b && t[b] || y;
    f.classList.add("hljs"), f.classList.add(`language-${T}`);
  }
  function v(f) {
    let b = null;
    const y = l(f);
    if (a(y))
      return;
    if (k(
      "before:highlightElement",
      { el: f, language: y }
    ), f.children.length > 0 && (o.ignoreUnescapedHTML || (console.warn("One of your code blocks includes unescaped HTML. This is a potentially serious security risk."), console.warn("https://github.com/highlightjs/highlight.js/wiki/security"), console.warn("The element with unescaped HTML:"), console.warn(f)), o.throwUnescapedHTML))
      throw new P9(
        "One of your code blocks includes unescaped HTML.",
        f.innerHTML
      );
    b = f;
    const T = b.textContent, I = y ? u(T, { language: y, ignoreIllegals: !0 }) : h(T);
    f.innerHTML = I.value, m(f, y, I.language), f.result = {
      language: I.language,
      re: I.relevance,
      relevance: I.relevance
    }, I.secondBest && (f.secondBest = {
      language: I.secondBest.language,
      relevance: I.secondBest.relevance
    }), k("after:highlightElement", { el: f, result: I, text: T });
  }
  function R(f) {
    o = hr(o, f);
  }
  const A = () => {
    N(), Le("10.6.0", "initHighlighting() deprecated.  Use highlightAll() now.");
  };
  function w() {
    N(), Le("10.6.0", "initHighlightingOnLoad() deprecated.  Use highlightAll() now.");
  }
  let S = !1;
  function N() {
    if (document.readyState === "loading") {
      S = !0;
      return;
    }
    document.querySelectorAll(o.cssSelector).forEach(v);
  }
  function O() {
    S && N();
  }
  typeof window < "u" && window.addEventListener && window.addEventListener("DOMContentLoaded", O, !1);
  function C(f, b) {
    let y = null;
    try {
      y = b(n);
    } catch (T) {
      if (Se("Language definition for '{}' could not be registered.".replace("{}", f)), s)
        Se(T);
      else
        throw T;
      y = i;
    }
    y.name || (y.name = f), e[f] = y, y.rawDefinition = b.bind(null, n), y.aliases && B(y.aliases, { languageName: f });
  }
  function P(f) {
    delete e[f];
    for (const b of Object.keys(t))
      t[b] === f && delete t[b];
  }
  function K() {
    return Object.keys(e);
  }
  function V(f) {
    return f = (f || "").toLowerCase(), e[f] || e[t[f]];
  }
  function B(f, { languageName: b }) {
    typeof f == "string" && (f = [f]), f.forEach((y) => {
      t[y.toLowerCase()] = b;
    });
  }
  function U(f) {
    const b = V(f);
    return b && !b.disableAutodetect;
  }
  function ce(f) {
    f["before:highlightBlock"] && !f["before:highlightElement"] && (f["before:highlightElement"] = (b) => {
      f["before:highlightBlock"](
        Object.assign({ block: b.el }, b)
      );
    }), f["after:highlightBlock"] && !f["after:highlightElement"] && (f["after:highlightElement"] = (b) => {
      f["after:highlightBlock"](
        Object.assign({ block: b.el }, b)
      );
    });
  }
  function re(f) {
    ce(f), r.push(f);
  }
  function k(f, b) {
    const y = f;
    r.forEach(function(T) {
      T[y] && T[y](b);
    });
  }
  function j(f) {
    return Le("10.7.0", "highlightBlock will be removed entirely in v12.0"), Le("10.7.0", "Please use highlightElement now."), v(f);
  }
  Object.assign(n, {
    highlight: u,
    highlightAuto: h,
    highlightAll: N,
    highlightElement: v,
    highlightBlock: j,
    configure: R,
    initHighlighting: A,
    initHighlightingOnLoad: w,
    registerLanguage: C,
    unregisterLanguage: P,
    listLanguages: K,
    getLanguage: V,
    registerAliases: B,
    autoDetection: U,
    inherit: hr,
    addPlugin: re
  }), n.debugMode = function() {
    s = !1;
  }, n.safeMode = function() {
    s = !0;
  }, n.versionString = $9, n.regex = {
    concat: Te,
    lookahead: Xr,
    either: gt,
    optional: n9,
    anyNumberOfTimes: e9
  };
  for (const f in tn)
    typeof tn[f] == "object" && pt.exports(tn[f]);
  return Object.assign(n, tn), n;
};
var We = H9({}), U9 = We;
We.HighlightJS = We;
We.default = We;
var gr = U9;
function br(n) {
  let e = vo(), t = n.subscribe((r) => {
    e.value = r;
  });
  return xo() && ko(t), e;
}
var _r;
const j9 = typeof window < "u";
j9 && ((_r = window == null ? void 0 : window.navigator) != null && _r.userAgent) && /iP(ad|hone|od)/.test(window.navigator.userAgent);
function G9(n) {
  return n;
}
const Jn = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {}, Xn = "__vueuse_ssr_handlers__";
Jn[Xn] = Jn[Xn] || {};
Jn[Xn];
var mr;
(function(n) {
  n.UP = "UP", n.RIGHT = "RIGHT", n.DOWN = "DOWN", n.LEFT = "LEFT", n.NONE = "NONE";
})(mr || (mr = {}));
function V9(n) {
  const e = be(n == null ? void 0 : n.element), t = be(n == null ? void 0 : n.input);
  function r() {
    var s, c;
    e.value && (e.value.style.height = "1px", e.value.style.height = `${(s = e.value) == null ? void 0 : s.scrollHeight}px`, (c = n == null ? void 0 : n.onResize) == null || c.call(n));
  }
  return mt([t, e], r, { immediate: !0 }), n != null && n.watch && mt(n.watch, r, { immediate: !0, deep: !0 }), {
    textarea: e,
    input: t,
    triggerResize: r
  };
}
var Z9 = Object.defineProperty, vr = Object.getOwnPropertySymbols, K9 = Object.prototype.hasOwnProperty, W9 = Object.prototype.propertyIsEnumerable, xr = (n, e, t) => e in n ? Z9(n, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : n[e] = t, Y9 = (n, e) => {
  for (var t in e || (e = {}))
    K9.call(e, t) && xr(n, t, e[t]);
  if (vr)
    for (var t of vr(e))
      W9.call(e, t) && xr(n, t, e[t]);
  return n;
};
const J9 = {
  easeInSine: [0.12, 0, 0.39, 0],
  easeOutSine: [0.61, 1, 0.88, 1],
  easeInOutSine: [0.37, 0, 0.63, 1],
  easeInQuad: [0.11, 0, 0.5, 0],
  easeOutQuad: [0.5, 1, 0.89, 1],
  easeInOutQuad: [0.45, 0, 0.55, 1],
  easeInCubic: [0.32, 0, 0.67, 0],
  easeOutCubic: [0.33, 1, 0.68, 1],
  easeInOutCubic: [0.65, 0, 0.35, 1],
  easeInQuart: [0.5, 0, 0.75, 0],
  easeOutQuart: [0.25, 1, 0.5, 1],
  easeInOutQuart: [0.76, 0, 0.24, 1],
  easeInQuint: [0.64, 0, 0.78, 0],
  easeOutQuint: [0.22, 1, 0.36, 1],
  easeInOutQuint: [0.83, 0, 0.17, 1],
  easeInExpo: [0.7, 0, 0.84, 0],
  easeOutExpo: [0.16, 1, 0.3, 1],
  easeInOutExpo: [0.87, 0, 0.13, 1],
  easeInCirc: [0.55, 0, 1, 0.45],
  easeOutCirc: [0, 0.55, 0.45, 1],
  easeInOutCirc: [0.85, 0, 0.15, 1],
  easeInBack: [0.36, 0, 0.66, -0.56],
  easeOutBack: [0.34, 1.56, 0.64, 1],
  easeInOutBack: [0.68, -0.6, 0.32, 1.6]
};
Y9({
  linear: G9
}, J9);
var X9 = (n, e) => {
  const t = n.__vccOpts || n;
  for (const [r, s] of e)
    t[r] = s;
  return t;
};
const Q9 = ["id"], eP = ["innerHTML"], nP = /* @__PURE__ */ ae({
  __name: "CodeEditor",
  props: {
    hljs: {
      type: Object,
      required: !0
    },
    code: {
      type: String,
      required: !0
    },
    lang: {
      type: String,
      required: !0
    },
    id: {
      type: String
    }
  },
  emits: ["edit"],
  setup(n, { emit: e }) {
    var t;
    const r = n, s = (t = r.id) != null ? t : `${+new Date()}`, c = be("0"), i = be(0), { textarea: o, input: a } = V9({
      onResize: l,
      watch: i
    });
    function l() {
      const p = window.getComputedStyle(o.value);
      c.value = p.height;
    }
    function u() {
      e("edit", a.value);
    }
    const d = Qn(() => (u(), r.hljs.highlight(a.value, { language: r.lang }).value));
    return pn(() => {
      a.value = r.code, yo(() => {
        ++i.value;
      });
    }), (p, h) => (D(), q("div", {
      class: "relative",
      style: Eo(`height:${c.value}`)
    }, [
      wo(F("textarea", {
        id: ne(s),
        class: "absolute top-0 left-0 z-30 w-full px-2 py-3 leading-6 text-transparent bg-transparent resize-none code-block",
        ref_key: "textarea",
        ref: o,
        "onUpdate:modelValue": h[0] || (h[0] = (m) => Ao(a) ? a.value = m : null),
        spellcheck: "false"
      }, `
      `, 8, Q9), [
        [Co, ne(a)]
      ]),
      F("code", {
        class: "absolute top-0 left-0 z-20 code-preview",
        innerHTML: ne(d)
      }, null, 8, eP)
    ], 4));
  }
});
var tP = /* @__PURE__ */ X9(nP, [["__scopeId", "data-v-646a99eb"]]);
const rP = ["viewBox"], oP = ["d"], Vn = /* @__PURE__ */ ae({
  __name: "AppIcon",
  props: {
    name: {
      type: String,
      required: !0
    }
  },
  setup(n) {
    const e = n, t = et({ path: "", viewbox: "" });
    function r(s) {
      let c = { viewbox: "0 0 512 512", path: "" };
      switch (s) {
        case "play":
          c.path = "M444.4 235.236L132.275 49.449A24 24 0 0 0 96 70.072v364.142a24.017 24.017 0 0 0 35.907 20.839L444.03 276.7a24 24 0 0 0 .367-41.461ZM128 420.429V84.144l288.244 171.574Z";
          break;
        case "pyconf":
          c.path = "M248.681 433.493v20.052h-52.74l-17.495-60.753c-12.178-3.106-24.257-7.747-36.04-14.079l-59.414 34.709l-35.357-35.358l32.122-60.013a156.965 156.965 0 0 1-14.572-34.737L0 265.607v-50.09l64.837-19.044c3.328-12.087 8.09-23.835 14.3-34.948L46.161 102.57L81.52 67.212l59.428 33.382c11.337-6.24 22.964-10.917 34.692-14.143l18.337-66.874h50.09l18.87 68.276a161.966 161.966 0 0 1 31.678 13.54l62.4-35.655l35.358 35.358l-35.475 62.993a154.339 154.339 0 0 1 11.742 27.753c-16.649.254-42.037 2.302-61.608 11.224c-20.91-51.65-85.056-77.912-138.003-47.388c-64.233 37.031-64.233 130.112 0 167.143c13.702 7.9 28.155 11.99 42.414 12.827c-2.42 60.593 5.868 79.325 37.24 97.845zm87.189-87.603c-22.256 0-41.008 19.116-41.008 40.778v29.99H272.29c-19.073 0-30.22-13.845-34.879-33.281c-6.293-26.105-6.026-41.705 0-66.708c5.229-21.82 21.93-33.28 41.003-33.28h90.27V272.1h-65.63v-25.819c0-18.94 5.046-25.46 32.82-30.362c21.441-3.59 43.298-3.551 65.558 0c17.815 2.965 32.821 16.326 32.821 34.116v62.495c0 18.335-14.57 33.354-32.82 33.354l-65.564.006zm17.449-101.901c0-11.69-12.551-19.035-22.537-13.19c-9.986 5.844-9.986 20.536 0 26.38c9.986 5.845 22.537-1.5 22.537-13.19zm154.06 145.006c-5.228 21.82-21.929 33.28-41.002 33.28h-90.27v10.216h65.63v26.892c0 18.94-5.046 25.461-32.82 30.362c-21.441 3.59-43.298 3.551-65.558 0c-17.815-2.965-32.821-16.325-32.821-34.116v-62.495c0-18.335 14.57-33.354 32.82-33.354l65.564-.006c22.256 0 41.008-19.115 41.008-40.778v-29.99h22.571c19.073 0 30.22 13.846 34.878 33.282c6.294 26.104 6.027 41.704 0 66.707zm-115.906 72.68c0 11.69 12.55 19.036 22.537 13.19c9.986-5.844 9.986-20.536 0-26.38c-9.986-5.845-22.537 1.5-22.537 13.19z";
          break;
        case "pytest":
          c.path = "m169.242 244.408l-84.89 141.594h132.332c-12.837-60.894 4.146-106.644 48.12-111.124l-18.582-30.47h-76.98zM302.005 61.813H275.91v125.878l23.883 37.448h-32l-19.868-30.392V61.813h-81.92v132.934L33.942 413.729h182.743v27.617H27.516c-26.369 0-34.163-13.204-21.746-34.336l132.25-219.32V61.814h-26.096c-19.52 0-19.52-27.617 0-27.617h190.081c19.52 0 19.52 27.617 0 27.617zm-6.837 329.95v29.946h-22.539c-19.046 0-30.176-13.825-34.829-33.234c-6.284-26.068-6.018-41.645 0-66.613c5.22-21.79 21.898-33.234 40.944-33.234h90.143v-11.273H303.35v-25.782c0-18.913 5.039-25.425 32.774-30.32c21.41-3.584 43.237-3.545 65.465 0c17.79 2.961 32.775 16.303 32.775 34.068v62.408c0 18.309-14.55 33.306-32.775 33.306l-65.47.006c-22.225 0-40.951 19.089-40.951 40.721zm58.375-142.479c0-11.673-12.533-19.008-22.505-13.172c-9.973 5.837-9.973 20.507 0 26.344c9.972 5.836 22.505-1.499 22.505-13.172zm96.475 74.901v-29.947h22.539c19.046 0 30.176 13.825 34.829 33.234c6.284 26.068 6.018 41.645 0 66.613c-5.22 21.79-21.898 33.234-40.944 33.234h-90.143v10.2h65.537v26.855c0 18.913-5.04 25.425-32.774 30.32c-21.41 3.584-43.237 3.545-65.465 0c-17.79-2.961-32.775-16.303-32.775-34.068v-62.408c0-18.309 14.55-33.306 32.775-33.306l65.47-.006c22.225 0 40.951-19.089 40.951-40.721zm-58.375 142.478c0 11.673 12.533 19.008 22.505 13.172c9.973-5.837 9.973-20.507 0-26.344c-9.972-5.837-22.505 1.499-22.505 13.172z";
          break;
        case "python":
          c.viewbox = "0 0 24 24", c.path = "M19.14 7.5A2.86 2.86 0 0 1 22 10.36v3.78A2.86 2.86 0 0 1 19.14 17H12c0 .39.32.96.71.96H17v1.68a2.86 2.86 0 0 1-2.86 2.86H9.86A2.86 2.86 0 0 1 7 19.64v-3.75a2.85 2.85 0 0 1 2.86-2.85h5.25a2.85 2.85 0 0 0 2.85-2.86V7.5h1.18m-4.28 11.79c-.4 0-.72.3-.72.89c0 .59.32.71.72.71a.71.71 0 0 0 .71-.71c0-.59-.32-.89-.71-.89m-10-1.79A2.86 2.86 0 0 1 2 14.64v-3.78A2.86 2.86 0 0 1 4.86 8H12c0-.39-.32-.96-.71-.96H7V5.36A2.86 2.86 0 0 1 9.86 2.5h4.28A2.86 2.86 0 0 1 17 5.36v3.75a2.85 2.85 0 0 1-2.86 2.85H8.89a2.85 2.85 0 0 0-2.85 2.86v2.68H4.86M9.14 5.71c.4 0 .72-.3.72-.89c0-.59-.32-.71-.72-.71c-.39 0-.71.12-.71.71s.32.89.71.89Z";
          break;
        default:
          throw new Error(`Unknown icon ${s}`);
      }
      return c;
    }
    return Er(() => {
      const s = r(e.name);
      t.viewbox = s.viewbox, t.path = s.path;
    }), (s, c) => (D(), q("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      width: "1em",
      height: "1em",
      preserveAspectRatio: "xMidYMid meet",
      viewBox: t.viewbox
    }, [
      F("path", {
        fill: "currentColor",
        d: t.path
      }, null, 8, oP)
    ], 8, rP));
  }
});
function sP(n) {
  const e = n.regex, t = /[\p{XID_Start}_]\p{XID_Continue}*/u, r = [
    "and",
    "as",
    "assert",
    "async",
    "await",
    "break",
    "case",
    "class",
    "continue",
    "def",
    "del",
    "elif",
    "else",
    "except",
    "finally",
    "for",
    "from",
    "global",
    "if",
    "import",
    "in",
    "is",
    "lambda",
    "match",
    "nonlocal|10",
    "not",
    "or",
    "pass",
    "raise",
    "return",
    "try",
    "while",
    "with",
    "yield"
  ], o = {
    $pattern: /[A-Za-z]\w+|__\w+__/,
    keyword: r,
    built_in: [
      "__import__",
      "abs",
      "all",
      "any",
      "ascii",
      "bin",
      "bool",
      "breakpoint",
      "bytearray",
      "bytes",
      "callable",
      "chr",
      "classmethod",
      "compile",
      "complex",
      "delattr",
      "dict",
      "dir",
      "divmod",
      "enumerate",
      "eval",
      "exec",
      "filter",
      "float",
      "format",
      "frozenset",
      "getattr",
      "globals",
      "hasattr",
      "hash",
      "help",
      "hex",
      "id",
      "input",
      "int",
      "isinstance",
      "issubclass",
      "iter",
      "len",
      "list",
      "locals",
      "map",
      "max",
      "memoryview",
      "min",
      "next",
      "object",
      "oct",
      "open",
      "ord",
      "pow",
      "print",
      "property",
      "range",
      "repr",
      "reversed",
      "round",
      "set",
      "setattr",
      "slice",
      "sorted",
      "staticmethod",
      "str",
      "sum",
      "super",
      "tuple",
      "type",
      "vars",
      "zip"
    ],
    literal: [
      "__debug__",
      "Ellipsis",
      "False",
      "None",
      "NotImplemented",
      "True"
    ],
    type: [
      "Any",
      "Callable",
      "Coroutine",
      "Dict",
      "List",
      "Literal",
      "Generic",
      "Optional",
      "Sequence",
      "Set",
      "Tuple",
      "Type",
      "Union"
    ]
  }, a = {
    className: "meta",
    begin: /^(>>>|\.\.\.) /
  }, l = {
    className: "subst",
    begin: /\{/,
    end: /\}/,
    keywords: o,
    illegal: /#/
  }, u = {
    begin: /\{\{/,
    relevance: 0
  }, d = {
    className: "string",
    contains: [n.BACKSLASH_ESCAPE],
    variants: [
      {
        begin: /([uU]|[bB]|[rR]|[bB][rR]|[rR][bB])?'''/,
        end: /'''/,
        contains: [
          n.BACKSLASH_ESCAPE,
          a
        ],
        relevance: 10
      },
      {
        begin: /([uU]|[bB]|[rR]|[bB][rR]|[rR][bB])?"""/,
        end: /"""/,
        contains: [
          n.BACKSLASH_ESCAPE,
          a
        ],
        relevance: 10
      },
      {
        begin: /([fF][rR]|[rR][fF]|[fF])'''/,
        end: /'''/,
        contains: [
          n.BACKSLASH_ESCAPE,
          a,
          u,
          l
        ]
      },
      {
        begin: /([fF][rR]|[rR][fF]|[fF])"""/,
        end: /"""/,
        contains: [
          n.BACKSLASH_ESCAPE,
          a,
          u,
          l
        ]
      },
      {
        begin: /([uU]|[rR])'/,
        end: /'/,
        relevance: 10
      },
      {
        begin: /([uU]|[rR])"/,
        end: /"/,
        relevance: 10
      },
      {
        begin: /([bB]|[bB][rR]|[rR][bB])'/,
        end: /'/
      },
      {
        begin: /([bB]|[bB][rR]|[rR][bB])"/,
        end: /"/
      },
      {
        begin: /([fF][rR]|[rR][fF]|[fF])'/,
        end: /'/,
        contains: [
          n.BACKSLASH_ESCAPE,
          u,
          l
        ]
      },
      {
        begin: /([fF][rR]|[rR][fF]|[fF])"/,
        end: /"/,
        contains: [
          n.BACKSLASH_ESCAPE,
          u,
          l
        ]
      },
      n.APOS_STRING_MODE,
      n.QUOTE_STRING_MODE
    ]
  }, p = "[0-9](_?[0-9])*", h = `(\\b(${p}))?\\.(${p})|\\b(${p})\\.`, m = `\\b|${r.join("|")}`, v = {
    className: "number",
    relevance: 0,
    variants: [
      {
        begin: `(\\b(${p})|(${h}))[eE][+-]?(${p})[jJ]?(?=${m})`
      },
      {
        begin: `(${h})[jJ]?`
      },
      {
        begin: `\\b([1-9](_?[0-9])*|0+(_?0)*)[lLjJ]?(?=${m})`
      },
      {
        begin: `\\b0[bB](_?[01])+[lL]?(?=${m})`
      },
      {
        begin: `\\b0[oO](_?[0-7])+[lL]?(?=${m})`
      },
      {
        begin: `\\b0[xX](_?[0-9a-fA-F])+[lL]?(?=${m})`
      },
      {
        begin: `\\b(${p})[jJ](?=${m})`
      }
    ]
  }, R = {
    className: "comment",
    begin: e.lookahead(/# type:/),
    end: /$/,
    keywords: o,
    contains: [
      {
        begin: /# type:/
      },
      {
        begin: /#/,
        end: /\b\B/,
        endsWithParent: !0
      }
    ]
  }, A = {
    className: "params",
    variants: [
      {
        className: "",
        begin: /\(\s*\)/,
        skip: !0
      },
      {
        begin: /\(/,
        end: /\)/,
        excludeBegin: !0,
        excludeEnd: !0,
        keywords: o,
        contains: [
          "self",
          a,
          v,
          d,
          n.HASH_COMMENT_MODE
        ]
      }
    ]
  };
  return l.contains = [
    d,
    v,
    a
  ], {
    name: "Python",
    aliases: [
      "py",
      "gyp",
      "ipython"
    ],
    unicodeRegex: !0,
    keywords: o,
    illegal: /(<\/|->|\?)|=>/,
    contains: [
      a,
      v,
      {
        begin: /\bself\b/
      },
      {
        beginKeywords: "if",
        relevance: 0
      },
      d,
      R,
      n.HASH_COMMENT_MODE,
      {
        match: [
          /\bdef/,
          /\s+/,
          t
        ],
        scope: {
          1: "keyword",
          3: "title.function"
        },
        contains: [A]
      },
      {
        variants: [
          {
            match: [
              /\bclass/,
              /\s+/,
              t,
              /\s*/,
              /\(\s*/,
              t,
              /\s*\)/
            ]
          },
          {
            match: [
              /\bclass/,
              /\s+/,
              t
            ]
          }
        ],
        scope: {
          1: "keyword",
          3: "title.class",
          6: "title.class.inherited"
        }
      },
      {
        className: "meta",
        begin: /^[\t ]*@/,
        end: /(?=#)|$/,
        contains: [
          v,
          A,
          d
        ]
      }
    ]
  };
}
var cP = (n, e) => {
  const t = n.__vccOpts || n;
  for (const [r, s] of e)
    t[r] = s;
  return t;
};
const iP = { class: "code-editor" }, aP = { key: 0 }, lP = /* @__PURE__ */ hn("  Execute "), uP = { class: "flex flex-col code-output" }, fP = { key: 0 }, pP = ["innerHTML"], hP = { key: 1 }, dP = ["innerHTML"], gP = ["innerHTML"], bP = ["innerHTML"], _P = /* @__PURE__ */ ae({
  __name: "PyCodeBlock",
  props: {
    id: {
      type: String,
      required: !0
    },
    py: {
      type: Object,
      required: !0
    },
    code: {
      type: String,
      required: !0
    },
    controls: {
      type: Boolean,
      default: !0
    },
    output: {
      type: Boolean,
      default: !0
    },
    exception: {
      type: Boolean,
      default: !0
    },
    stdout: {
      type: Boolean,
      default: !0
    },
    stderr: {
      type: Boolean,
      default: !0
    },
    dispatch: {
      type: Function
    }
  },
  emits: ["result"],
  setup(n, { emit: e }) {
    const t = n;
    gr.registerLanguage("python", sP);
    const r = be(""), s = be(null), c = br(t.py.isReady), i = et({
      id: "",
      stdOut: new Array(),
      stdErr: new Array(),
      exception: ""
    }), o = br(t.py.isExecuting);
    function a(p) {
      r.value = p;
    }
    async function l() {
      if (s.value = "", !u)
        return;
      const { results: p, error: h } = await t.py.run(r.value, t.id);
      if (p) {
        let m = "";
        if (p instanceof Map ? m = JSON.stringify(Object.fromEntries(p.entries()), null, "  ") : m = `${p}`, t.dispatch) {
          const v = await t.dispatch(m);
          v != null ? m = v : m = "";
        }
        s.value = m, e("result", s.value);
      }
    }
    const u = Qn(() => c.value == !0), d = t.py.log.listen((p) => {
      p.id == t.id && (i.id = p.id, i.stdOut = p.stdOut, i.stdErr = p.stdErr, i.exception = p.exception);
    });
    return bo(() => d()), pn(() => {
      r.value = t.code, s.value = "";
    }), (p, h) => (D(), q("div", null, [
      F("div", iP, [
        _e(ne(tP), {
          code: r.value,
          onKeyup: h[0] || (h[0] = _o(mo((m) => l(), ["ctrl"]), ["enter"])),
          lang: "python",
          onEdit: h[1] || (h[1] = (m) => a(m)),
          hljs: ne(gr)
        }, null, 8, ["code", "hljs"])
      ]),
      n.controls == !0 ? (D(), q("div", aP, [
        F("button", {
          class: Oe(["border code-exec-btn btn neuro", ne(u) && !ne(o) ? "cursor-pointer" : "cursor-wait"]),
          onClick: h[2] || (h[2] = (m) => l())
        }, [
          ne(u) ? (D(), q(oe, { key: 1 }, [
            ne(o) ? (D(), we(Vn, {
              key: 1,
              name: "python",
              class: "inline-block text-xl txt-danger"
            })) : (D(), we(Vn, {
              key: 0,
              name: "play",
              class: "inline-block text-xl txt-success"
            }))
          ], 64)) : (D(), we(Vn, {
            key: 0,
            name: "play",
            class: "inline-block text-xl txt-lighter"
          })),
          lP
        ], 2)
      ])) : W("", !0),
      F("div", uP, [
        n.stdout == !0 && s.value ? (D(), q("div", fP, [
          (D(!0), q(oe, null, ie(i.stdOut, (m) => (D(), q("pre", { innerHTML: m }, null, 8, pP))), 256))
        ])) : W("", !0),
        n.stderr == !0 ? (D(), q("div", hP, [
          (D(!0), q(oe, null, ie(i.stdErr, (m) => (D(), q("pre", { innerHTML: m }, null, 8, dP))), 256))
        ])) : W("", !0),
        n.exception == !0 && i.exception ? (D(), q("div", {
          key: 2,
          innerHTML: i.exception
        }, null, 8, gP)) : W("", !0),
        n.output == !0 && s.value ? (D(), q("div", {
          key: 3,
          innerHTML: s.value
        }, null, 8, bP)) : W("", !0)
      ])
    ]));
  }
});
var kr = /* @__PURE__ */ cP(_P, [["__scopeId", "data-v-e3645984"]]);
const mP = ["innerHTML"], yr = /* @__PURE__ */ ae({
  __name: "StaticPyCodeBlock",
  props: {
    code: {
      type: String,
      required: !0
    }
  },
  setup(n) {
    const e = n;
    ge.registerLanguage("python", ln), ge.registerLanguage("python", ln);
    const t = ge.highlight(e.code, { language: "python" }).value;
    return (r, s) => (D(), q("div", null, [
      F("pre", null, [
        F("code", {
          innerHTML: ne(t),
          style: { "white-space": "pre" }
        }, null, 8, mP)
      ])
    ]));
  }
}), Me = (n) => (wr("data-v-0150d756"), n = n(), Ar(), n), vP = { class: "prosed" }, xP = { key: 0 }, kP = ["innerHTML"], yP = { class: "py-2 mt-5 w-max" }, EP = ["innerHTML"], wP = { class: "mt-5 prosed" }, AP = ["innerHTML"], CP = { key: 1 }, SP = /* @__PURE__ */ Me(() => /* @__PURE__ */ F("h3", null, "Parameters", -1)), DP = { class: "mt-3 space-y-2" }, RP = ["innerHTML"], TP = /* @__PURE__ */ hn(), MP = ["innerHTML"], NP = /* @__PURE__ */ hn(": "), qP = ["innerHTML"], LP = {
  key: 2,
  class: "mt-5"
}, OP = /* @__PURE__ */ Me(() => /* @__PURE__ */ F("h3", null, "Returns", -1)), IP = { class: "mt-3" }, BP = ["innerHTML"], FP = {
  key: 3,
  class: "mt-5"
}, $P = /* @__PURE__ */ Me(() => /* @__PURE__ */ F("h3", null, "Raises", -1)), PP = { class: "mt-3" }, zP = ["innerHTML"], HP = /* @__PURE__ */ hn(": "), UP = ["innerHTML"], jP = {
  key: 0,
  class: "mt-5 prosed"
}, GP = {
  key: 0,
  class: "mt-3"
}, VP = /* @__PURE__ */ Me(() => /* @__PURE__ */ F("h2", null, "Executable example", -1)), ZP = {
  key: 1,
  class: "mt-3"
}, KP = /* @__PURE__ */ Me(() => /* @__PURE__ */ F("h2", null, "Example", -1)), WP = {
  key: 1,
  class: "mt-5 prosed"
}, YP = {
  key: 0,
  class: "mt-3"
}, JP = /* @__PURE__ */ Me(() => /* @__PURE__ */ F("h2", null, "Executable example", -1)), XP = {
  key: 1,
  class: "mt-3"
}, QP = /* @__PURE__ */ Me(() => /* @__PURE__ */ F("h2", null, "Example", -1)), e7 = /* @__PURE__ */ ae({
  __name: "RenderPyDocstring",
  props: {
    docstring: {
      type: Object,
      required: !0
    },
    title: {
      type: String,
      required: !0
    },
    py: {
      type: Object,
      required: !0
    },
    darkMode: {
      type: Boolean,
      default: !1
    }
  },
  setup(n) {
    const e = n;
    ge.registerLanguage("python", ln);
    const t = be("");
    function r() {
      t.value = ge.highlight(e.docstring.funcdef, { language: "python" }).value;
    }
    return pn(() => {
      r();
    }), (s, c) => {
      var i, o;
      return D(), q("div", null, [
        F("div", vP, [
          n.title ? (D(), q("h1", xP, rn(n.title), 1)) : W("", !0),
          So(s.$slots, "default", {}, void 0, !0),
          F("div", {
            innerHTML: n.docstring.description
          }, null, 8, kP)
        ]),
        F("pre", yP, [
          F("code", {
            innerHTML: t.value,
            style: { "white-space": "pre" }
          }, null, 8, EP)
        ]),
        F("div", wP, [
          n.docstring.long_description ? (D(), q("div", {
            key: 0,
            class: "mt-3",
            innerHTML: n.docstring.long_description
          }, null, 8, AP)) : W("", !0),
          Object.keys(n.docstring.params).length > 0 ? (D(), q("div", CP, [
            SP,
            F("ul", DP, [
              (D(!0), q(oe, null, ie(Object.keys(n.docstring.params), (a) => (D(), q("li", null, [
                F("kbd", {
                  class: "mr-1 font-bold",
                  innerHTML: a
                }, null, 8, RP),
                TP,
                F("span", {
                  class: "hljs-built_in",
                  innerHTML: n.docstring.params[a].type
                }, null, 8, MP),
                NP,
                F("span", {
                  innerHTML: n.docstring.params[a].description
                }, null, 8, qP)
              ]))), 256))
            ])
          ])) : W("", !0),
          (o = (i = n.docstring) == null ? void 0 : i.returns) != null && o.type ? (D(), q("div", LP, [
            OP,
            F("div", IP, [
              F("span", {
                class: "hljs-built_in",
                innerHTML: n.docstring.returns.type
              }, null, 8, BP)
            ])
          ])) : W("", !0),
          Object.keys(n.docstring.raises).length > 0 ? (D(), q("div", FP, [
            $P,
            (D(!0), q(oe, null, ie(n.docstring.raises, (a) => (D(), q("div", PP, [
              F("span", {
                class: "hljs-built_in",
                innerHTML: a.type
              }, null, 8, zP),
              HP,
              F("span", {
                innerHTML: a.description
              }, null, 8, UP)
            ]))), 256))
          ])) : W("", !0)
        ]),
        n.docstring.example ? (D(), q("div", jP, [
          n.docstring.example.is_executable ? (D(), q("div", GP, [
            VP,
            _e(ne(kr), {
              class: "not-prose",
              controls: !0,
              id: "example_0",
              py: n.py,
              code: n.docstring.example.code,
              theme: n.darkMode ? "dark" : "light",
              width: "52rem"
            }, null, 8, ["py", "code", "theme"])
          ])) : (D(), q("div", ZP, [
            KP,
            _e(yr, {
              class: "static-code not-prose",
              code: n.docstring.example.code
            }, null, 8, ["code"])
          ]))
        ])) : W("", !0),
        n.docstring.extra_examples ? (D(), q("div", WP, [
          (D(!0), q(oe, null, ie(n.docstring.extra_examples, (a) => (D(), q("div", null, [
            a.is_executable ? (D(), q("div", YP, [
              JP,
              _e(ne(kr), {
                class: "not-prose",
                controls: !0,
                id: "example_" + Date(),
                py: n.py,
                code: a.code,
                theme: n.darkMode ? "dark" : "light"
              }, null, 8, ["id", "py", "code", "theme"])
            ])) : (D(), q("div", XP, [
              QP,
              _e(yr, {
                class: "static-code not-prose",
                code: a.code
              }, null, 8, ["code"])
            ]))
          ]))), 256))
        ])) : W("", !0)
      ]);
    };
  }
});
const n7 = /* @__PURE__ */ Sr(e7, [["__scopeId", "data-v-0150d756"]]);
function t7(n) {
  const e = n.regex, t = {}, r = {
    begin: /\$\{/,
    end: /\}/,
    contains: [
      "self",
      {
        begin: /:-/,
        contains: [t]
      }
      // default values
    ]
  };
  Object.assign(t, {
    className: "variable",
    variants: [
      { begin: e.concat(
        /\$[\w\d#@][\w\d_]*/,
        // negative look-ahead tries to avoid matching patterns that are not
        // Perl at all like $ident$, @ident@, etc.
        "(?![\\w\\d])(?![$])"
      ) },
      r
    ]
  });
  const s = {
    className: "subst",
    begin: /\$\(/,
    end: /\)/,
    contains: [n.BACKSLASH_ESCAPE]
  }, c = {
    begin: /<<-?\s*(?=\w+)/,
    starts: { contains: [
      n.END_SAME_AS_BEGIN({
        begin: /(\w+)/,
        end: /(\w+)/,
        className: "string"
      })
    ] }
  }, i = {
    className: "string",
    begin: /"/,
    end: /"/,
    contains: [
      n.BACKSLASH_ESCAPE,
      t,
      s
    ]
  };
  s.contains.push(i);
  const o = {
    className: "",
    begin: /\\"/
  }, a = {
    className: "string",
    begin: /'/,
    end: /'/
  }, l = {
    begin: /\$\(\(/,
    end: /\)\)/,
    contains: [
      {
        begin: /\d+#[0-9a-f]+/,
        className: "number"
      },
      n.NUMBER_MODE,
      t
    ]
  }, u = [
    "fish",
    "bash",
    "zsh",
    "sh",
    "csh",
    "ksh",
    "tcsh",
    "dash",
    "scsh"
  ], d = n.SHEBANG({
    binary: `(${u.join("|")})`,
    relevance: 10
  }), p = {
    className: "function",
    begin: /\w[\w\d_]*\s*\(\s*\)\s*\{/,
    returnBegin: !0,
    contains: [n.inherit(n.TITLE_MODE, { begin: /\w[\w\d_]*/ })],
    relevance: 0
  }, h = [
    "if",
    "then",
    "else",
    "elif",
    "fi",
    "for",
    "while",
    "in",
    "do",
    "done",
    "case",
    "esac",
    "function"
  ], m = [
    "true",
    "false"
  ], v = { match: /(\/[a-z._-]+)+/ }, R = [
    "break",
    "cd",
    "continue",
    "eval",
    "exec",
    "exit",
    "export",
    "getopts",
    "hash",
    "pwd",
    "readonly",
    "return",
    "shift",
    "test",
    "times",
    "trap",
    "umask",
    "unset"
  ], A = [
    "alias",
    "bind",
    "builtin",
    "caller",
    "command",
    "declare",
    "echo",
    "enable",
    "help",
    "let",
    "local",
    "logout",
    "mapfile",
    "printf",
    "read",
    "readarray",
    "source",
    "type",
    "typeset",
    "ulimit",
    "unalias"
  ], w = [
    "autoload",
    "bg",
    "bindkey",
    "bye",
    "cap",
    "chdir",
    "clone",
    "comparguments",
    "compcall",
    "compctl",
    "compdescribe",
    "compfiles",
    "compgroups",
    "compquote",
    "comptags",
    "comptry",
    "compvalues",
    "dirs",
    "disable",
    "disown",
    "echotc",
    "echoti",
    "emulate",
    "fc",
    "fg",
    "float",
    "functions",
    "getcap",
    "getln",
    "history",
    "integer",
    "jobs",
    "kill",
    "limit",
    "log",
    "noglob",
    "popd",
    "print",
    "pushd",
    "pushln",
    "rehash",
    "sched",
    "setcap",
    "setopt",
    "stat",
    "suspend",
    "ttyctl",
    "unfunction",
    "unhash",
    "unlimit",
    "unsetopt",
    "vared",
    "wait",
    "whence",
    "where",
    "which",
    "zcompile",
    "zformat",
    "zftp",
    "zle",
    "zmodload",
    "zparseopts",
    "zprof",
    "zpty",
    "zregexparse",
    "zsocket",
    "zstyle",
    "ztcp"
  ], S = [
    "chcon",
    "chgrp",
    "chown",
    "chmod",
    "cp",
    "dd",
    "df",
    "dir",
    "dircolors",
    "ln",
    "ls",
    "mkdir",
    "mkfifo",
    "mknod",
    "mktemp",
    "mv",
    "realpath",
    "rm",
    "rmdir",
    "shred",
    "sync",
    "touch",
    "truncate",
    "vdir",
    "b2sum",
    "base32",
    "base64",
    "cat",
    "cksum",
    "comm",
    "csplit",
    "cut",
    "expand",
    "fmt",
    "fold",
    "head",
    "join",
    "md5sum",
    "nl",
    "numfmt",
    "od",
    "paste",
    "ptx",
    "pr",
    "sha1sum",
    "sha224sum",
    "sha256sum",
    "sha384sum",
    "sha512sum",
    "shuf",
    "sort",
    "split",
    "sum",
    "tac",
    "tail",
    "tr",
    "tsort",
    "unexpand",
    "uniq",
    "wc",
    "arch",
    "basename",
    "chroot",
    "date",
    "dirname",
    "du",
    "echo",
    "env",
    "expr",
    "factor",
    // "false", // keyword literal already
    "groups",
    "hostid",
    "id",
    "link",
    "logname",
    "nice",
    "nohup",
    "nproc",
    "pathchk",
    "pinky",
    "printenv",
    "printf",
    "pwd",
    "readlink",
    "runcon",
    "seq",
    "sleep",
    "stat",
    "stdbuf",
    "stty",
    "tee",
    "test",
    "timeout",
    // "true", // keyword literal already
    "tty",
    "uname",
    "unlink",
    "uptime",
    "users",
    "who",
    "whoami",
    "yes"
  ];
  return {
    name: "Bash",
    aliases: ["sh"],
    keywords: {
      $pattern: /\b[a-z][a-z0-9._-]+\b/,
      keyword: h,
      literal: m,
      built_in: [
        ...R,
        ...A,
        // Shell modifiers
        "set",
        "shopt",
        ...w,
        ...S
      ]
    },
    contains: [
      d,
      // to catch known shells and boost relevancy
      n.SHEBANG(),
      // to catch unknown shells but still highlight the shebang
      p,
      l,
      n.HASH_COMMENT_MODE,
      c,
      v,
      i,
      o,
      a,
      t
    ]
  };
}
const fn = "[A-Za-z$_][0-9A-Za-z$_]*", io = [
  "as",
  // for exports
  "in",
  "of",
  "if",
  "for",
  "while",
  "finally",
  "var",
  "new",
  "function",
  "do",
  "return",
  "void",
  "else",
  "break",
  "catch",
  "instanceof",
  "with",
  "throw",
  "case",
  "default",
  "try",
  "switch",
  "continue",
  "typeof",
  "delete",
  "let",
  "yield",
  "const",
  "class",
  // JS handles these with a special rule
  // "get",
  // "set",
  "debugger",
  "async",
  "await",
  "static",
  "import",
  "from",
  "export",
  "extends"
], ao = [
  "true",
  "false",
  "null",
  "undefined",
  "NaN",
  "Infinity"
], lo = [
  // Fundamental objects
  "Object",
  "Function",
  "Boolean",
  "Symbol",
  // numbers and dates
  "Math",
  "Date",
  "Number",
  "BigInt",
  // text
  "String",
  "RegExp",
  // Indexed collections
  "Array",
  "Float32Array",
  "Float64Array",
  "Int8Array",
  "Uint8Array",
  "Uint8ClampedArray",
  "Int16Array",
  "Int32Array",
  "Uint16Array",
  "Uint32Array",
  "BigInt64Array",
  "BigUint64Array",
  // Keyed collections
  "Set",
  "Map",
  "WeakSet",
  "WeakMap",
  // Structured data
  "ArrayBuffer",
  "SharedArrayBuffer",
  "Atomics",
  "DataView",
  "JSON",
  // Control abstraction objects
  "Promise",
  "Generator",
  "GeneratorFunction",
  "AsyncFunction",
  // Reflection
  "Reflect",
  "Proxy",
  // Internationalization
  "Intl",
  // WebAssembly
  "WebAssembly"
], uo = [
  "Error",
  "EvalError",
  "InternalError",
  "RangeError",
  "ReferenceError",
  "SyntaxError",
  "TypeError",
  "URIError"
], fo = [
  "setInterval",
  "setTimeout",
  "clearInterval",
  "clearTimeout",
  "require",
  "exports",
  "eval",
  "isFinite",
  "isNaN",
  "parseFloat",
  "parseInt",
  "decodeURI",
  "decodeURIComponent",
  "encodeURI",
  "encodeURIComponent",
  "escape",
  "unescape"
], po = [
  "arguments",
  "this",
  "super",
  "console",
  "window",
  "document",
  "localStorage",
  "module",
  "global"
  // Node.js
], ho = [].concat(
  fo,
  lo,
  uo
);
function r7(n) {
  const e = n.regex, t = (b, { after: y }) => {
    const T = "</" + b[0].slice(1);
    return b.input.indexOf(T, y) !== -1;
  }, r = fn, s = {
    begin: "<>",
    end: "</>"
  }, c = /<[A-Za-z0-9\\._:-]+\s*\/>/, i = {
    begin: /<[A-Za-z0-9\\._:-]+/,
    end: /\/[A-Za-z0-9\\._:-]+>|\/>/,
    /**
     * @param {RegExpMatchArray} match
     * @param {CallbackResponse} response
     */
    isTrulyOpeningTag: (b, y) => {
      const T = b[0].length + b.index, I = b.input[T];
      if (
        // HTML should not include another raw `<` inside a tag
        // nested type?
        // `<Array<Array<number>>`, etc.
        I === "<" || // the , gives away that this is not HTML
        // `<T, A extends keyof T, V>`
        I === ","
      ) {
        y.ignoreMatch();
        return;
      }
      I === ">" && (t(b, { after: T }) || y.ignoreMatch());
      let Z;
      if ((Z = b.input.substring(T).match(/^\s+extends\s+/)) && Z.index === 0) {
        y.ignoreMatch();
        return;
      }
    }
  }, o = {
    $pattern: fn,
    keyword: io,
    literal: ao,
    built_in: ho,
    "variable.language": po
  }, a = "[0-9](_?[0-9])*", l = `\\.(${a})`, u = "0|[1-9](_?[0-9])*|0[0-7]*[89][0-9]*", d = {
    className: "number",
    variants: [
      // DecimalLiteral
      { begin: `(\\b(${u})((${l})|\\.)?|(${l}))[eE][+-]?(${a})\\b` },
      { begin: `\\b(${u})\\b((${l})\\b|\\.)?|(${l})\\b` },
      // DecimalBigIntegerLiteral
      { begin: "\\b(0|[1-9](_?[0-9])*)n\\b" },
      // NonDecimalIntegerLiteral
      { begin: "\\b0[xX][0-9a-fA-F](_?[0-9a-fA-F])*n?\\b" },
      { begin: "\\b0[bB][0-1](_?[0-1])*n?\\b" },
      { begin: "\\b0[oO][0-7](_?[0-7])*n?\\b" },
      // LegacyOctalIntegerLiteral (does not include underscore separators)
      // https://tc39.es/ecma262/#sec-additional-syntax-numeric-literals
      { begin: "\\b0[0-7]+n?\\b" }
    ],
    relevance: 0
  }, p = {
    className: "subst",
    begin: "\\$\\{",
    end: "\\}",
    keywords: o,
    contains: []
    // defined later
  }, h = {
    begin: "html`",
    end: "",
    starts: {
      end: "`",
      returnEnd: !1,
      contains: [
        n.BACKSLASH_ESCAPE,
        p
      ],
      subLanguage: "xml"
    }
  }, m = {
    begin: "css`",
    end: "",
    starts: {
      end: "`",
      returnEnd: !1,
      contains: [
        n.BACKSLASH_ESCAPE,
        p
      ],
      subLanguage: "css"
    }
  }, v = {
    className: "string",
    begin: "`",
    end: "`",
    contains: [
      n.BACKSLASH_ESCAPE,
      p
    ]
  }, A = {
    className: "comment",
    variants: [
      n.COMMENT(
        /\/\*\*(?!\/)/,
        "\\*/",
        {
          relevance: 0,
          contains: [
            {
              begin: "(?=@[A-Za-z]+)",
              relevance: 0,
              contains: [
                {
                  className: "doctag",
                  begin: "@[A-Za-z]+"
                },
                {
                  className: "type",
                  begin: "\\{",
                  end: "\\}",
                  excludeEnd: !0,
                  excludeBegin: !0,
                  relevance: 0
                },
                {
                  className: "variable",
                  begin: r + "(?=\\s*(-)|$)",
                  endsParent: !0,
                  relevance: 0
                },
                // eat spaces (not newlines) so we can find
                // types or variables
                {
                  begin: /(?=[^\n])\s/,
                  relevance: 0
                }
              ]
            }
          ]
        }
      ),
      n.C_BLOCK_COMMENT_MODE,
      n.C_LINE_COMMENT_MODE
    ]
  }, w = [
    n.APOS_STRING_MODE,
    n.QUOTE_STRING_MODE,
    h,
    m,
    v,
    d
    // This is intentional:
    // See https://github.com/highlightjs/highlight.js/issues/3288
    // hljs.REGEXP_MODE
  ];
  p.contains = w.concat({
    // we need to pair up {} inside our subst to prevent
    // it from ending too early by matching another }
    begin: /\{/,
    end: /\}/,
    keywords: o,
    contains: [
      "self"
    ].concat(w)
  });
  const S = [].concat(A, p.contains), N = S.concat([
    // eat recursive parens in sub expressions
    {
      begin: /\(/,
      end: /\)/,
      keywords: o,
      contains: ["self"].concat(S)
    }
  ]), O = {
    className: "params",
    begin: /\(/,
    end: /\)/,
    excludeBegin: !0,
    excludeEnd: !0,
    keywords: o,
    contains: N
  }, C = {
    variants: [
      // class Car extends vehicle
      {
        match: [
          /class/,
          /\s+/,
          r,
          /\s+/,
          /extends/,
          /\s+/,
          e.concat(r, "(", e.concat(/\./, r), ")*")
        ],
        scope: {
          1: "keyword",
          3: "title.class",
          5: "keyword",
          7: "title.class.inherited"
        }
      },
      // class Car
      {
        match: [
          /class/,
          /\s+/,
          r
        ],
        scope: {
          1: "keyword",
          3: "title.class"
        }
      }
    ]
  }, P = {
    relevance: 0,
    match: e.either(
      // Hard coded exceptions
      /\bJSON/,
      // Float32Array, OutT
      /\b[A-Z][a-z]+([A-Z][a-z]*|\d)*/,
      // CSSFactory, CSSFactoryT
      /\b[A-Z]{2,}([A-Z][a-z]+|\d)+([A-Z][a-z]*)*/,
      // FPs, FPsT
      /\b[A-Z]{2,}[a-z]+([A-Z][a-z]+|\d)*([A-Z][a-z]*)*/
      // P
      // single letters are not highlighted
      // BLAH
      // this will be flagged as a UPPER_CASE_CONSTANT instead
    ),
    className: "title.class",
    keywords: {
      _: [
        // se we still get relevance credit for JS library classes
        ...lo,
        ...uo
      ]
    }
  }, K = {
    label: "use_strict",
    className: "meta",
    relevance: 10,
    begin: /^\s*['"]use (strict|asm)['"]/
  }, V = {
    variants: [
      {
        match: [
          /function/,
          /\s+/,
          r,
          /(?=\s*\()/
        ]
      },
      // anonymous function
      {
        match: [
          /function/,
          /\s*(?=\()/
        ]
      }
    ],
    className: {
      1: "keyword",
      3: "title.function"
    },
    label: "func.def",
    contains: [O],
    illegal: /%/
  }, B = {
    relevance: 0,
    match: /\b[A-Z][A-Z_0-9]+\b/,
    className: "variable.constant"
  };
  function U(b) {
    return e.concat("(?!", b.join("|"), ")");
  }
  const ce = {
    match: e.concat(
      /\b/,
      U([
        ...fo,
        "super"
      ]),
      r,
      e.lookahead(/\(/)
    ),
    className: "title.function",
    relevance: 0
  }, re = {
    begin: e.concat(/\./, e.lookahead(
      e.concat(r, /(?![0-9A-Za-z$_(])/)
    )),
    end: r,
    excludeBegin: !0,
    keywords: "prototype",
    className: "property",
    relevance: 0
  }, k = {
    match: [
      /get|set/,
      /\s+/,
      r,
      /(?=\()/
    ],
    className: {
      1: "keyword",
      3: "title.function"
    },
    contains: [
      {
        // eat to avoid empty params
        begin: /\(\)/
      },
      O
    ]
  }, j = "(\\([^()]*(\\([^()]*(\\([^()]*\\)[^()]*)*\\)[^()]*)*\\)|" + n.UNDERSCORE_IDENT_RE + ")\\s*=>", f = {
    match: [
      /const|var|let/,
      /\s+/,
      r,
      /\s*/,
      /=\s*/,
      /(async\s*)?/,
      // async is optional
      e.lookahead(j)
    ],
    keywords: "async",
    className: {
      1: "keyword",
      3: "title.function"
    },
    contains: [
      O
    ]
  };
  return {
    name: "Javascript",
    aliases: ["js", "jsx", "mjs", "cjs"],
    keywords: o,
    // this will be extended by TypeScript
    exports: { PARAMS_CONTAINS: N, CLASS_REFERENCE: P },
    illegal: /#(?![$_A-z])/,
    contains: [
      n.SHEBANG({
        label: "shebang",
        binary: "node",
        relevance: 5
      }),
      K,
      n.APOS_STRING_MODE,
      n.QUOTE_STRING_MODE,
      h,
      m,
      v,
      A,
      d,
      P,
      {
        className: "attr",
        begin: r + e.lookahead(":"),
        relevance: 0
      },
      f,
      {
        // "value" container
        begin: "(" + n.RE_STARTERS_RE + "|\\b(case|return|throw)\\b)\\s*",
        keywords: "return throw case",
        relevance: 0,
        contains: [
          A,
          n.REGEXP_MODE,
          {
            className: "function",
            // we have to count the parens to make sure we actually have the
            // correct bounding ( ) before the =>.  There could be any number of
            // sub-expressions inside also surrounded by parens.
            begin: j,
            returnBegin: !0,
            end: "\\s*=>",
            contains: [
              {
                className: "params",
                variants: [
                  {
                    begin: n.UNDERSCORE_IDENT_RE,
                    relevance: 0
                  },
                  {
                    className: null,
                    begin: /\(\s*\)/,
                    skip: !0
                  },
                  {
                    begin: /\(/,
                    end: /\)/,
                    excludeBegin: !0,
                    excludeEnd: !0,
                    keywords: o,
                    contains: N
                  }
                ]
              }
            ]
          },
          {
            // could be a comma delimited list of params to a function call
            begin: /,/,
            relevance: 0
          },
          {
            match: /\s+/,
            relevance: 0
          },
          {
            // JSX
            variants: [
              { begin: s.begin, end: s.end },
              { match: c },
              {
                begin: i.begin,
                // we carefully check the opening tag to see if it truly
                // is a tag and not a false positive
                "on:begin": i.isTrulyOpeningTag,
                end: i.end
              }
            ],
            subLanguage: "xml",
            contains: [
              {
                begin: i.begin,
                end: i.end,
                skip: !0,
                contains: ["self"]
              }
            ]
          }
        ]
      },
      V,
      {
        // prevent this from getting swallowed up by function
        // since they appear "function like"
        beginKeywords: "while if switch catch for"
      },
      {
        // we have to count the parens to make sure we actually have the correct
        // bounding ( ).  There could be any number of sub-expressions inside
        // also surrounded by parens.
        begin: "\\b(?!function)" + n.UNDERSCORE_IDENT_RE + "\\([^()]*(\\([^()]*(\\([^()]*\\)[^()]*)*\\)[^()]*)*\\)\\s*\\{",
        // end parens
        returnBegin: !0,
        label: "func.def",
        contains: [
          O,
          n.inherit(n.TITLE_MODE, { begin: r, className: "title.function" })
        ]
      },
      // catch ... so it won't trigger the property rule below
      {
        match: /\.\.\./,
        relevance: 0
      },
      re,
      // hack: prevents detection of keywords in some circumstances
      // .keyword()
      // $keyword = x
      {
        match: "\\$" + r,
        relevance: 0
      },
      {
        match: [/\bconstructor(?=\s*\()/],
        className: { 1: "title.function" },
        contains: [O]
      },
      ce,
      B,
      C,
      k,
      {
        match: /\$[(.]/
        // relevance booster for a pattern common to JS libs: `$(something)` and `$.something`
      }
    ]
  };
}
function o7(n) {
  const e = r7(n), t = fn, r = [
    "any",
    "void",
    "number",
    "boolean",
    "string",
    "object",
    "never",
    "symbol",
    "bigint",
    "unknown"
  ], s = {
    beginKeywords: "namespace",
    end: /\{/,
    excludeEnd: !0,
    contains: [e.exports.CLASS_REFERENCE]
  }, c = {
    beginKeywords: "interface",
    end: /\{/,
    excludeEnd: !0,
    keywords: {
      keyword: "interface extends",
      built_in: r
    },
    contains: [e.exports.CLASS_REFERENCE]
  }, i = {
    className: "meta",
    relevance: 10,
    begin: /^\s*['"]use strict['"]/
  }, o = [
    "type",
    "namespace",
    "interface",
    "public",
    "private",
    "protected",
    "implements",
    "declare",
    "abstract",
    "readonly",
    "enum",
    "override"
  ], a = {
    $pattern: fn,
    keyword: io.concat(o),
    literal: ao,
    built_in: ho.concat(r),
    "variable.language": po
  }, l = {
    className: "meta",
    begin: "@" + t
  }, u = (p, h, m) => {
    const v = p.contains.findIndex((R) => R.label === h);
    if (v === -1)
      throw new Error("can not find mode to replace");
    p.contains.splice(v, 1, m);
  };
  Object.assign(e.keywords, a), e.exports.PARAMS_CONTAINS.push(l), e.contains = e.contains.concat([
    l,
    s,
    c
  ]), u(e, "shebang", n.SHEBANG()), u(e, "use_strict", i);
  const d = e.contains.find((p) => p.label === "func.def");
  return d.relevance = 0, Object.assign(e, {
    name: "TypeScript",
    aliases: [
      "ts",
      "tsx"
    ]
  }), e;
}
const s7 = { class: "max-w-[105ch]" }, Zn = /* @__PURE__ */ ae({
  __name: "RenderMdPy",
  props: {
    code: {
      type: String,
      required: !0
    }
  },
  setup(n) {
    return ge.registerLanguage("python", ln), ge.registerLanguage("typescript", o7), ge.registerLanguage("bash", t7), (e, t) => (D(), q("div", s7, [
      _e(e4, {
        source: n.code,
        hljs: ne(ge)
      }, null, 8, ["source", "hljs"])
    ]));
  }
}), c7 = { key: 0 }, d7 = /* @__PURE__ */ ae({
  __name: "DispatchRoutePy",
  props: {
    nav: {
      type: Object,
      required: !0
    },
    py: {
      type: Object,
      required: !0
    },
    url: {
      type: String,
      required: !0
    }
  },
  setup(n) {
    const e = n, t = et({ data: {} }), r = be(!1);
    return pn(async () => {
      r.value = !1, t.data = await e.nav.loadFromRoutePath(e.url), r.value = !0;
    }), (s, c) => {
      var i;
      return r.value ? (D(), q("div", c7, [
        t.data.hasDocstring === !0 ? (D(), we(n7, {
          key: 0,
          py: n.py,
          class: "max-w-[105ch]",
          docstring: t.data.docstring,
          title: t.data.name
        }, {
          default: Do(() => {
            var o;
            return [
              (o = t.data.docstring.extra_md) != null && o.header ? (D(), we(Zn, {
                key: 0,
                code: t.data.docstring.extra_md.header,
                class: Oe(t.data.hasDocstring ? "mb-3" : "")
              }, null, 8, ["code", "class"])) : W("", !0)
            ];
          }),
          _: 1
        }, 8, ["py", "docstring", "title"])) : W("", !0),
        (i = t.data.docstring) != null && i.extra_md ? (D(), we(Zn, {
          key: 1,
          code: t.data.docstring.extra_md.footer,
          class: Oe(t.data.hasDocstring ? "mt-5" : "")
        }, null, 8, ["code", "class"])) : W("", !0),
        t.data.hasMarkdown ? (D(), we(Zn, {
          key: 2,
          code: t.data.markdown
        }, null, 8, ["code"])) : W("", !0)
      ])) : W("", !0);
    };
  }
});
export {
  a7 as AutoNav,
  Go as AutoNavNode,
  d7 as DispatchRoutePy,
  e4 as RenderMd,
  Zn as RenderMdPy,
  l7 as RenderNavNode,
  n7 as RenderPyDocstring,
  yr as StaticPyCodeBlock
};
