/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

/*! js-cookie v3.0.1 | MIT */
/* eslint-disable no-var */
function assign (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];
    for (var key in source) {
      target[key] = source[key];
    }
  }
  return target
}
/* eslint-enable no-var */

/* eslint-disable no-var */
var defaultConverter = {
  read: function (value) {
    if (value[0] === '"') {
      value = value.slice(1, -1);
    }
    return value.replace(/(%[\dA-F]{2})+/gi, decodeURIComponent)
  },
  write: function (value) {
    return encodeURIComponent(value).replace(
      /%(2[346BF]|3[AC-F]|40|5[BDE]|60|7[BCD])/g,
      decodeURIComponent
    )
  }
};
/* eslint-enable no-var */

/* eslint-disable no-var */

function init (converter, defaultAttributes) {
  function set (key, value, attributes) {
    if (typeof document === 'undefined') {
      return
    }

    attributes = assign({}, defaultAttributes, attributes);

    if (typeof attributes.expires === 'number') {
      attributes.expires = new Date(Date.now() + attributes.expires * 864e5);
    }
    if (attributes.expires) {
      attributes.expires = attributes.expires.toUTCString();
    }

    key = encodeURIComponent(key)
      .replace(/%(2[346B]|5E|60|7C)/g, decodeURIComponent)
      .replace(/[()]/g, escape);

    var stringifiedAttributes = '';
    for (var attributeName in attributes) {
      if (!attributes[attributeName]) {
        continue
      }

      stringifiedAttributes += '; ' + attributeName;

      if (attributes[attributeName] === true) {
        continue
      }

      // Considers RFC 6265 section 5.2:
      // ...
      // 3.  If the remaining unparsed-attributes contains a %x3B (";")
      //     character:
      // Consume the characters of the unparsed-attributes up to,
      // not including, the first %x3B (";") character.
      // ...
      stringifiedAttributes += '=' + attributes[attributeName].split(';')[0];
    }

    return (document.cookie =
      key + '=' + converter.write(value, key) + stringifiedAttributes)
  }

  function get (key) {
    if (typeof document === 'undefined' || (arguments.length && !key)) {
      return
    }

    // To prevent the for loop in the first place assign an empty array
    // in case there are no cookies at all.
    var cookies = document.cookie ? document.cookie.split('; ') : [];
    var jar = {};
    for (var i = 0; i < cookies.length; i++) {
      var parts = cookies[i].split('=');
      var value = parts.slice(1).join('=');

      try {
        var foundKey = decodeURIComponent(parts[0]);
        jar[foundKey] = converter.read(value, foundKey);

        if (key === foundKey) {
          break
        }
      } catch (e) {}
    }

    return key ? jar[key] : jar
  }

  return Object.create(
    {
      set: set,
      get: get,
      remove: function (key, attributes) {
        set(
          key,
          '',
          assign({}, attributes, {
            expires: -1
          })
        );
      },
      withAttributes: function (attributes) {
        return init(this.converter, assign({}, this.attributes, attributes))
      },
      withConverter: function (converter) {
        return init(assign({}, this.converter, converter), this.attributes)
      }
    },
    {
      attributes: { value: Object.freeze(defaultAttributes) },
      converter: { value: Object.freeze(converter) }
    }
  )
}

var api = init(defaultConverter, { path: '/' });

const useApi = (params = {
    serverUrl: "",
    csrfCookieName: "csrftoken",
    csrfHeaderKey: "X-CSRFToken",
    credentials: "include",
    mode: "cors",
}) => {
    var _a, _b, _c, _d, _e;
    let _serverUrl = (_a = params.serverUrl) !== null && _a !== void 0 ? _a : "";
    let _csrfCookieName = (_b = params === null || params === void 0 ? void 0 : params.csrfCookieName) !== null && _b !== void 0 ? _b : "csrftoken";
    let _csrfHeaderKey = (_c = params === null || params === void 0 ? void 0 : params.csrfHeaderKey) !== null && _c !== void 0 ? _c : "X-CSRFToken";
    let _mode = (_d = params === null || params === void 0 ? void 0 : params.mode) !== null && _d !== void 0 ? _d : "cors";
    let _credentials = (_e = params.credentials) !== null && _e !== void 0 ? _e : "include";
    let _csrfToken = null;
    let _extraHeaders = {};
    let _hasExtraHeaders = false;
    let _onResponse;
    const csrfToken = () => _csrfToken;
    const hasCsrfCookie = () => {
        const cookie = api.get(_csrfCookieName);
        if (cookie) {
            return true;
        }
        return false;
    };
    const _csrfFromCookie = () => {
        const c = api.get(_csrfCookieName);
        if (!c) {
            throw ("Csrf cookie not found");
        }
        return c;
    };
    const addHeader = (key, val) => {
        _extraHeaders[key] = val;
        _hasExtraHeaders = true;
    };
    const removeHeader = (key) => {
        delete _extraHeaders[key];
        if (Object.keys(_extraHeaders).length == 0) {
            _hasExtraHeaders = false;
        }
    };
    const onResponse = (hook) => {
        _onResponse = hook;
    };
    const setCsrfToken = (token) => {
        _csrfToken = token;
    };
    const setCsrfTokenFromCookie = (verbose = false) => {
        if (hasCsrfCookie()) {
            _csrfToken = _csrfFromCookie();
            if (verbose) {
                console.log("User logged in with csrf cookie, setting api token", _csrfToken);
            }
            return true;
        }
        else {
            if (verbose) {
                console.log("User does not have csrf cookie");
            }
        }
        return false;
    };
    const _processResponse = (response) => __awaiter(void 0, void 0, void 0, function* () {
        var _f;
        const head = {};
        response.headers.forEach((v, k) => head[k] = v);
        let apiResp = {
            ok: response.ok,
            url: response.url,
            headers: head,
            status: response.status,
            statusText: response.statusText,
            data: {},
            text: "",
        };
        if (!(response.status == 204)) {
            if (!((_f = response.headers.get("Content-Type")) === null || _f === void 0 ? void 0 : _f.startsWith("application/json"))) {
                const txt = yield response.text();
                apiResp.text = txt;
            }
            else {
                try {
                    apiResp.data = (yield response.json());
                }
                catch (e) {
                    console.warn(`Json parsing error: ${e}`);
                }
            }
        }
        if (_onResponse) {
            apiResp = yield _onResponse(apiResp);
        }
        return apiResp;
    });
    const post = (uri, payload, multipart = false, verbose = false) => __awaiter(void 0, void 0, void 0, function* () {
        const opts = _postHeader(payload, "post", multipart);
        let url = _serverUrl + uri;
        if (verbose) {
            console.log("POST", url);
            console.log(JSON.stringify(opts, null, "  "));
        }
        const response = yield fetch(url, opts);
        return yield _processResponse(response);
    });
    const patch = (uri, payload, verbose = false) => __awaiter(void 0, void 0, void 0, function* () {
        const opts = _postHeader(payload, "patch");
        let url = _serverUrl + uri;
        if (verbose) {
            console.log("PATCH", url);
            console.log(JSON.stringify(opts, null, "  "));
        }
        const response = yield fetch(url, opts);
        return yield _processResponse(response);
    });
    const put = (uri, payload, verbose = false) => __awaiter(void 0, void 0, void 0, function* () {
        let url = _serverUrl + uri;
        const opts = _postHeader(payload, "put");
        if (verbose) {
            console.log("PUT", url);
            console.log(JSON.stringify(opts, null, "  "));
        }
        const response = yield fetch(url, opts);
        return yield _processResponse(response);
    });
    const get = (uri, verbose = false) => __awaiter(void 0, void 0, void 0, function* () {
        let url = _serverUrl + uri;
        const opts = _getHeader("get");
        if (verbose) {
            console.log("GET", url);
            console.log(JSON.stringify(opts, null, "  "));
        }
        const response = yield fetch(url, opts);
        return yield _processResponse(response);
    });
    const del = (uri, verbose = false) => __awaiter(void 0, void 0, void 0, function* () {
        const url = _serverUrl + uri;
        const opts = _getHeader("delete");
        if (verbose) {
            console.log("DELETE", url);
            console.log(JSON.stringify(opts, null, "  "));
        }
        const response = yield fetch(url, opts);
        return yield _processResponse(response);
    });
    const _getHeader = (method = "get") => {
        const h = {
            method: method,
            mode: _mode,
        };
        if (_credentials !== null) {
            h.credentials = _credentials;
        }
        const headers = { "Content-Type": "application/json" };
        h.headers = _getBaseHeaders(headers);
        return h;
    };
    const _postHeader = (payload, method = "post", multipart = false) => {
        const pl = multipart ? payload : JSON.stringify(payload);
        const r = {
            method: method,
            mode: _mode,
            body: pl
        };
        let headers;
        if (!multipart) {
            headers = { "Content-Type": "application/json" };
        }
        else {
            headers = { "Content-Type": "multipart/form-data" };
        }
        if (_credentials !== null) {
            r.credentials = _credentials;
        }
        r.headers = _getBaseHeaders(headers);
        return r;
    };
    function _getBaseHeaders(headers) {
        if (_csrfToken !== null) {
            headers[_csrfHeaderKey] = _csrfToken;
        }
        if (_hasExtraHeaders) {
            for (const [k, v] of Object.entries(_extraHeaders)) {
                headers[k] = v;
            }
        }
        return headers;
    }
    return {
        csrfToken,
        hasCsrfCookie,
        setCsrfToken,
        setCsrfTokenFromCookie,
        addHeader,
        removeHeader,
        onResponse,
        get,
        post,
        put,
        patch,
        del,
    };
};

export { useApi };
