import {
  __commonJS,
  __require
} from "./chunk-7FP5O474.js";

// browser-external:worker_threads
var require_worker_threads = __commonJS({
  "browser-external:worker_threads"(exports, module2) {
    module2.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "worker_threads" has been externalized for browser compatibility. Cannot access "worker_threads.${key}" in client code. See http://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/usepython/dist/py.esm.js
function __rest(s, e) {
  var t = {};
  for (var p in s)
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
}
function __awaiter(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
var WorkerClass = null;
try {
  WorkerThreads = typeof module !== "undefined" && typeof module.require === "function" && module.require("worker_threads") || typeof __non_webpack_require__ === "function" && __non_webpack_require__("worker_threads") || typeof __require === "function" && require_worker_threads();
  WorkerClass = WorkerThreads.Worker;
} catch (e) {
}
var WorkerThreads;
function decodeBase64$1(base64, enableUnicode) {
  return Buffer.from(base64, "base64").toString(enableUnicode ? "utf16" : "utf8");
}
function createBase64WorkerFactory$2(base64, sourcemapArg, enableUnicodeArg) {
  var sourcemap = sourcemapArg === void 0 ? null : sourcemapArg;
  var enableUnicode = enableUnicodeArg === void 0 ? false : enableUnicodeArg;
  var source = decodeBase64$1(base64, enableUnicode);
  var start = source.indexOf("\n", 10) + 1;
  var body = source.substring(start) + (sourcemap ? "//# sourceMappingURL=" + sourcemap : "");
  return function WorkerFactory2(options) {
    return new WorkerClass(body, Object.assign({}, options, { eval: true }));
  };
}
function decodeBase64(base64, enableUnicode) {
  var binaryString = atob(base64);
  if (enableUnicode) {
    var binaryView = new Uint8Array(binaryString.length);
    for (var i = 0, n = binaryString.length; i < n; ++i) {
      binaryView[i] = binaryString.charCodeAt(i);
    }
    return String.fromCharCode.apply(null, new Uint16Array(binaryView.buffer));
  }
  return binaryString;
}
function createURL(base64, sourcemapArg, enableUnicodeArg) {
  var sourcemap = sourcemapArg === void 0 ? null : sourcemapArg;
  var enableUnicode = enableUnicodeArg === void 0 ? false : enableUnicodeArg;
  var source = decodeBase64(base64, enableUnicode);
  var start = source.indexOf("\n", 10) + 1;
  var body = source.substring(start) + (sourcemap ? "//# sourceMappingURL=" + sourcemap : "");
  var blob = new Blob([body], { type: "application/javascript" });
  return URL.createObjectURL(blob);
}
function createBase64WorkerFactory$1(base64, sourcemapArg, enableUnicodeArg) {
  var url;
  return function WorkerFactory2(options) {
    url = url || createURL(base64, sourcemapArg, enableUnicodeArg);
    return new Worker(url, options);
  };
}
var kIsNodeJS = Object.prototype.toString.call(typeof process !== "undefined" ? process : 0) === "[object process]";
function isNodeJS() {
  return kIsNodeJS;
}
function createBase64WorkerFactory(base64, sourcemapArg, enableUnicodeArg) {
  if (isNodeJS()) {
    return createBase64WorkerFactory$2(base64, sourcemapArg, enableUnicodeArg);
  }
  return createBase64WorkerFactory$1(base64, sourcemapArg, enableUnicodeArg);
}
var WorkerFactory = createBase64WorkerFactory("Lyogcm9sbHVwLXBsdWdpbi13ZWItd29ya2VyLWxvYWRlciAqLwooZnVuY3Rpb24gKCkgewogICd1c2Ugc3RyaWN0JzsKCiAgaW1wb3J0U2NyaXB0cygiaHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L3B5b2RpZGUvdjAuMjEuMC9mdWxsL3B5b2RpZGUuanMiKTsKCiAgbGV0IGlzUHlMb2FkZWQgPSBmYWxzZTsKCiAgZnVuY3Rpb24gc3Rkb3V0KG1zZykgewogICAgc2VsZi5wb3N0TWVzc2FnZSh7IHR5cGU6ICJzdGRvdXQiLCBtc2c6IG1zZywgaWQ6IG51bGwgfSk7CiAgfQoKICBmdW5jdGlvbiBzdGRlcnIobXNnKSB7CiAgICBzZWxmLnBvc3RNZXNzYWdlKHsgdHlwZTogInN0ZGVyciIsIG1zZzogbXNnLCBpZDogbnVsbCB9KTsKICB9CgogIGZ1bmN0aW9uIGluc3RhbGxMb2coaWQsIHN0YWdlLCBtc2cpIHsKICAgIHNlbGYucG9zdE1lc3NhZ2UoewogICAgICB0eXBlOiAiaW5zdGFsbGxvZyIsIG1zZzogewogICAgICAgIHN0YWdlOiBzdGFnZSwKICAgICAgICBtc2c6IG1zZwogICAgICB9LCBpZDogaWQKICAgIH0pOwogIH0KCiAgZnVuY3Rpb24gZXJyKGlkLCBtc2cpIHsKICAgIHNlbGYucG9zdE1lc3NhZ2UoeyB0eXBlOiAiZXJyIiwgbXNnOiBtc2csIGlkOiBpZCB9KTsKICB9CgogIGZ1bmN0aW9uIGVuZChpZCwgcmVzKSB7CiAgICBzZWxmLnBvc3RNZXNzYWdlKHsgdHlwZTogImVuZCIsIHJlczogcmVzID8/IG51bGwsIGlkOiBpZCB9KTsKICB9CgogIGFzeW5jIGZ1bmN0aW9uIGxvYWRQeW9kaWRlQW5kUGFja2FnZXMoaWQsIHB5b1BhY2thZ2VzLCBwYWNrYWdlcywgaW5pdENvZGUsIHRyYW5zZm9ybUNvZGUpIHsKICAgIGluc3RhbGxMb2coaWQsIDEsICJMb2FkaW5nIHB5dGhvbiBydW50aW1lIik7CiAgICBzZWxmLnB5b2RpZGUgPSBhd2FpdCBsb2FkUHlvZGlkZSh7CiAgICAgIHN0ZG91dDogc3Rkb3V0LAogICAgICBzdGRlcnI6IHN0ZGVyciwKICAgIH0pOwogICAgcHlvUGFja2FnZXMudW5zaGlmdCgibWljcm9waXAiKTsKICAgIC8vaW5zdGFsbG9nKDIsIGBJbnN0YWxsaW5nIHB5dGhvbiBwYWNrYWdlcyAke3BhY2thZ2VzLmpvaW4oIiwgIil9YCk7CiAgICBpbnN0YWxsTG9nKGlkLCAyLCBgQ3JlYXRpbmcgcHl0aG9uIGVudmApOwogICAgYXdhaXQgc2VsZi5weW9kaWRlLmxvYWRQYWNrYWdlKHB5b1BhY2thZ2VzKTsKICAgIGluc3RhbGxMb2coaWQsIDMsIGBJbnN0YWxsaW5nIHB5dGhvbiBwYWNrYWdlc2ApOwogICAgc2VsZi5wYXJyYXkgPSBwYWNrYWdlczsKICAgIGF3YWl0IHB5b2RpZGUucnVuUHl0aG9uQXN5bmMoYAogIGltcG9ydCBtaWNyb3BpcAogIGZyb20ganMgaW1wb3J0IHBhcnJheQogIGF3YWl0IG1pY3JvcGlwLmluc3RhbGwocGFycmF5LnRvX3B5KCkpCiAgYCk7CiAgICBpbnN0YWxsTG9nKGlkLCA0LCBgSW5pdGlhbGl6aW5nIGVudmlyb25tZW50YCk7CiAgICBzZWxmLnBhcnJheSA9IHVuZGVmaW5lZDsKICAgIGNvbnN0IHNyYyA9IGBmcm9tIHB5b2RpZGUuY29kZSBpbXBvcnQgZXZhbF9jb2RlX2FzeW5jCmZyb20gcHlvZGlkZS5mZmkgaW1wb3J0IHRvX2pzCmFzeW5jIGRlZiBweWV2YWwoY29kZSwgbnMpOgogIHJlc3VsdCA9IGF3YWl0IGV2YWxfY29kZV9hc3luYyhjb2RlLCBucykKICAke3RyYW5zZm9ybUNvZGV9CiAgcmV0dXJuIHRvX2pzKHJlc3VsdClgOwogICAgLy9jb25zb2xlLmxvZygiU1JDIEVYRUMiLCBzcmMpCiAgICBhd2FpdCBweW9kaWRlLnJ1blB5dGhvbkFzeW5jKHNyYyk7CiAgICBpZiAoaW5pdENvZGUubGVuZ3RoID4gMCkgewogICAgICBhd2FpdCBweW9kaWRlLnJ1blB5dGhvbkFzeW5jKGluaXRDb2RlKTsKICAgIH0KICAgIGluc3RhbGxMb2coaWQsIDUsICJUaGUgcHl0aG9uIGVudiBpcyBsb2FkZWQiKTsKICAgIGlzUHlMb2FkZWQgPSB0cnVlOwogIH0KCiAgYXN5bmMgZnVuY3Rpb24gcnVuU2NyaXB0KHB5dGhvbiwgaWQpIHsKICAgIHRyeSB7CiAgICAgIC8vY29uc29sZS5sb2coIkxvYWQgaW1wb3J0cyIpCiAgICAgIGF3YWl0IHNlbGYucHlvZGlkZS5sb2FkUGFja2FnZXNGcm9tSW1wb3J0cyhweXRob24pOwogICAgICAvL2NvbnNvbGUubG9nKCJSdW4gcHkgYXN5bmMiKQogICAgICAvL2xldCByZXN1bHRzID0gYXdhaXQgc2VsZi5weW9kaWRlLnJ1blB5dGhvbkFzeW5jKHB5dGhvbik7CiAgICAgIGxldCByZXN1bHRzID0gYXdhaXQgcHlvZGlkZS5nbG9iYWxzLmdldCgicHlldmFsIikocHl0aG9uLCBweW9kaWRlLmdsb2JhbHMpOwogICAgICAvL2NvbnNvbGUubG9nKCJFbmQiKQogICAgICBlbmQoaWQsIHJlc3VsdHMpOwogICAgfSBjYXRjaCAoZXJyb3IpIHsKICAgICAgY29uc29sZS5sb2coIlBZIFJVTiBFUlIiLCBlcnJvcik7CiAgICAgIGVycihpZCwgZXJyb3IubWVzc2FnZSk7CiAgICB9CiAgfQoKICBzZWxmLm9ubWVzc2FnZSA9IGFzeW5jIChldmVudCkgPT4gewogICAgY29uc3QgeyBpZCwgcHl0aG9uLCAuLi5jb250ZXh0IH0gPSBldmVudC5kYXRhOwogICAgaWYgKGlkICE9ICJfcHlpbnN0YWxsZXIiKSB7CiAgICAgIC8vIFRoZSB3b3JrZXIgY29waWVzIHRoZSBjb250ZXh0IGluIGl0cyBvd24gIm1lbW9yeSIgKGFuIG9iamVjdCBtYXBwaW5nIG5hbWUgdG8gdmFsdWVzKQogICAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhjb250ZXh0KSkgewogICAgICAgIHNlbGZba2V5XSA9IGNvbnRleHRba2V5XTsKICAgICAgfQogICAgICBpZiAoIWlzUHlMb2FkZWQpIHsKICAgICAgICAvL2F3YWl0IGxvYWRQeW9kaWRlQW5kUGFja2FnZXMoaWQsIFtdKTsKICAgICAgICB0aHJvdyBuZXcgRXJyb3IoIlB5dGhvbiBpcyBub3QgbG9hZGVkIikKICAgICAgfQogICAgICBhd2FpdCBydW5TY3JpcHQocHl0aG9uLCBpZCk7CiAgICB9IGVsc2UgewogICAgICBhd2FpdCBsb2FkUHlvZGlkZUFuZFBhY2thZ2VzKGlkLCBjb250ZXh0LnB5b1BhY2thZ2VzLCBjb250ZXh0LnBhY2thZ2VzLCBjb250ZXh0LmluaXRDb2RlLCBjb250ZXh0LnRyYW5zZm9ybUNvZGUpOwogICAgICBlbmQoaWQpOwogICAgfQogIH07Cgp9KSgpOwoK", null, false);
var clean = Symbol("clean");
var MOUNT = 5;
var UNMOUNT = 6;
var REVERT_MUTATION = 10;
var on = (object, listener, eventKey, mutateStore) => {
  object.events = object.events || {};
  if (!object.events[eventKey + REVERT_MUTATION]) {
    object.events[eventKey + REVERT_MUTATION] = mutateStore((eventProps) => {
      object.events[eventKey].reduceRight((event, l) => (l(event), event), {
        shared: {},
        ...eventProps
      });
    });
  }
  object.events[eventKey] = object.events[eventKey] || [];
  object.events[eventKey].push(listener);
  return () => {
    let currentListeners = object.events[eventKey];
    let index = currentListeners.indexOf(listener);
    currentListeners.splice(index, 1);
    if (!currentListeners.length) {
      delete object.events[eventKey];
      object.events[eventKey + REVERT_MUTATION]();
      delete object.events[eventKey + REVERT_MUTATION];
    }
  };
};
var STORE_UNMOUNT_DELAY = 1e3;
var onMount = (store, initialize) => {
  let listener = (payload) => {
    let destroy = initialize(payload);
    if (destroy)
      store.events[UNMOUNT].push(destroy);
  };
  return on(store, listener, MOUNT, (runListeners) => {
    let originListen = store.listen;
    store.listen = (arg) => {
      if (!store.lc && !store.active) {
        runListeners();
        store.active = true;
      }
      return originListen(arg);
    };
    let originOff = store.off;
    store.events[UNMOUNT] = [];
    store.off = () => {
      setTimeout(() => {
        if (store.active && !store.lc) {
          store.active = false;
          for (let destroy of store.events[UNMOUNT])
            destroy();
          store.events[UNMOUNT] = [];
          originOff();
        }
      }, STORE_UNMOUNT_DELAY);
    };
    if (true) {
      let originClean = store[clean];
      store[clean] = () => {
        for (let destroy of store.events[UNMOUNT])
          destroy();
        store.events[UNMOUNT] = [];
        store.active = false;
        originClean();
      };
    }
    return () => {
      store.listen = originListen;
      store.off = originOff;
    };
  });
};
var listenerQueue = [];
var notifyId = 0;
var atom = (initialValue) => {
  let currentListeners;
  let nextListeners = [];
  let store = {
    lc: 0,
    value: initialValue,
    set(data) {
      store.value = data;
      store.notify();
    },
    get() {
      if (!store.lc) {
        store.listen(() => {
        })();
      }
      return store.value;
    },
    notify(changedKey) {
      currentListeners = nextListeners;
      let runListenerQueue = !listenerQueue.length;
      for (let i = 0; i < currentListeners.length; i++) {
        listenerQueue.push(currentListeners[i], store.value, changedKey);
      }
      if (runListenerQueue) {
        notifyId++;
        for (let i = 0; i < listenerQueue.length; i += 3) {
          listenerQueue[i](listenerQueue[i + 1], listenerQueue[i + 2]);
        }
        listenerQueue.length = 0;
      }
    },
    listen(listener) {
      if (nextListeners === currentListeners) {
        nextListeners = nextListeners.slice();
      }
      store.lc = nextListeners.push(listener);
      return () => {
        if (nextListeners === currentListeners) {
          nextListeners = nextListeners.slice();
        }
        let index = nextListeners.indexOf(listener);
        if (~index) {
          nextListeners.splice(index, 1);
          store.lc--;
          if (!store.lc)
            store.off();
        }
      };
    },
    subscribe(cb) {
      let unbind = store.listen(cb);
      cb(store.value);
      return unbind;
    },
    off() {
    }
    /* It will be called on last listener unsubscribing.
       We will redefine it in onMount and onStop. */
  };
  if (true) {
    store[clean] = () => {
      nextListeners = [];
      store.lc = 0;
      store.off();
    };
  }
  return store;
};
var map = (value = {}) => {
  let store = atom(value);
  store.setKey = function(key, newValue) {
    if (typeof newValue === "undefined") {
      if (key in store.value) {
        store.value = { ...store.value };
        delete store.value[key];
        store.notify(key);
      }
    } else if (store.value[key] !== newValue) {
      store.value = {
        ...store.value,
        [key]: newValue
      };
      store.notify(key);
    }
  };
  return store;
};
var computed = (stores, cb) => {
  if (!Array.isArray(stores))
    stores = [stores];
  let diamondNotifyId;
  let diamondArgs = [];
  let run = () => {
    let args = stores.map((store) => store.get());
    if (diamondNotifyId !== notifyId || args.some((arg, i) => arg !== diamondArgs[i])) {
      diamondNotifyId = notifyId;
      diamondArgs = args;
      derived.set(cb(...args));
    }
  };
  let derived = atom();
  onMount(derived, () => {
    let unbinds = stores.map(
      (store) => store.listen(run, cb)
    );
    run();
    return () => {
      for (let unbind of unbinds)
        unbind();
    };
  });
  return derived;
};
var pyLog = map({
  id: "",
  stdOut: [],
  stdErr: [],
  exception: ""
});
var pyInstallLog = map({
  stage: 0,
  msg: ""
});
var pyExecState = atom(0);
var isPyReadyState = atom(0);
var isPyExecuting = computed(pyExecState, (all) => {
  return all === 1;
});
var isPyReady = computed(isPyReadyState, (all) => {
  return all === 1;
});
var usePython = () => {
  const _pyodideWorker = new WorkerFactory();
  let _callback = (v) => null;
  function _dispatchEvent(id, data) {
    switch (data.type) {
      case "end":
        _callback({ results: data.res, error: null });
        _callback = (v) => null;
        pyExecState.set(0);
        break;
      case "err":
        _callback = (v) => null;
        pyExecState.set(0);
        pyLog.setKey("exception", data.msg);
        break;
      case "installlog":
        pyInstallLog.setKey("stage", data.msg.stage);
        pyInstallLog.setKey("msg", data.msg.msg);
        break;
      case "stderr":
        pyLog.get().stdErr.push(data.msg);
        pyLog.notify();
        break;
      case "stdout":
        pyLog.get().stdOut.push(data.msg);
        pyLog.notify();
        break;
      default:
        pyExecState.set(0);
        throw new Error(`Unknown event type ${data.type}`);
    }
  }
  _pyodideWorker.onmessage = (event) => {
    const _a = event.data, { id } = _a, data = __rest(_a, ["id"]);
    _dispatchEvent(id !== null && id !== void 0 ? id : "", data);
  };
  function _processTransformCode(code) {
    if (code.startsWith("\n")) {
      code.replace("\n", "");
    }
    const li = code.split("\n");
    const buf = new Array();
    li.forEach((el) => {
      buf.push("  " + el);
    });
    return buf.join("\n");
  }
  function load(pyoPackages = [], packages = [], initCode = "", transformCode = "") {
    return __awaiter(this, void 0, void 0, function* () {
      let res;
      try {
        res = yield run("", "_pyinstaller", {
          pyoPackages,
          packages,
          initCode,
          transformCode: _processTransformCode(transformCode)
        });
      } catch (e) {
        throw new Error(`Error in pyodideWorker at ${e.filename}, Line: ${e.lineno}, ${e.message}`);
      }
      isPyReadyState.set(1);
      return res;
    });
  }
  function run(script, id, context = {}) {
    return __awaiter(this, void 0, void 0, function* () {
      if (pyExecState.get() === 1) {
        throw new Error("Only one python script can run at the time");
      }
      pyExecState.set(1);
      const _id = id !== null && id !== void 0 ? id : (+new Date()).toString();
      pyLog.set({
        id: _id,
        stdOut: [],
        stdErr: [],
        exception: ""
      });
      return new Promise((onSuccess) => {
        _callback = onSuccess;
        _pyodideWorker.postMessage(Object.assign({ id: _id, python: script }, context));
      });
    });
  }
  return {
    load,
    run,
    installLog: pyInstallLog,
    log: pyLog,
    isExecuting: isPyExecuting,
    isReady: isPyReady
  };
};
export {
  usePython
};
//# sourceMappingURL=usepython.js.map
