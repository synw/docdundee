import "./chunk-7FP5O474.js";

// node_modules/restmix/dist/api.es.js
function __awaiter(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
function assign(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];
    for (var key in source) {
      target[key] = source[key];
    }
  }
  return target;
}
var defaultConverter = {
  read: function(value) {
    if (value[0] === '"') {
      value = value.slice(1, -1);
    }
    return value.replace(/(%[\dA-F]{2})+/gi, decodeURIComponent);
  },
  write: function(value) {
    return encodeURIComponent(value).replace(
      /%(2[346BF]|3[AC-F]|40|5[BDE]|60|7[BCD])/g,
      decodeURIComponent
    );
  }
};
function init(converter, defaultAttributes) {
  function set(key, value, attributes) {
    if (typeof document === "undefined") {
      return;
    }
    attributes = assign({}, defaultAttributes, attributes);
    if (typeof attributes.expires === "number") {
      attributes.expires = new Date(Date.now() + attributes.expires * 864e5);
    }
    if (attributes.expires) {
      attributes.expires = attributes.expires.toUTCString();
    }
    key = encodeURIComponent(key).replace(/%(2[346B]|5E|60|7C)/g, decodeURIComponent).replace(/[()]/g, escape);
    var stringifiedAttributes = "";
    for (var attributeName in attributes) {
      if (!attributes[attributeName]) {
        continue;
      }
      stringifiedAttributes += "; " + attributeName;
      if (attributes[attributeName] === true) {
        continue;
      }
      stringifiedAttributes += "=" + attributes[attributeName].split(";")[0];
    }
    return document.cookie = key + "=" + converter.write(value, key) + stringifiedAttributes;
  }
  function get(key) {
    if (typeof document === "undefined" || arguments.length && !key) {
      return;
    }
    var cookies = document.cookie ? document.cookie.split("; ") : [];
    var jar = {};
    for (var i = 0; i < cookies.length; i++) {
      var parts = cookies[i].split("=");
      var value = parts.slice(1).join("=");
      try {
        var foundKey = decodeURIComponent(parts[0]);
        jar[foundKey] = converter.read(value, foundKey);
        if (key === foundKey) {
          break;
        }
      } catch (e) {
      }
    }
    return key ? jar[key] : jar;
  }
  return Object.create(
    {
      set,
      get,
      remove: function(key, attributes) {
        set(
          key,
          "",
          assign({}, attributes, {
            expires: -1
          })
        );
      },
      withAttributes: function(attributes) {
        return init(this.converter, assign({}, this.attributes, attributes));
      },
      withConverter: function(converter2) {
        return init(assign({}, this.converter, converter2), this.attributes);
      }
    },
    {
      attributes: { value: Object.freeze(defaultAttributes) },
      converter: { value: Object.freeze(converter) }
    }
  );
}
var api = init(defaultConverter, { path: "/" });
var useApi = (params = {
  serverUrl: "",
  csrfCookieName: "csrftoken",
  csrfHeaderKey: "X-CSRFToken",
  credentials: "include",
  mode: "cors"
}) => {
  var _a, _b, _c, _d, _e;
  let _serverUrl = (_a = params.serverUrl) !== null && _a !== void 0 ? _a : "";
  let _csrfCookieName = (_b = params === null || params === void 0 ? void 0 : params.csrfCookieName) !== null && _b !== void 0 ? _b : "csrftoken";
  let _csrfHeaderKey = (_c = params === null || params === void 0 ? void 0 : params.csrfHeaderKey) !== null && _c !== void 0 ? _c : "X-CSRFToken";
  let _mode = (_d = params === null || params === void 0 ? void 0 : params.mode) !== null && _d !== void 0 ? _d : "cors";
  let _credentials = (_e = params.credentials) !== null && _e !== void 0 ? _e : "include";
  let _csrfToken = null;
  let _extraHeaders = {};
  let _hasExtraHeaders = false;
  let _onResponse;
  const csrfToken = () => _csrfToken;
  const hasCsrfCookie = () => {
    const cookie = api.get(_csrfCookieName);
    if (cookie) {
      return true;
    }
    return false;
  };
  const _csrfFromCookie = () => {
    const c = api.get(_csrfCookieName);
    if (!c) {
      throw "Csrf cookie not found";
    }
    return c;
  };
  const addHeader = (key, val) => {
    _extraHeaders[key] = val;
    _hasExtraHeaders = true;
  };
  const removeHeader = (key) => {
    delete _extraHeaders[key];
    if (Object.keys(_extraHeaders).length == 0) {
      _hasExtraHeaders = false;
    }
  };
  const onResponse = (hook) => {
    _onResponse = hook;
  };
  const setCsrfToken = (token) => {
    _csrfToken = token;
  };
  const setCsrfTokenFromCookie = (verbose = false) => {
    if (hasCsrfCookie()) {
      _csrfToken = _csrfFromCookie();
      if (verbose) {
        console.log("User logged in with csrf cookie, setting api token", _csrfToken);
      }
      return true;
    } else {
      if (verbose) {
        console.log("User does not have csrf cookie");
      }
    }
    return false;
  };
  const _processResponse = (response) => __awaiter(void 0, void 0, void 0, function* () {
    var _f;
    const head = {};
    response.headers.forEach((v, k) => head[k] = v);
    let apiResp = {
      ok: response.ok,
      url: response.url,
      headers: head,
      status: response.status,
      statusText: response.statusText,
      data: {},
      text: ""
    };
    if (!(response.status == 204)) {
      if (!((_f = response.headers.get("Content-Type")) === null || _f === void 0 ? void 0 : _f.startsWith("application/json"))) {
        const txt = yield response.text();
        apiResp.text = txt;
      } else {
        try {
          apiResp.data = yield response.json();
        } catch (e) {
          console.warn(`Json parsing error: ${e}`);
        }
      }
    }
    if (_onResponse) {
      apiResp = yield _onResponse(apiResp);
    }
    return apiResp;
  });
  const post = (uri, payload, multipart = false, verbose = false) => __awaiter(void 0, void 0, void 0, function* () {
    const opts = _postHeader(payload, "post", multipart);
    let url = _serverUrl + uri;
    if (verbose) {
      console.log("POST", url);
      console.log(JSON.stringify(opts, null, "  "));
    }
    const response = yield fetch(url, opts);
    return yield _processResponse(response);
  });
  const patch = (uri, payload, verbose = false) => __awaiter(void 0, void 0, void 0, function* () {
    const opts = _postHeader(payload, "patch");
    let url = _serverUrl + uri;
    if (verbose) {
      console.log("PATCH", url);
      console.log(JSON.stringify(opts, null, "  "));
    }
    const response = yield fetch(url, opts);
    return yield _processResponse(response);
  });
  const put = (uri, payload, verbose = false) => __awaiter(void 0, void 0, void 0, function* () {
    let url = _serverUrl + uri;
    const opts = _postHeader(payload, "put");
    if (verbose) {
      console.log("PUT", url);
      console.log(JSON.stringify(opts, null, "  "));
    }
    const response = yield fetch(url, opts);
    return yield _processResponse(response);
  });
  const get = (uri, verbose = false) => __awaiter(void 0, void 0, void 0, function* () {
    let url = _serverUrl + uri;
    const opts = _getHeader("get");
    if (verbose) {
      console.log("GET", url);
      console.log(JSON.stringify(opts, null, "  "));
    }
    const response = yield fetch(url, opts);
    return yield _processResponse(response);
  });
  const del = (uri, verbose = false) => __awaiter(void 0, void 0, void 0, function* () {
    const url = _serverUrl + uri;
    const opts = _getHeader("delete");
    if (verbose) {
      console.log("DELETE", url);
      console.log(JSON.stringify(opts, null, "  "));
    }
    const response = yield fetch(url, opts);
    return yield _processResponse(response);
  });
  const _getHeader = (method = "get") => {
    const h = {
      method,
      mode: _mode
    };
    if (_credentials !== null) {
      h.credentials = _credentials;
    }
    const headers = { "Content-Type": "application/json" };
    h.headers = _getBaseHeaders(headers);
    return h;
  };
  const _postHeader = (payload, method = "post", multipart = false) => {
    const pl = multipart ? payload : JSON.stringify(payload);
    const r = {
      method,
      mode: _mode,
      body: pl
    };
    let headers;
    if (!multipart) {
      headers = { "Content-Type": "application/json" };
    } else {
      headers = { "Content-Type": "multipart/form-data" };
    }
    if (_credentials !== null) {
      r.credentials = _credentials;
    }
    r.headers = _getBaseHeaders(headers);
    return r;
  };
  function _getBaseHeaders(headers) {
    if (_csrfToken !== null) {
      headers[_csrfHeaderKey] = _csrfToken;
    }
    if (_hasExtraHeaders) {
      for (const [k, v] of Object.entries(_extraHeaders)) {
        headers[k] = v;
      }
    }
    return headers;
  }
  return {
    csrfToken,
    hasCsrfCookie,
    setCsrfToken,
    setCsrfTokenFromCookie,
    addHeader,
    removeHeader,
    onResponse,
    get,
    post,
    put,
    patch,
    del
  };
};
export {
  useApi
};
/*! Bundled license information:

restmix/dist/api.es.js:
  (*! js-cookie v3.0.1 | MIT *)
*/
//# sourceMappingURL=restmix.js.map
