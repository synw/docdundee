import { ref, getCurrentScope, onScopeDispose, defineComponent, toRefs, openBlock, createElementBlock, renderSlot, createCommentVNode, createElementVNode, computed, normalizeClass } from "vue";
function tryOnScopeDispose(fn) {
  if (getCurrentScope()) {
    onScopeDispose(fn);
    return true;
  }
  return false;
}
const isClient = typeof window !== "undefined";
function increaseWithUnit(target, delta) {
  var _a;
  if (typeof target === "number")
    return target + delta;
  const value = ((_a = target.match(/^-?[0-9]+\.?[0-9]*/)) == null ? void 0 : _a[0]) || "";
  const unit = target.slice(value.length);
  const result = parseFloat(value) + delta;
  if (Number.isNaN(result))
    return target;
  return result + unit;
}
const defaultWindow = isClient ? window : void 0;
function useMediaQuery(query, options = {}) {
  const { window: window2 = defaultWindow } = options;
  if (!window2)
    return ref(false);
  const mediaQuery = window2.matchMedia(query);
  const matches = ref(mediaQuery.matches);
  const handler = (event) => {
    matches.value = event.matches;
  };
  if ("addEventListener" in mediaQuery)
    mediaQuery.addEventListener("change", handler);
  else
    mediaQuery.addListener(handler);
  tryOnScopeDispose(() => {
    if ("removeEventListener" in mediaQuery)
      mediaQuery.removeEventListener("change", handler);
    else
      mediaQuery.removeListener(handler);
  });
  return matches;
}
const breakpointsTailwind = {
  "sm": 640,
  "md": 768,
  "lg": 1024,
  "xl": 1280,
  "2xl": 1536
};
var __defProp$b = Object.defineProperty;
var __getOwnPropSymbols$d = Object.getOwnPropertySymbols;
var __hasOwnProp$d = Object.prototype.hasOwnProperty;
var __propIsEnum$d = Object.prototype.propertyIsEnumerable;
var __defNormalProp$b = (obj, key, value) => key in obj ? __defProp$b(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$b = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$d.call(b, prop))
      __defNormalProp$b(a, prop, b[prop]);
  if (__getOwnPropSymbols$d)
    for (var prop of __getOwnPropSymbols$d(b)) {
      if (__propIsEnum$d.call(b, prop))
        __defNormalProp$b(a, prop, b[prop]);
    }
  return a;
};
function useBreakpoints(breakpoints, options = {}) {
  function getValue(k, delta) {
    let v = breakpoints[k];
    if (delta != null)
      v = increaseWithUnit(v, delta);
    if (typeof v === "number")
      v = `${v}px`;
    return v;
  }
  const { window: window2 = defaultWindow } = options;
  function match(query) {
    if (!window2)
      return false;
    return window2.matchMedia(query).matches;
  }
  const greater = (k) => {
    return useMediaQuery(`(min-width: ${getValue(k)})`, options);
  };
  const shortcutMethods = Object.keys(breakpoints).reduce((shortcuts, k) => {
    Object.defineProperty(shortcuts, k, {
      get: () => greater(k),
      enumerable: true,
      configurable: true
    });
    return shortcuts;
  }, {});
  return __spreadValues$b({
    greater,
    smaller(k) {
      return useMediaQuery(`(max-width: ${getValue(k, -0.1)})`, options);
    },
    between(a, b) {
      return useMediaQuery(`(min-width: ${getValue(a)}) and (max-width: ${getValue(b, -0.1)})`, options);
    },
    isGreater(k) {
      return match(`(min-width: ${getValue(k)})`);
    },
    isSmaller(k) {
      return match(`(max-width: ${getValue(k, -0.1)})`);
    },
    isInBetween(a, b) {
      return match(`(min-width: ${getValue(a)}) and (max-width: ${getValue(b, -0.1)})`);
    }
  }, shortcutMethods);
}
var SwipeDirection;
(function(SwipeDirection2) {
  SwipeDirection2["UP"] = "UP";
  SwipeDirection2["RIGHT"] = "RIGHT";
  SwipeDirection2["DOWN"] = "DOWN";
  SwipeDirection2["LEFT"] = "LEFT";
  SwipeDirection2["NONE"] = "NONE";
})(SwipeDirection || (SwipeDirection = {}));
const twbreakpoints = useBreakpoints(breakpointsTailwind);
function useScreenSize(mobileBreakpoint = "sm", tabletBreakpoint = "lg") {
  const isMobile = twbreakpoints.smaller(mobileBreakpoint);
  const isTablet = twbreakpoints.between(mobileBreakpoint, tabletBreakpoint);
  const isDesktop = twbreakpoints.greater(tabletBreakpoint);
  return {
    isMobile,
    isTablet,
    isDesktop
  };
}
var _export_sfc = (sfc, props) => {
  const target = sfc.__vccOpts || sfc;
  for (const [key, val] of props) {
    target[key] = val;
  }
  return target;
};
const _sfc_main$1 = defineComponent({
  props: {
    breakpoint: {
      type: String,
      default: () => "sm"
    }
  },
  emits: ["togglemenu"],
  setup(props, { emit }) {
    const { breakpoint } = toRefs(props);
    const { isMobile } = useScreenSize(breakpoint.value, "lg");
    function onClick() {
      emit("togglemenu");
    }
    function back() {
      if (history.length > 0) {
        history.back();
      }
    }
    return {
      onClick,
      back,
      isMobile
    };
  }
});
const _hoisted_1 = { class: "flex flex-row items-center" };
const _hoisted_2 = {
  key: 0,
  class: "flex-none"
};
const _hoisted_3 = {
  key: 1,
  class: "inline-flex flex-row items-center h-full"
};
const _hoisted_4 = {
  key: 2,
  class: "flex-grow h-full"
};
const _hoisted_5 = {
  key: 3,
  class: "flex items-center justify-end flex-grow h-full cursor-pointer"
};
const _hoisted_6 = /* @__PURE__ */ createElementVNode("div", { class: "mr-5 text-3xl" }, [
  /* @__PURE__ */ createElementVNode("svg", {
    class: "fill-current",
    xmlns: "http://www.w3.org/2000/svg",
    "xmlns:xlink": "http://www.w3.org/1999/xlink",
    "aria-hidden": "true",
    focusable: "false",
    width: "1em",
    height: "1em",
    preserveAspectRatio: "xMidYMid meet",
    viewBox: "0 0 24 24"
  }, [
    /* @__PURE__ */ createElementVNode("g", null, [
      /* @__PURE__ */ createElementVNode("path", {
        "fill-rule": "evenodd",
        "clip-rule": "evenodd",
        d: "M2 6a2 2 0 0 1 2-2h16a2 2 0 1 1 0 4H4a2 2 0 0 1-2-2zm0 6a2 2 0 0 1 2-2h16a2 2 0 1 1 0 4H4a2 2 0 0 1-2-2zm0 6a2 2 0 0 1 2-2h16a2 2 0 1 1 0 4H4a2 2 0 0 1-2-2z"
      })
    ])
  ])
], -1);
function _sfc_render$1(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", _hoisted_1, [
    !_ctx.isMobile ? (openBlock(), createElementBlock("div", _hoisted_2, [
      renderSlot(_ctx.$slots, "branding")
    ])) : createCommentVNode("", true),
    _ctx.isMobile ? (openBlock(), createElementBlock("div", _hoisted_3, [
      createElementVNode("div", {
        onClick: _cache[0] || (_cache[0] = ($event) => _ctx.back())
      }, [
        renderSlot(_ctx.$slots, "mobile-back")
      ]),
      renderSlot(_ctx.$slots, "mobile-branding")
    ])) : createCommentVNode("", true),
    !_ctx.isMobile ? (openBlock(), createElementBlock("div", _hoisted_4, [
      renderSlot(_ctx.$slots, "menu")
    ])) : createCommentVNode("", true),
    _ctx.isMobile ? (openBlock(), createElementBlock("div", _hoisted_5, [
      createElementVNode("div", {
        class: "border-none btn",
        onClick: _cache[1] || (_cache[1] = ($event) => _ctx.onClick())
      }, [
        renderSlot(_ctx.$slots, "menuicon", {}, () => [
          _hoisted_6
        ])
      ])
    ])) : createCommentVNode("", true)
  ]);
}
var SwHeader = /* @__PURE__ */ _export_sfc(_sfc_main$1, [["render", _sfc_render$1]]);
const _sfc_main = defineComponent({
  props: {
    isVisible: {
      type: Boolean,
      required: true
    },
    breakpoint: {
      type: String,
      default: () => "sm"
    }
  },
  setup(props) {
    const { isVisible, breakpoint } = toRefs(props);
    const css = computed(() => {
      const cl = {
        "slide-y": true,
        "slideup": isVisible.value === false,
        "slidedown": isVisible.value === true
      };
      let bp = "";
      switch (breakpoint.value) {
        case "sm":
          bp = "sm:hidden";
          break;
        case "md":
          bp = "md:hidden";
          break;
        case "lg":
          bp = "lg:hidden";
          break;
        case "xl":
          bp = "xl:hidden";
          break;
        case "2xl":
          bp = "2xl:hidden";
          break;
      }
      cl[`${bp}`] = true;
      return cl;
    });
    return {
      css
    };
  }
});
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", {
    class: normalizeClass([_ctx.css, "w-full"])
  }, [
    renderSlot(_ctx.$slots, "default")
  ], 2);
}
var SwMobileMenu = /* @__PURE__ */ _export_sfc(_sfc_main, [["render", _sfc_render]]);
export { SwHeader, SwMobileMenu };
